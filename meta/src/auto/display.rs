// Generated by gir (https://github.com/gtk-rs/gir @ 5bbf6cb)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

use crate::Compositor;
use crate::Cursor;
use crate::DisplayDirection;
use crate::GrabOp;
use crate::KeyBinding;
use crate::KeyBindingFlags;
use crate::PadActionType;
use crate::Rectangle;
use crate::Selection;
use crate::TabList;
use crate::Window;
use crate::Workspace;
use crate::WorkspaceManager;
use glib::object::IsA;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "MetaDisplay")]
    pub struct Display(Object<ffi::MetaDisplay, ffi::MetaDisplayClass>);

    match fn {
        type_ => || ffi::meta_display_get_type(),
    }
}

impl Display {
    /// Save the specified serial and ignore crossing events with that
    /// serial for the purpose of focus-follows-mouse. This can be used
    /// for certain changes to the window hierarchy that we don't want
    /// to change the focus window, even if they cause the pointer to
    /// end up in a new window.
    /// ## `serial`
    /// the serial to ignore
    #[doc(alias = "meta_display_add_ignored_crossing_serial")]
    pub fn add_ignored_crossing_serial(&self, serial: libc::c_ulong) {
        unsafe {
            ffi::meta_display_add_ignored_crossing_serial(self.to_glib_none().0, serial);
        }
    }

    /// Add a keybinding at runtime. The key `name` in `schema` needs to be of
    /// type `G_VARIANT_TYPE_STRING_ARRAY`, with each string describing a
    /// keybinding in the form of "&lt;Control&gt;a" or "&lt;Shift&gt;&lt;Alt&gt;F1". The parser
    /// is fairly liberal and allows lower or upper case, and also abbreviations
    /// such as "&lt;Ctl&gt;" and "&lt;Ctrl&gt;". If the key is set to the empty list or a
    /// list with a single element of either "" or "disabled", the keybinding is
    /// disabled.
    ///
    /// Use [`remove_keybinding()`][Self::remove_keybinding()] to remove the binding.
    /// ## `name`
    /// the binding's name
    /// ## `settings`
    /// the [`gio::Settings`][crate::gio::Settings] object where `name` is stored
    /// ## `flags`
    /// flags to specify binding details
    /// ## `handler`
    /// function to run when the keybinding is invoked
    /// ## `free_data`
    /// function to free `user_data`
    ///
    /// # Returns
    ///
    /// the corresponding keybinding action if the keybinding was
    ///  added successfully, otherwise `META_KEYBINDING_ACTION_NONE`
    #[doc(alias = "meta_display_add_keybinding")]
    pub fn add_keybinding<P: IsA<gio::Settings>, Q: Fn(&Display, &Window, Option<&clutter::KeyEvent>, &KeyBinding) + 'static>(&self, name: &str, settings: &P, flags: KeyBindingFlags, handler: Q) -> u32 {
        let handler_data: Box_<Q> = Box_::new(handler);
        unsafe extern "C" fn handler_func<P: IsA<gio::Settings>, Q: Fn(&Display, &Window, Option<&clutter::KeyEvent>, &KeyBinding) + 'static>(display: *mut ffi::MetaDisplay, window: *mut ffi::MetaWindow, event: *mut clutter::ffi::ClutterKeyEvent, binding: *mut ffi::MetaKeyBinding, user_data: glib::ffi::gpointer) {
            let display = from_glib_borrow(display);
            let window = from_glib_borrow(window);
            let event: Borrowed<Option<clutter::KeyEvent>> = from_glib_borrow(event);
            let binding = from_glib_borrow(binding);
            let callback: &Q = &*(user_data as *mut _);
            (*callback)(&display, &window, event.as_ref().as_ref(), &binding);
        }
        let handler = Some(handler_func::<P, Q> as _);
        unsafe extern "C" fn free_data_func<P: IsA<gio::Settings>, Q: Fn(&Display, &Window, Option<&clutter::KeyEvent>, &KeyBinding) + 'static>(data: glib::ffi::gpointer) {
            let _callback: Box_<Q> = Box_::from_raw(data as *mut _);
        }
        let destroy_call6 = Some(free_data_func::<P, Q> as _);
        let super_callback0: Box_<Q> = handler_data;
        unsafe {
            ffi::meta_display_add_keybinding(self.to_glib_none().0, name.to_glib_none().0, settings.as_ref().to_glib_none().0, flags.into_glib(), handler, Box_::into_raw(super_callback0) as *mut _, destroy_call6)
        }
    }

    #[doc(alias = "meta_display_begin_grab_op")]
    pub fn begin_grab_op(&self, window: &Window, op: GrabOp, pointer_already_grabbed: bool, frame_action: bool, button: i32, modmask: libc::c_ulong, timestamp: u32, root_x: i32, root_y: i32) -> bool {
        unsafe {
            from_glib(ffi::meta_display_begin_grab_op(self.to_glib_none().0, window.to_glib_none().0, op.into_glib(), pointer_already_grabbed.into_glib(), frame_action.into_glib(), button, modmask, timestamp, root_x, root_y))
        }
    }

    /// Sets the mouse-mode flag to [`false`], which means that motion events are
    /// no longer ignored in mouse or sloppy focus.
    /// This is an internal function. It should be used only for reimplementing
    /// keybindings, and only in a manner compatible with core code.
    #[doc(alias = "meta_display_clear_mouse_mode")]
    pub fn clear_mouse_mode(&self) {
        unsafe {
            ffi::meta_display_clear_mouse_mode(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_display_close")]
    pub fn close(&self, timestamp: u32) {
        unsafe {
            ffi::meta_display_close(self.to_glib_none().0, timestamp);
        }
    }

    #[doc(alias = "meta_display_end_grab_op")]
    pub fn end_grab_op(&self, timestamp: u32) {
        unsafe {
            ffi::meta_display_end_grab_op(self.to_glib_none().0, timestamp);
        }
    }

    #[doc(alias = "meta_display_focus_default_window")]
    pub fn focus_default_window(&self, timestamp: u32) {
        unsafe {
            ffi::meta_display_focus_default_window(self.to_glib_none().0, timestamp);
        }
    }

    #[doc(alias = "meta_display_freeze_keyboard")]
    pub fn freeze_keyboard(&self, timestamp: u32) {
        unsafe {
            ffi::meta_display_freeze_keyboard(self.to_glib_none().0, timestamp);
        }
    }

    #[doc(alias = "meta_display_get_compositor")]
    #[doc(alias = "get_compositor")]
    pub fn compositor(&self) -> Option<Compositor> {
        unsafe {
            from_glib_none(ffi::meta_display_get_compositor(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_display_get_compositor_modifiers")]
    #[doc(alias = "get_compositor_modifiers")]
    pub fn compositor_modifiers(&self) -> clutter::ModifierType {
        unsafe {
            from_glib(ffi::meta_display_get_compositor_modifiers(self.to_glib_none().0))
        }
    }

    /// Gets the index of the monitor that currently has the mouse pointer.
    ///
    /// # Returns
    ///
    /// a monitor index
    #[doc(alias = "meta_display_get_current_monitor")]
    #[doc(alias = "get_current_monitor")]
    pub fn current_monitor(&self) -> i32 {
        unsafe {
            ffi::meta_display_get_current_monitor(self.to_glib_none().0)
        }
    }

    #[doc(alias = "meta_display_get_current_time")]
    #[doc(alias = "get_current_time")]
    pub fn current_time(&self) -> u32 {
        unsafe {
            ffi::meta_display_get_current_time(self.to_glib_none().0)
        }
    }

    #[doc(alias = "meta_display_get_current_time_roundtrip")]
    #[doc(alias = "get_current_time_roundtrip")]
    pub fn current_time_roundtrip(&self) -> u32 {
        unsafe {
            ffi::meta_display_get_current_time_roundtrip(self.to_glib_none().0)
        }
    }

    /// Get our best guess as to the "currently" focused window (that is,
    /// the window that we expect will be focused at the point when the X
    /// server processes our next request).
    ///
    /// # Returns
    ///
    /// The current focus window
    #[doc(alias = "meta_display_get_focus_window")]
    #[doc(alias = "get_focus_window")]
    pub fn focus_window(&self) -> Option<Window> {
        unsafe {
            from_glib_none(ffi::meta_display_get_focus_window(self.to_glib_none().0))
        }
    }

    /// Gets the current grab operation, if any.
    ///
    /// # Returns
    ///
    /// the current grab operation, or [`GrabOp::None`][crate::GrabOp::None] if
    /// Mutter doesn't currently have a grab. [`GrabOp::Compositor`][crate::GrabOp::Compositor] will
    /// be returned if a compositor-plugin modal operation is in effect
    /// (See `mutter_begin_modal_for_plugin()`)
    #[doc(alias = "meta_display_get_grab_op")]
    #[doc(alias = "get_grab_op")]
    pub fn grab_op(&self) -> GrabOp {
        unsafe {
            from_glib(ffi::meta_display_get_grab_op(self.to_glib_none().0))
        }
    }

    /// Get the keybinding action bound to `keycode`. Builtin keybindings
    /// have a fixed associated `MetaKeyBindingAction`, for bindings added
    /// dynamically the function will return the keybinding action
    /// [`add_keybinding()`][Self::add_keybinding()] returns on registration.
    /// ## `keycode`
    /// Raw keycode
    /// ## `mask`
    /// Event mask
    ///
    /// # Returns
    ///
    /// The action that should be taken for the given key, or
    /// `META_KEYBINDING_ACTION_NONE`.
    #[doc(alias = "meta_display_get_keybinding_action")]
    #[doc(alias = "get_keybinding_action")]
    pub fn keybinding_action(&self, keycode: u32, mask: libc::c_ulong) -> u32 {
        unsafe {
            ffi::meta_display_get_keybinding_action(self.to_glib_none().0, keycode, mask)
        }
    }

    ///
    /// # Returns
    ///
    /// Timestamp of the last user interaction event with a window
    #[doc(alias = "meta_display_get_last_user_time")]
    #[doc(alias = "get_last_user_time")]
    pub fn last_user_time(&self) -> u32 {
        unsafe {
            ffi::meta_display_get_last_user_time(self.to_glib_none().0)
        }
    }

    /// Stores the location and size of the indicated `monitor` in `geometry`.
    /// ## `monitor`
    /// the monitor number
    ///
    /// # Returns
    ///
    ///
    /// ## `geometry`
    /// location to store the monitor geometry
    #[doc(alias = "meta_display_get_monitor_geometry")]
    #[doc(alias = "get_monitor_geometry")]
    pub fn monitor_geometry(&self, monitor: i32) -> Rectangle {
        unsafe {
            let mut geometry = Rectangle::uninitialized();
            ffi::meta_display_get_monitor_geometry(self.to_glib_none().0, monitor, geometry.to_glib_none_mut().0);
            geometry
        }
    }

    /// Determines whether there is a fullscreen window obscuring the specified
    /// monitor. If there is a fullscreen window, the desktop environment will
    /// typically hide any controls that might obscure the fullscreen window.
    ///
    /// You can get notification when this changes by connecting to
    /// MetaDisplay::in-fullscreen-changed.
    /// ## `monitor`
    /// the monitor number
    ///
    /// # Returns
    ///
    /// [`true`] if there is a fullscreen window covering the specified monitor.
    #[doc(alias = "meta_display_get_monitor_in_fullscreen")]
    #[doc(alias = "get_monitor_in_fullscreen")]
    pub fn is_monitor_in_fullscreen(&self, monitor: i32) -> bool {
        unsafe {
            from_glib(ffi::meta_display_get_monitor_in_fullscreen(self.to_glib_none().0, monitor))
        }
    }

    #[doc(alias = "meta_display_get_monitor_index_for_rect")]
    #[doc(alias = "get_monitor_index_for_rect")]
    pub fn monitor_index_for_rect(&self, rect: &mut Rectangle) -> i32 {
        unsafe {
            ffi::meta_display_get_monitor_index_for_rect(self.to_glib_none().0, rect.to_glib_none_mut().0)
        }
    }

    #[doc(alias = "meta_display_get_monitor_neighbor_index")]
    #[doc(alias = "get_monitor_neighbor_index")]
    pub fn monitor_neighbor_index(&self, which_monitor: i32, dir: DisplayDirection) -> i32 {
        unsafe {
            ffi::meta_display_get_monitor_neighbor_index(self.to_glib_none().0, which_monitor, dir.into_glib())
        }
    }

    /// Gets the monitor scaling value for the given `monitor`.
    /// ## `monitor`
    /// the monitor number
    ///
    /// # Returns
    ///
    /// the monitor scaling value
    #[doc(alias = "meta_display_get_monitor_scale")]
    #[doc(alias = "get_monitor_scale")]
    pub fn monitor_scale(&self, monitor: i32) -> f32 {
        unsafe {
            ffi::meta_display_get_monitor_scale(self.to_glib_none().0, monitor)
        }
    }

    /// Gets the number of monitors that are joined together to form `self`.
    ///
    /// # Returns
    ///
    /// the number of monitors
    #[doc(alias = "meta_display_get_n_monitors")]
    #[doc(alias = "get_n_monitors")]
    pub fn n_monitors(&self) -> i32 {
        unsafe {
            ffi::meta_display_get_n_monitors(self.to_glib_none().0)
        }
    }

    #[doc(alias = "meta_display_get_pad_action_label")]
    #[doc(alias = "get_pad_action_label")]
    pub fn pad_action_label(&self, pad: &clutter::InputDevice, action_type: PadActionType, action_number: u32) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::meta_display_get_pad_action_label(self.to_glib_none().0, pad.to_glib_none().0, action_type.into_glib(), action_number))
        }
    }

    /// Gets the index of the primary monitor on this `self`.
    ///
    /// # Returns
    ///
    /// a monitor index
    #[doc(alias = "meta_display_get_primary_monitor")]
    #[doc(alias = "get_primary_monitor")]
    pub fn primary_monitor(&self) -> i32 {
        unsafe {
            ffi::meta_display_get_primary_monitor(self.to_glib_none().0)
        }
    }

    ///
    /// # Returns
    ///
    /// The selection manager of the display
    #[doc(alias = "meta_display_get_selection")]
    #[doc(alias = "get_selection")]
    pub fn selection(&self) -> Option<Selection> {
        unsafe {
            from_glib_none(ffi::meta_display_get_selection(self.to_glib_none().0))
        }
    }

    /// Retrieve the size of the display.
    ///
    /// # Returns
    ///
    ///
    /// ## `width`
    /// The width of the screen
    ///
    /// ## `height`
    /// The height of the screen
    #[doc(alias = "meta_display_get_size")]
    #[doc(alias = "get_size")]
    pub fn size(&self) -> (i32, i32) {
        unsafe {
            let mut width = mem::MaybeUninit::uninit();
            let mut height = mem::MaybeUninit::uninit();
            ffi::meta_display_get_size(self.to_glib_none().0, width.as_mut_ptr(), height.as_mut_ptr());
            let width = width.assume_init();
            let height = height.assume_init();
            (width, height)
        }
    }

    //#[doc(alias = "meta_display_get_sound_player")]
    //#[doc(alias = "get_sound_player")]
    //pub fn sound_player(&self) -> /*Ignored*/Option<SoundPlayer> {
    //    unsafe { TODO: call ffi:meta_display_get_sound_player() }
    //}

    //#[doc(alias = "meta_display_get_startup_notification")]
    //#[doc(alias = "get_startup_notification")]
    //pub fn startup_notification(&self) -> /*Ignored*/Option<StartupNotification> {
    //    unsafe { TODO: call ffi:meta_display_get_startup_notification() }
    //}

    /// Determine the active window that should be displayed for Alt-TAB.
    /// ## `type_`
    /// type of tab list
    /// ## `workspace`
    /// origin workspace
    ///
    /// # Returns
    ///
    /// Current window
    #[doc(alias = "meta_display_get_tab_current")]
    #[doc(alias = "get_tab_current")]
    pub fn tab_current(&self, type_: TabList, workspace: &Workspace) -> Option<Window> {
        unsafe {
            from_glib_none(ffi::meta_display_get_tab_current(self.to_glib_none().0, type_.into_glib(), workspace.to_glib_none().0))
        }
    }

    /// Determine the list of windows that should be displayed for Alt-TAB
    /// functionality. The windows are returned in most recently used order.
    /// If `workspace` is not [`None`], the list only contains windows that are on
    /// `workspace` or have the demands-attention hint set; otherwise it contains
    /// all windows.
    /// ## `type_`
    /// type of tab list
    /// ## `workspace`
    /// origin workspace
    ///
    /// # Returns
    ///
    /// List of windows
    #[doc(alias = "meta_display_get_tab_list")]
    #[doc(alias = "get_tab_list")]
    pub fn tab_list(&self, type_: TabList, workspace: Option<&Workspace>) -> Vec<Window> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::meta_display_get_tab_list(self.to_glib_none().0, type_.into_glib(), workspace.to_glib_none().0))
        }
    }

    /// Determine the next window that should be displayed for Alt-TAB
    /// functionality.
    /// ## `type_`
    /// type of tab list
    /// ## `workspace`
    /// origin workspace
    /// ## `window`
    /// starting window
    /// ## `backward`
    /// If [`true`], look for the previous window.
    ///
    /// # Returns
    ///
    /// Next window
    #[doc(alias = "meta_display_get_tab_next")]
    #[doc(alias = "get_tab_next")]
    pub fn tab_next(&self, type_: TabList, workspace: &Workspace, window: Option<&Window>, backward: bool) -> Option<Window> {
        unsafe {
            from_glib_none(ffi::meta_display_get_tab_next(self.to_glib_none().0, type_.into_glib(), workspace.to_glib_none().0, window.to_glib_none().0, backward.into_glib()))
        }
    }

    ///
    /// # Returns
    ///
    /// The workspace manager of the display
    #[doc(alias = "meta_display_get_workspace_manager")]
    #[doc(alias = "get_workspace_manager")]
    pub fn workspace_manager(&self) -> Option<WorkspaceManager> {
        unsafe {
            from_glib_none(ffi::meta_display_get_workspace_manager(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "meta_display_get_x11_display")]
    //#[doc(alias = "get_x11_display")]
    //pub fn x11_display(&self) -> /*Ignored*/Option<X11Display> {
    //    unsafe { TODO: call ffi:meta_display_get_x11_display() }
    //}

    #[doc(alias = "meta_display_grab_accelerator")]
    pub fn grab_accelerator(&self, accelerator: &str, flags: KeyBindingFlags) -> u32 {
        unsafe {
            ffi::meta_display_grab_accelerator(self.to_glib_none().0, accelerator.to_glib_none().0, flags.into_glib())
        }
    }

    //#[doc(alias = "meta_display_is_pointer_emulating_sequence")]
    //pub fn is_pointer_emulating_sequence(&self, sequence: /*Ignored*/Option<&mut clutter::EventSequence>) -> bool {
    //    unsafe { TODO: call ffi:meta_display_is_pointer_emulating_sequence() }
    //}

    /// Remove keybinding `name`; the function will fail if `name` is not a known
    /// keybinding or has not been added with [`add_keybinding()`][Self::add_keybinding()].
    /// ## `name`
    /// name of the keybinding to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the binding has been removed successfully,
    ///  otherwise [`false`]
    #[doc(alias = "meta_display_remove_keybinding")]
    pub fn remove_keybinding(&self, name: &str) -> bool {
        unsafe {
            from_glib(ffi::meta_display_remove_keybinding(self.to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_display_request_pad_osd")]
    pub fn request_pad_osd(&self, pad: &clutter::InputDevice, edition_mode: bool) {
        unsafe {
            ffi::meta_display_request_pad_osd(self.to_glib_none().0, pad.to_glib_none().0, edition_mode.into_glib());
        }
    }

    #[doc(alias = "meta_display_set_cursor")]
    pub fn set_cursor(&self, cursor: Cursor) {
        unsafe {
            ffi::meta_display_set_cursor(self.to_glib_none().0, cursor.into_glib());
        }
    }

    #[doc(alias = "meta_display_set_input_focus")]
    pub fn set_input_focus(&self, window: &Window, focus_frame: bool, timestamp: u32) {
        unsafe {
            ffi::meta_display_set_input_focus(self.to_glib_none().0, window.to_glib_none().0, focus_frame.into_glib(), timestamp);
        }
    }

    ///
    /// # Returns
    ///
    /// whether pointer barriers can be supported.
    ///
    /// When running as an X compositor the X server needs XInput 2
    /// version 2.3. When running as a display server it is supported
    /// when running on the native backend.
    ///
    /// Clients should use this method to determine whether their
    /// interfaces should depend on new barrier features.
    #[doc(alias = "meta_display_supports_extended_barriers")]
    pub fn supports_extended_barriers(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_display_supports_extended_barriers(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_display_unfreeze_keyboard")]
    pub fn unfreeze_keyboard(&self, timestamp: u32) {
        unsafe {
            ffi::meta_display_unfreeze_keyboard(self.to_glib_none().0, timestamp);
        }
    }

    #[doc(alias = "meta_display_ungrab_accelerator")]
    pub fn ungrab_accelerator(&self, action_id: u32) -> bool {
        unsafe {
            from_glib(ffi::meta_display_ungrab_accelerator(self.to_glib_none().0, action_id))
        }
    }

    #[doc(alias = "meta_display_ungrab_keyboard")]
    pub fn ungrab_keyboard(&self, timestamp: u32) {
        unsafe {
            ffi::meta_display_ungrab_keyboard(self.to_glib_none().0, timestamp);
        }
    }

    #[doc(alias = "meta_display_unset_input_focus")]
    pub fn unset_input_focus(&self, timestamp: u32) {
        unsafe {
            ffi::meta_display_unset_input_focus(self.to_glib_none().0, timestamp);
        }
    }

    /// Xserver time can wraparound, thus comparing two timestamps needs to take
    /// this into account. If no wraparound has occurred, this is equivalent to
    ///  time1 < time2
    /// Otherwise, we need to account for the fact that wraparound can occur
    /// and the fact that a timestamp of 0 must be special-cased since it
    /// means "older than anything else".
    ///
    /// Note that this is NOT an equivalent for time1 <= time2; if that's what
    /// you need then you'll need to swap the order of the arguments and negate
    /// the result.
    /// ## `time1`
    /// An event timestamp
    /// ## `time2`
    /// An event timestamp
    #[doc(alias = "meta_display_xserver_time_is_before")]
    pub fn xserver_time_is_before(&self, time1: u32, time2: u32) -> bool {
        unsafe {
            from_glib(ffi::meta_display_xserver_time_is_before(self.to_glib_none().0, time1, time2))
        }
    }

    #[doc(alias = "accelerator-activated")]
    pub fn connect_accelerator_activated<F: Fn(&Self, u32, &clutter::InputDevice, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn accelerator_activated_trampoline<F: Fn(&Display, u32, &clutter::InputDevice, u32) + 'static>(this: *mut ffi::MetaDisplay, object: libc::c_uint, p0: *mut clutter::ffi::ClutterInputDevice, p1: libc::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), object, &from_glib_borrow(p0), p1)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"accelerator-activated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(accelerator_activated_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "closing")]
    pub fn connect_closing<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn closing_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"closing\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(closing_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "cursor-updated")]
    pub fn connect_cursor_updated<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn cursor_updated_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"cursor-updated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(cursor_updated_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "gl-video-memory-purged")]
    pub fn connect_gl_video_memory_purged<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn gl_video_memory_purged_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"gl-video-memory-purged\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(gl_video_memory_purged_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "grab-op-begin")]
    pub fn connect_grab_op_begin<F: Fn(&Self, &Window, GrabOp) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn grab_op_begin_trampoline<F: Fn(&Display, &Window, GrabOp) + 'static>(this: *mut ffi::MetaDisplay, object: *mut ffi::MetaWindow, p0: ffi::MetaGrabOp, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(object), from_glib(p0))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"grab-op-begin\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(grab_op_begin_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "grab-op-end")]
    pub fn connect_grab_op_end<F: Fn(&Self, &Window, GrabOp) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn grab_op_end_trampoline<F: Fn(&Display, &Window, GrabOp) + 'static>(this: *mut ffi::MetaDisplay, object: *mut ffi::MetaWindow, p0: ffi::MetaGrabOp, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(object), from_glib(p0))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"grab-op-end\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(grab_op_end_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "in-fullscreen-changed")]
    pub fn connect_in_fullscreen_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn in_fullscreen_changed_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"in-fullscreen-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(in_fullscreen_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "init-xserver")]
    pub fn connect_init_xserver<F: Fn(&Self, &gio::Task) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn init_xserver_trampoline<F: Fn(&Display, &gio::Task) -> bool + 'static>(this: *mut ffi::MetaDisplay, object: *mut gio::ffi::GTask, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(object)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"init-xserver\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(init_xserver_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// The ::modifiers-accelerator-activated signal will be emitted when
    /// a special modifiers-only keybinding is activated.
    ///
    /// # Returns
    ///
    /// [`true`] means that the keyboard device should remain
    ///  frozen and [`false`] for the default behavior of unfreezing the
    ///  keyboard.
    #[doc(alias = "modifiers-accelerator-activated")]
    pub fn connect_modifiers_accelerator_activated<F: Fn(&Self) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn modifiers_accelerator_activated_trampoline<F: Fn(&Display) -> bool + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"modifiers-accelerator-activated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(modifiers_accelerator_activated_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "overlay-key")]
    pub fn connect_overlay_key<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn overlay_key_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"overlay-key\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(overlay_key_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "pad-mode-switch")]
    pub fn connect_pad_mode_switch<F: Fn(&Self, &clutter::InputDevice, u32, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn pad_mode_switch_trampoline<F: Fn(&Display, &clutter::InputDevice, u32, u32) + 'static>(this: *mut ffi::MetaDisplay, object: *mut clutter::ffi::ClutterInputDevice, p0: libc::c_uint, p1: libc::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(object), p0, p1)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"pad-mode-switch\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(pad_mode_switch_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "restacked")]
    pub fn connect_restacked<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn restacked_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"restacked\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(restacked_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// The ::restart signal is emitted to indicate that compositor
    /// should reexec the process. This is
    /// emitted when [`restart()`][crate::restart()] is called, either by Mutter
    /// internally or by the embedding compositor. See also
    /// ::show-restart-message.
    ///
    /// # Returns
    ///
    /// [`false`] to indicate that the compositor could not
    ///  be restarted. When the compositor is restarted, the signal
    ///  should not return.
    #[doc(alias = "restart")]
    pub fn connect_restart<F: Fn(&Self) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn restart_trampoline<F: Fn(&Display) -> bool + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"restart\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(restart_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "show-osd")]
    pub fn connect_show_osd<F: Fn(&Self, i32, &str, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_osd_trampoline<F: Fn(&Display, i32, &str, &str) + 'static>(this: *mut ffi::MetaDisplay, object: libc::c_int, p0: *mut libc::c_char, p1: *mut libc::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), object, &glib::GString::from_glib_borrow(p0), &glib::GString::from_glib_borrow(p1))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-osd\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_osd_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// Requests the pad button mapping OSD to be shown.
    /// ## `pad`
    /// the pad device
    /// ## `settings`
    /// the pad device settings
    /// ## `layout_path`
    /// path to the layout image
    /// ## `edition_mode`
    /// Whether the OSD should be shown in edition mode
    /// ## `monitor_idx`
    /// Monitor to show the OSD on
    ///
    /// # Returns
    ///
    /// The OSD actor
    #[doc(alias = "show-pad-osd")]
    pub fn connect_show_pad_osd<F: Fn(&Self, &clutter::InputDevice, &gio::Settings, &str, bool, i32) -> Option<clutter::Actor> + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_pad_osd_trampoline<F: Fn(&Display, &clutter::InputDevice, &gio::Settings, &str, bool, i32) -> Option<clutter::Actor> + 'static>(this: *mut ffi::MetaDisplay, pad: *mut clutter::ffi::ClutterInputDevice, settings: *mut gio::ffi::GSettings, layout_path: *mut libc::c_char, edition_mode: glib::ffi::gboolean, monitor_idx: libc::c_int, f: glib::ffi::gpointer) -> *mut clutter::ffi::ClutterActor {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(pad), &from_glib_borrow(settings), &glib::GString::from_glib_borrow(layout_path), from_glib(edition_mode), monitor_idx)/*Not checked*/.to_glib_none().0
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-pad-osd\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_pad_osd_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "show-resize-popup")]
    pub fn connect_show_resize_popup<F: Fn(&Self, bool, &Rectangle, i32, i32) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_resize_popup_trampoline<F: Fn(&Display, bool, &Rectangle, i32, i32) -> bool + 'static>(this: *mut ffi::MetaDisplay, object: glib::ffi::gboolean, p0: *mut ffi::MetaRectangle, p1: libc::c_int, p2: libc::c_int, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), from_glib(object), &from_glib_borrow(p0), p1, p2).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-resize-popup\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_resize_popup_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// The ::show-restart-message signal will be emitted to indicate
    /// that the compositor should show a message during restart. This is
    /// emitted when [`restart()`][crate::restart()] is called, either by Mutter
    /// internally or by the embedding compositor. The message should be
    /// immediately added to the Clutter stage in its final form -
    /// ::restart will be emitted to exit the application and leave the
    /// stage contents frozen as soon as the the stage is painted again.
    ///
    /// On case of failure to restart, this signal will be emitted again
    /// with [`None`] for `message`.
    /// ## `message`
    /// The message to display, or [`None`]
    ///  to clear a previous restart message.
    ///
    /// # Returns
    ///
    /// [`true`] means the message was added to the stage; [`false`]
    ///  indicates that the compositor did not show the message.
    #[doc(alias = "show-restart-message")]
    pub fn connect_show_restart_message<F: Fn(&Self, Option<&str>) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_restart_message_trampoline<F: Fn(&Display, Option<&str>) -> bool + 'static>(this: *mut ffi::MetaDisplay, message: *mut libc::c_char, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), Option::<glib::GString>::from_glib_borrow(message).as_ref().as_deref()).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-restart-message\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_restart_message_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "showing-desktop-changed")]
    pub fn connect_showing_desktop_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn showing_desktop_changed_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"showing-desktop-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(showing_desktop_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "window-created")]
    pub fn connect_window_created<F: Fn(&Self, &Window) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn window_created_trampoline<F: Fn(&Display, &Window) + 'static>(this: *mut ffi::MetaDisplay, object: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"window-created\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(window_created_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "window-demands-attention")]
    pub fn connect_window_demands_attention<F: Fn(&Self, &Window) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn window_demands_attention_trampoline<F: Fn(&Display, &Window) + 'static>(this: *mut ffi::MetaDisplay, object: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"window-demands-attention\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(window_demands_attention_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "window-entered-monitor")]
    pub fn connect_window_entered_monitor<F: Fn(&Self, i32, &Window) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn window_entered_monitor_trampoline<F: Fn(&Display, i32, &Window) + 'static>(this: *mut ffi::MetaDisplay, object: libc::c_int, p0: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), object, &from_glib_borrow(p0))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"window-entered-monitor\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(window_entered_monitor_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "window-left-monitor")]
    pub fn connect_window_left_monitor<F: Fn(&Self, i32, &Window) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn window_left_monitor_trampoline<F: Fn(&Display, i32, &Window) + 'static>(this: *mut ffi::MetaDisplay, object: libc::c_int, p0: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), object, &from_glib_borrow(p0))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"window-left-monitor\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(window_left_monitor_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "window-marked-urgent")]
    pub fn connect_window_marked_urgent<F: Fn(&Self, &Window) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn window_marked_urgent_trampoline<F: Fn(&Display, &Window) + 'static>(this: *mut ffi::MetaDisplay, object: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"window-marked-urgent\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(window_marked_urgent_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "workareas-changed")]
    pub fn connect_workareas_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn workareas_changed_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"workareas-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(workareas_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "x11-display-closing")]
    pub fn connect_x11_display_closing<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn x11_display_closing_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"x11-display-closing\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(x11_display_closing_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "x11-display-opened")]
    pub fn connect_x11_display_opened<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn x11_display_opened_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"x11-display-opened\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(x11_display_opened_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "x11-display-setup")]
    pub fn connect_x11_display_setup<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn x11_display_setup_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"x11-display-setup\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(x11_display_setup_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "compositor-modifiers")]
    pub fn connect_compositor_modifiers_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_compositor_modifiers_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::compositor-modifiers\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_compositor_modifiers_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "focus-window")]
    pub fn connect_focus_window_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_focus_window_trampoline<F: Fn(&Display) + 'static>(this: *mut ffi::MetaDisplay, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::focus-window\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_focus_window_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Display {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Display")
    }
}
