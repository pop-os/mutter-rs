// Generated by gir (https://github.com/gtk-rs/gir @ 5bbf6cb)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

use crate::Display;
use crate::FrameType;
use crate::GrabOp;
use crate::MaximizeFlags;
use crate::Rectangle;
use crate::StackLayer;
use crate::WindowClientType;
use crate::WindowType;
use crate::Workspace;
use glib::object::IsA;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "MetaWindow")]
    pub struct Window(Object<ffi::MetaWindow, ffi::MetaWindowClass>);

    match fn {
        type_ => || ffi::meta_window_get_type(),
    }
}

impl Window {
    #[doc(alias = "meta_window_activate")]
    pub fn activate(&self, current_time: u32) {
        unsafe {
            ffi::meta_window_activate(self.to_glib_none().0, current_time);
        }
    }

    #[doc(alias = "meta_window_activate_with_workspace")]
    pub fn activate_with_workspace(&self, current_time: u32, workspace: &Workspace) {
        unsafe {
            ffi::meta_window_activate_with_workspace(self.to_glib_none().0, current_time, workspace.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_allows_move")]
    pub fn allows_move(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_allows_move(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_allows_resize")]
    pub fn allows_resize(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_allows_resize(self.to_glib_none().0))
        }
    }

    /// Determines if the window should be drawn with a focused appearance. This is
    /// true for focused windows but also true for windows with a focused modal
    /// dialog attached.
    ///
    /// # Returns
    ///
    /// [`true`] if the window should be drawn with a focused frame
    #[doc(alias = "meta_window_appears_focused")]
    pub fn appears_focused(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_appears_focused(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_begin_grab_op")]
    pub fn begin_grab_op(&self, op: GrabOp, frame_action: bool, timestamp: u32) {
        unsafe {
            ffi::meta_window_begin_grab_op(self.to_glib_none().0, op.into_glib(), frame_action.into_glib(), timestamp);
        }
    }

    #[doc(alias = "meta_window_can_close")]
    pub fn can_close(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_can_close(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_can_maximize")]
    pub fn can_maximize(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_can_maximize(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_can_minimize")]
    pub fn can_minimize(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_can_minimize(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_can_shade")]
    pub fn can_shade(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_can_shade(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_change_workspace")]
    pub fn change_workspace(&self, workspace: &Workspace) {
        unsafe {
            ffi::meta_window_change_workspace(self.to_glib_none().0, workspace.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_change_workspace_by_index")]
    pub fn change_workspace_by_index(&self, space_index: i32, append: bool) {
        unsafe {
            ffi::meta_window_change_workspace_by_index(self.to_glib_none().0, space_index, append.into_glib());
        }
    }

    #[doc(alias = "meta_window_check_alive")]
    pub fn check_alive(&self, timestamp: u32) {
        unsafe {
            ffi::meta_window_check_alive(self.to_glib_none().0, timestamp);
        }
    }

    /// Converts a desired bounds of the client window into the corresponding bounds
    /// of the window frame (excluding invisible borders and client side shadows.)
    /// ## `client_rect`
    /// client rectangle in root coordinates
    ///
    /// # Returns
    ///
    ///
    /// ## `frame_rect`
    /// location to store the computed corresponding frame bounds.
    #[doc(alias = "meta_window_client_rect_to_frame_rect")]
    pub fn client_rect_to_frame_rect(&self, client_rect: &mut Rectangle) -> Rectangle {
        unsafe {
            let mut frame_rect = Rectangle::uninitialized();
            ffi::meta_window_client_rect_to_frame_rect(self.to_glib_none().0, client_rect.to_glib_none_mut().0, frame_rect.to_glib_none_mut().0);
            frame_rect
        }
    }

    #[doc(alias = "meta_window_compute_group")]
    pub fn compute_group(&self) {
        unsafe {
            ffi::meta_window_compute_group(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_delete")]
    pub fn delete(&self, timestamp: u32) {
        unsafe {
            ffi::meta_window_delete(self.to_glib_none().0, timestamp);
        }
    }

    /// Follow the chain of parents of `self`, skipping transient windows,
    /// and return the "root" window which has no non-transient parent.
    ///
    /// # Returns
    ///
    /// The root ancestor window
    #[doc(alias = "meta_window_find_root_ancestor")]
    pub fn find_root_ancestor(&self) -> Option<Window> {
        unsafe {
            from_glib_none(ffi::meta_window_find_root_ancestor(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_focus")]
    pub fn focus(&self, timestamp: u32) {
        unsafe {
            ffi::meta_window_focus(self.to_glib_none().0, timestamp);
        }
    }

    /// If `self` is transient, call `func` with the window for which it's transient,
    /// repeatedly until either we find a non-transient window, or `func` returns [`false`].
    /// ## `func`
    /// Called for each window which is a transient parent of `self`
    #[doc(alias = "meta_window_foreach_ancestor")]
    pub fn foreach_ancestor<P: FnMut(&Window) -> bool>(&self, func: P) {
        let func_data: P = func;
        unsafe extern "C" fn func_func<P: FnMut(&Window) -> bool>(window: *mut ffi::MetaWindow, user_data: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let window = from_glib_borrow(window);
            let callback: *mut P = user_data as *const _ as usize as *mut P;
            let res = (*callback)(&window);
            res.into_glib()
        }
        let func = Some(func_func::<P> as _);
        let super_callback0: &P = &func_data;
        unsafe {
            ffi::meta_window_foreach_ancestor(self.to_glib_none().0, func, super_callback0 as *const _ as usize as *mut _);
        }
    }

    /// Call `func` for every window which is either transient for `self`, or is
    /// a transient of a window which is in turn transient for `self`.
    /// The order of window enumeration is not defined.
    ///
    /// Iteration will stop if `func` at any point returns [`false`].
    /// ## `func`
    /// Called for each window which is a transient of `self` (transitively)
    #[doc(alias = "meta_window_foreach_transient")]
    pub fn foreach_transient<P: FnMut(&Window) -> bool>(&self, func: P) {
        let func_data: P = func;
        unsafe extern "C" fn func_func<P: FnMut(&Window) -> bool>(window: *mut ffi::MetaWindow, user_data: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let window = from_glib_borrow(window);
            let callback: *mut P = user_data as *const _ as usize as *mut P;
            let res = (*callback)(&window);
            res.into_glib()
        }
        let func = Some(func_func::<P> as _);
        let super_callback0: &P = &func_data;
        unsafe {
            ffi::meta_window_foreach_transient(self.to_glib_none().0, func, super_callback0 as *const _ as usize as *mut _);
        }
    }

    /// Converts a desired frame bounds for a window into the bounds of the client
    /// window.
    /// ## `frame_rect`
    /// desired frame bounds for the window
    ///
    /// # Returns
    ///
    ///
    /// ## `client_rect`
    /// location to store the computed corresponding client rectangle.
    #[doc(alias = "meta_window_frame_rect_to_client_rect")]
    pub fn frame_rect_to_client_rect(&self, frame_rect: &mut Rectangle) -> Rectangle {
        unsafe {
            let mut client_rect = Rectangle::uninitialized();
            ffi::meta_window_frame_rect_to_client_rect(self.to_glib_none().0, frame_rect.to_glib_none_mut().0, client_rect.to_glib_none_mut().0);
            client_rect
        }
    }

    /// Gets the rectangle that the pixmap or buffer of `self` occupies.
    ///
    /// For X11 windows, this is the server-side geometry of the toplevel
    /// window.
    ///
    /// For Wayland windows, this is the bounding rectangle of the attached
    /// buffer.
    ///
    /// # Returns
    ///
    ///
    /// ## `rect`
    /// pointer to an allocated [`Rectangle`][crate::Rectangle]
    #[doc(alias = "meta_window_get_buffer_rect")]
    #[doc(alias = "get_buffer_rect")]
    pub fn buffer_rect(&self) -> Rectangle {
        unsafe {
            let mut rect = Rectangle::uninitialized();
            ffi::meta_window_get_buffer_rect(self.to_glib_none().0, rect.to_glib_none_mut().0);
            rect
        }
    }

    /// Returns name of the client machine from which this windows was created,
    /// if known (obtained from the WM_CLIENT_MACHINE property).
    ///
    /// # Returns
    ///
    /// the machine name, or NULL; the string is
    /// owned by the window manager and should not be freed or modified by the
    /// caller.
    #[doc(alias = "meta_window_get_client_machine")]
    #[doc(alias = "get_client_machine")]
    pub fn client_machine(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_client_machine(self.to_glib_none().0))
        }
    }

    /// Returns the [`WindowClientType`][crate::WindowClientType] of the window.
    ///
    /// # Returns
    ///
    /// The root ancestor window
    #[doc(alias = "meta_window_get_client_type")]
    #[doc(alias = "get_client_type")]
    pub fn client_type(&self) -> WindowClientType {
        unsafe {
            from_glib(ffi::meta_window_get_client_type(self.to_glib_none().0))
        }
    }

    /// Gets the compositor's wrapper object for `self`.
    ///
    /// # Returns
    ///
    /// the wrapper object.
    #[doc(alias = "meta_window_get_compositor_private")]
    #[doc(alias = "get_compositor_private")]
    pub fn compositor_private(&self) -> Option<glib::Object> {
        unsafe {
            from_glib_none(ffi::meta_window_get_compositor_private(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_get_description")]
    #[doc(alias = "get_description")]
    pub fn description(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_description(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The display for `self`
    #[doc(alias = "meta_window_get_display")]
    #[doc(alias = "get_display")]
    pub fn display(&self) -> Option<Display> {
        unsafe {
            from_glib_none(ffi::meta_window_get_display(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "meta_window_get_frame")]
    //#[doc(alias = "get_frame")]
    //pub fn frame(&self) -> /*Ignored*/Option<Frame> {
    //    unsafe { TODO: call ffi:meta_window_get_frame() }
    //}

    /// Gets a region representing the outer bounds of the window's frame.
    ///
    /// # Returns
    ///
    /// a [`cairo::Region`][crate::cairo::Region]
    ///  holding the outer bounds of the window, or [`None`] if the window
    ///  doesn't have a frame.
    #[doc(alias = "meta_window_get_frame_bounds")]
    #[doc(alias = "get_frame_bounds")]
    pub fn frame_bounds(&self) -> Option<cairo::Region> {
        unsafe {
            from_glib_none(ffi::meta_window_get_frame_bounds(self.to_glib_none().0))
        }
    }

    /// Gets the rectangle that bounds `self` that is what the user thinks of
    /// as the edge of the window. This doesn't include any extra reactive
    /// area that we or the client adds to the window, or any area that the
    /// client adds to draw a client-side shadow.
    ///
    /// # Returns
    ///
    ///
    /// ## `rect`
    /// pointer to an allocated [`Rectangle`][crate::Rectangle]
    #[doc(alias = "meta_window_get_frame_rect")]
    #[doc(alias = "get_frame_rect")]
    pub fn frame_rect(&self) -> Rectangle {
        unsafe {
            let mut rect = Rectangle::uninitialized();
            ffi::meta_window_get_frame_rect(self.to_glib_none().0, rect.to_glib_none_mut().0);
            rect
        }
    }

    /// Gets the type of window decorations that should be used for this window.
    ///
    /// # Returns
    ///
    /// the frame type
    #[doc(alias = "meta_window_get_frame_type")]
    #[doc(alias = "get_frame_type")]
    pub fn frame_type(&self) -> FrameType {
        unsafe {
            from_glib(ffi::meta_window_get_frame_type(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "meta_window_get_group")]
    //#[doc(alias = "get_group")]
    //pub fn group(&self) -> /*Ignored*/Option<Group> {
    //    unsafe { TODO: call ffi:meta_window_get_group() }
    //}

    ///
    /// # Returns
    ///
    /// the object path
    #[doc(alias = "meta_window_get_gtk_app_menu_object_path")]
    #[doc(alias = "get_gtk_app_menu_object_path")]
    pub fn gtk_app_menu_object_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_gtk_app_menu_object_path(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the application ID
    #[doc(alias = "meta_window_get_gtk_application_id")]
    #[doc(alias = "get_gtk_application_id")]
    pub fn gtk_application_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_gtk_application_id(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the object path
    #[doc(alias = "meta_window_get_gtk_application_object_path")]
    #[doc(alias = "get_gtk_application_object_path")]
    pub fn gtk_application_object_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_gtk_application_object_path(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the object path
    #[doc(alias = "meta_window_get_gtk_menubar_object_path")]
    #[doc(alias = "get_gtk_menubar_object_path")]
    pub fn gtk_menubar_object_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_gtk_menubar_object_path(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the theme variant or [`None`]
    #[doc(alias = "meta_window_get_gtk_theme_variant")]
    #[doc(alias = "get_gtk_theme_variant")]
    pub fn gtk_theme_variant(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_gtk_theme_variant(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the unique name
    #[doc(alias = "meta_window_get_gtk_unique_bus_name")]
    #[doc(alias = "get_gtk_unique_bus_name")]
    pub fn gtk_unique_bus_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_gtk_unique_bus_name(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the object path
    #[doc(alias = "meta_window_get_gtk_window_object_path")]
    #[doc(alias = "get_gtk_window_object_path")]
    pub fn gtk_window_object_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_gtk_window_object_path(self.to_glib_none().0))
        }
    }

    /// Gets the location of the icon corresponding to the window. The location
    /// will be provided set by the task bar or other user interface element
    /// displaying the icon, and is relative to the root window.
    ///
    /// # Returns
    ///
    /// [`true`] if the icon geometry was successfully retrieved.
    ///
    /// ## `rect`
    /// rectangle into which to store the returned geometry.
    #[doc(alias = "meta_window_get_icon_geometry")]
    #[doc(alias = "get_icon_geometry")]
    pub fn icon_geometry(&self) -> Option<Rectangle> {
        unsafe {
            let mut rect = Rectangle::uninitialized();
            let ret = from_glib(ffi::meta_window_get_icon_geometry(self.to_glib_none().0, rect.to_glib_none_mut().0));
            if ret { Some(rect) } else { None }
        }
    }

    /// Returns the window id associated with window.
    ///
    /// # Returns
    ///
    /// The window id
    #[doc(alias = "meta_window_get_id")]
    #[doc(alias = "get_id")]
    pub fn id(&self) -> u64 {
        unsafe {
            ffi::meta_window_get_id(self.to_glib_none().0)
        }
    }

    #[doc(alias = "meta_window_get_layer")]
    #[doc(alias = "get_layer")]
    pub fn layer(&self) -> StackLayer {
        unsafe {
            from_glib(ffi::meta_window_get_layer(self.to_glib_none().0))
        }
    }

    /// Gets the current maximization state of the window, as combination
    /// of the [`MaximizeFlags::HORIZONTAL`][crate::MaximizeFlags::HORIZONTAL] and [`MaximizeFlags::VERTICAL`][crate::MaximizeFlags::VERTICAL] flags;
    ///
    /// # Returns
    ///
    /// current maximization state
    #[doc(alias = "meta_window_get_maximized")]
    #[doc(alias = "get_maximized")]
    pub fn maximized(&self) -> MaximizeFlags {
        unsafe {
            from_glib(ffi::meta_window_get_maximized(self.to_glib_none().0))
        }
    }

    /// Gets index of the monitor that this window is on.
    ///
    /// # Returns
    ///
    /// The index of the monitor in the screens monitor list, or -1
    /// if the window has been recently unmanaged and does not have a monitor.
    #[doc(alias = "meta_window_get_monitor")]
    #[doc(alias = "get_monitor")]
    pub fn monitor(&self) -> i32 {
        unsafe {
            ffi::meta_window_get_monitor(self.to_glib_none().0)
        }
    }

    /// Gets the current value of the _MUTTER_HINTS property.
    ///
    /// The purpose of the hints is to allow fine-tuning of the Window Manager and
    /// Compositor behaviour on per-window basis, and is intended primarily for
    /// hints that are plugin-specific.
    ///
    /// The property is a list of colon-separated key=value pairs. The key names for
    /// any plugin-specific hints must be suitably namespaced to allow for shared
    /// use; 'mutter-' key prefix is reserved for internal use, and must not be used
    /// by plugins.
    ///
    /// # Returns
    ///
    /// the _MUTTER_HINTS string, or [`None`] if no hints
    /// are set.
    #[doc(alias = "meta_window_get_mutter_hints")]
    #[doc(alias = "get_mutter_hints")]
    pub fn mutter_hints(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_mutter_hints(self.to_glib_none().0))
        }
    }

    /// Returns the pid of the process that created this window, if available
    /// to the windowing system.
    ///
    /// Note that the value returned by this is vulnerable to spoofing attacks
    /// by the client.
    ///
    /// # Returns
    ///
    /// the pid, or 0 if not known.
    #[doc(alias = "meta_window_get_pid")]
    #[doc(alias = "get_pid")]
    pub fn pid(&self) -> i32 {
        unsafe {
            ffi::meta_window_get_pid(self.to_glib_none().0)
        }
    }

    #[doc(alias = "meta_window_get_role")]
    #[doc(alias = "get_role")]
    pub fn role(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_role(self.to_glib_none().0))
        }
    }

    /// Gets an unique id for a sandboxed app (currently flatpaks and snaps are
    /// supported).
    ///
    /// # Returns
    ///
    /// the sandboxed application ID or [`None`]
    #[doc(alias = "meta_window_get_sandboxed_app_id")]
    #[doc(alias = "get_sandboxed_app_id")]
    pub fn sandboxed_app_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_sandboxed_app_id(self.to_glib_none().0))
        }
    }

    /// The stable sequence number is a monotonicially increasing
    /// unique integer assigned to each [`Window`][crate::Window] upon creation.
    ///
    /// This number can be useful for sorting windows in a stable
    /// fashion.
    ///
    /// # Returns
    ///
    /// Internal sequence number for this window
    #[doc(alias = "meta_window_get_stable_sequence")]
    #[doc(alias = "get_stable_sequence")]
    pub fn stable_sequence(&self) -> u32 {
        unsafe {
            ffi::meta_window_get_stable_sequence(self.to_glib_none().0)
        }
    }

    #[doc(alias = "meta_window_get_startup_id")]
    #[doc(alias = "get_startup_id")]
    pub fn startup_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_startup_id(self.to_glib_none().0))
        }
    }

    /// Returns the matching tiled window on the same monitor as `self`. This is
    /// the topmost tiled window in a complementary tile mode that is:
    ///
    ///  - on the same monitor;
    ///  - on the same workspace;
    ///  - spanning the remaining monitor width;
    ///  - there is no 3rd window stacked between both tiled windows that's
    ///  partially visible in the common edge.
    ///
    /// # Returns
    ///
    /// the matching tiled window or
    /// [`None`] if it doesn't exist.
    #[doc(alias = "meta_window_get_tile_match")]
    #[doc(alias = "get_tile_match")]
    pub fn tile_match(&self) -> Option<Window> {
        unsafe {
            from_glib_none(ffi::meta_window_get_tile_match(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the current title of the window.
    #[doc(alias = "meta_window_get_title")]
    #[doc(alias = "get_title")]
    pub fn title(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_title(self.to_glib_none().0))
        }
    }

    /// Returns the [`Window`][crate::Window] for the window that is pointed to by the
    /// WM_TRANSIENT_FOR hint on this window (see XGetTransientForHint()
    /// or XSetTransientForHint()). Metacity keeps transient windows above their
    /// parents. A typical usage of this hint is for a dialog that wants to stay
    /// above its associated window.
    ///
    /// # Returns
    ///
    /// the window this window is transient for, or
    /// [`None`] if the WM_TRANSIENT_FOR hint is unset or does not point to a toplevel
    /// window that Metacity knows about.
    #[doc(alias = "meta_window_get_transient_for")]
    #[doc(alias = "get_transient_for")]
    pub fn transient_for(&self) -> Option<Window> {
        unsafe {
            from_glib_none(ffi::meta_window_get_transient_for(self.to_glib_none().0))
        }
    }

    /// The user time represents a timestamp for the last time the user
    /// interacted with this window. Note this property is only available
    /// for non-override-redirect windows.
    ///
    /// The property is set by Mutter initially upon window creation,
    /// and updated thereafter on input events (key and button presses) seen by Mutter,
    /// client updates to the _NET_WM_USER_TIME property (if later than the current time)
    /// and when focusing the window.
    ///
    /// # Returns
    ///
    /// The last time the user interacted with this window.
    #[doc(alias = "meta_window_get_user_time")]
    #[doc(alias = "get_user_time")]
    pub fn user_time(&self) -> u32 {
        unsafe {
            ffi::meta_window_get_user_time(self.to_glib_none().0)
        }
    }

    #[doc(alias = "meta_window_get_window_type")]
    #[doc(alias = "get_window_type")]
    pub fn window_type(&self) -> WindowType {
        unsafe {
            from_glib(ffi::meta_window_get_window_type(self.to_glib_none().0))
        }
    }

    /// Return the current value of the name part of WM_CLASS X property.
    #[doc(alias = "meta_window_get_wm_class")]
    #[doc(alias = "get_wm_class")]
    pub fn wm_class(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_wm_class(self.to_glib_none().0))
        }
    }

    /// Return the current value of the instance part of WM_CLASS X property.
    #[doc(alias = "meta_window_get_wm_class_instance")]
    #[doc(alias = "get_wm_class_instance")]
    pub fn wm_class_instance(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::meta_window_get_wm_class_instance(self.to_glib_none().0))
        }
    }

    /// Get the work area for all monitors for `self`.
    ///
    /// # Returns
    ///
    ///
    /// ## `area`
    /// a location to store the work area
    #[doc(alias = "meta_window_get_work_area_all_monitors")]
    #[doc(alias = "get_work_area_all_monitors")]
    pub fn work_area_all_monitors(&self) -> Rectangle {
        unsafe {
            let mut area = Rectangle::uninitialized();
            ffi::meta_window_get_work_area_all_monitors(self.to_glib_none().0, area.to_glib_none_mut().0);
            area
        }
    }

    /// Get the work area for the monitor `self` is currently on.
    ///
    /// # Returns
    ///
    ///
    /// ## `area`
    /// a location to store the work area
    #[doc(alias = "meta_window_get_work_area_current_monitor")]
    #[doc(alias = "get_work_area_current_monitor")]
    pub fn work_area_current_monitor(&self) -> Rectangle {
        unsafe {
            let mut area = Rectangle::uninitialized();
            ffi::meta_window_get_work_area_current_monitor(self.to_glib_none().0, area.to_glib_none_mut().0);
            area
        }
    }

    /// Get the work area for `self`, given the monitor index
    /// `which_monitor`.
    /// ## `which_monitor`
    /// a moniotr to get the work area for
    ///
    /// # Returns
    ///
    ///
    /// ## `area`
    /// a location to store the work area
    #[doc(alias = "meta_window_get_work_area_for_monitor")]
    #[doc(alias = "get_work_area_for_monitor")]
    pub fn work_area_for_monitor(&self, which_monitor: i32) -> Rectangle {
        unsafe {
            let mut area = Rectangle::uninitialized();
            ffi::meta_window_get_work_area_for_monitor(self.to_glib_none().0, which_monitor, area.to_glib_none_mut().0);
            area
        }
    }

    /// Gets the [`Workspace`][crate::Workspace] that the window is currently displayed on.
    /// If the window is on all workspaces, returns the currently active
    /// workspace.
    ///
    /// # Returns
    ///
    /// the [`Workspace`][crate::Workspace] for the window
    #[doc(alias = "meta_window_get_workspace")]
    #[doc(alias = "get_workspace")]
    pub fn workspace(&self) -> Option<Workspace> {
        unsafe {
            from_glib_none(ffi::meta_window_get_workspace(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "meta_window_get_xwindow")]
    //#[doc(alias = "get_xwindow")]
    //pub fn xwindow(&self) -> /*Ignored*/xlib::Window {
    //    unsafe { TODO: call ffi:meta_window_get_xwindow() }
    //}

    #[doc(alias = "meta_window_group_leader_changed")]
    pub fn group_leader_changed(&self) {
        unsafe {
            ffi::meta_window_group_leader_changed(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_has_focus")]
    pub fn has_focus(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_has_focus(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_is_above")]
    pub fn is_above(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_above(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_is_always_on_all_workspaces")]
    pub fn is_always_on_all_workspaces(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_always_on_all_workspaces(self.to_glib_none().0))
        }
    }

    /// The function determines whether `self` is an ancestor of `transient`; it does
    /// so by traversing the `transient`'s ancestors until it either locates `self`
    /// or reaches an ancestor that is not transient.
    /// ## `transient`
    /// a [`Window`][crate::Window]
    ///
    /// # Returns
    ///
    /// [`true`] if window is an ancestor of transient.
    #[doc(alias = "meta_window_is_ancestor_of_transient")]
    pub fn is_ancestor_of_transient(&self, transient: &Window) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_ancestor_of_transient(self.to_glib_none().0, transient.to_glib_none().0))
        }
    }

    /// Tests if `self` is should be attached to its parent window.
    /// (If the "attach_modal_dialogs" option is not enabled, this will
    /// always return [`false`].)
    ///
    /// # Returns
    ///
    /// whether `self` should be attached to its parent
    #[doc(alias = "meta_window_is_attached_dialog")]
    pub fn is_attached_dialog(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_attached_dialog(self.to_glib_none().0))
        }
    }

    /// Check if if the window has decorations drawn by the client.
    /// (window->decorated refers only to whether we should add decorations)
    #[doc(alias = "meta_window_is_client_decorated")]
    pub fn is_client_decorated(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_client_decorated(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if the window is currently fullscreen
    #[doc(alias = "meta_window_is_fullscreen")]
    pub fn is_fullscreen(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_fullscreen(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_is_hidden")]
    pub fn is_hidden(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_hidden(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if the window is occupies an entire monitor or
    ///  the whole screen.
    #[doc(alias = "meta_window_is_monitor_sized")]
    pub fn is_monitor_sized(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_monitor_sized(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_is_on_all_workspaces")]
    pub fn is_on_all_workspaces(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_on_all_workspaces(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if the window is on the primary monitor
    #[doc(alias = "meta_window_is_on_primary_monitor")]
    pub fn is_on_primary_monitor(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_on_primary_monitor(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if this window isn't managed by mutter; it will
    /// control its own positioning and mutter won't draw decorations
    /// among other things. In X terminology this is "override redirect".
    #[doc(alias = "meta_window_is_override_redirect")]
    pub fn is_override_redirect(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_override_redirect(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if this window originates from a host
    /// different from the one running mutter.
    #[doc(alias = "meta_window_is_remote")]
    pub fn is_remote(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_remote(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if the window is occupies the
    ///  the whole screen (all monitors).
    #[doc(alias = "meta_window_is_screen_sized")]
    pub fn is_screen_sized(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_screen_sized(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_is_shaded")]
    pub fn is_shaded(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_shaded(self.to_glib_none().0))
        }
    }

    /// Gets whether this window should be ignored by task lists.
    ///
    /// # Returns
    ///
    /// [`true`] if the skip bar hint is set.
    #[doc(alias = "meta_window_is_skip_taskbar")]
    pub fn is_skip_taskbar(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_is_skip_taskbar(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_kill")]
    pub fn kill(&self) {
        unsafe {
            ffi::meta_window_kill(self.to_glib_none().0);
        }
    }

    /// ## `workspace`
    /// a [`Workspace`][crate::Workspace]
    ///
    /// # Returns
    ///
    /// whether `self` is displayed on `workspace`, or whether it
    /// will be displayed on all workspaces.
    #[doc(alias = "meta_window_located_on_workspace")]
    pub fn located_on_workspace(&self, workspace: &Workspace) -> bool {
        unsafe {
            from_glib(ffi::meta_window_located_on_workspace(self.to_glib_none().0, workspace.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_lower")]
    pub fn lower(&self) {
        unsafe {
            ffi::meta_window_lower(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_make_above")]
    pub fn make_above(&self) {
        unsafe {
            ffi::meta_window_make_above(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_make_fullscreen")]
    pub fn make_fullscreen(&self) {
        unsafe {
            ffi::meta_window_make_fullscreen(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_maximize")]
    pub fn maximize(&self, directions: MaximizeFlags) {
        unsafe {
            ffi::meta_window_maximize(self.to_glib_none().0, directions.into_glib());
        }
    }

    #[doc(alias = "meta_window_minimize")]
    pub fn minimize(&self) {
        unsafe {
            ffi::meta_window_minimize(self.to_glib_none().0);
        }
    }

    /// Moves the window to the desired location on window's assigned
    /// workspace, using the northwest edge of the frame as the reference,
    /// instead of the actual window's origin, but only if a frame is present.
    /// Otherwise, acts identically to `meta_window_move()`.
    /// ## `user_op`
    /// bool to indicate whether or not this is a user operation
    /// ## `root_x_nw`
    /// desired x pos
    /// ## `root_y_nw`
    /// desired y pos
    #[doc(alias = "meta_window_move_frame")]
    pub fn move_frame(&self, user_op: bool, root_x_nw: i32, root_y_nw: i32) {
        unsafe {
            ffi::meta_window_move_frame(self.to_glib_none().0, user_op.into_glib(), root_x_nw, root_y_nw);
        }
    }

    /// Resizes the window so that its outer bounds (including frame)
    /// fit within the given rect
    /// ## `user_op`
    /// bool to indicate whether or not this is a user operation
    /// ## `root_x_nw`
    /// new x
    /// ## `root_y_nw`
    /// new y
    /// ## `w`
    /// desired width
    /// ## `h`
    /// desired height
    #[doc(alias = "meta_window_move_resize_frame")]
    pub fn move_resize_frame(&self, user_op: bool, root_x_nw: i32, root_y_nw: i32, w: i32, h: i32) {
        unsafe {
            ffi::meta_window_move_resize_frame(self.to_glib_none().0, user_op.into_glib(), root_x_nw, root_y_nw, w, h);
        }
    }

    /// Moves the window to the monitor with index `monitor`, keeping
    /// the relative position of the window's top left corner.
    /// ## `monitor`
    /// desired monitor index
    #[doc(alias = "meta_window_move_to_monitor")]
    pub fn move_to_monitor(&self, monitor: i32) {
        unsafe {
            ffi::meta_window_move_to_monitor(self.to_glib_none().0, monitor);
        }
    }

    #[doc(alias = "meta_window_raise")]
    pub fn raise(&self) {
        unsafe {
            ffi::meta_window_raise(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_set_compositor_private")]
    pub fn set_compositor_private<P: IsA<glib::Object>>(&self, priv_: &P) {
        unsafe {
            ffi::meta_window_set_compositor_private(self.to_glib_none().0, priv_.as_ref().to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_set_demands_attention")]
    pub fn set_demands_attention(&self) {
        unsafe {
            ffi::meta_window_set_demands_attention(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_shade")]
    pub fn shade(&self, timestamp: u32) {
        unsafe {
            ffi::meta_window_shade(self.to_glib_none().0, timestamp);
        }
    }

    #[doc(alias = "meta_window_shove_titlebar_onscreen")]
    pub fn shove_titlebar_onscreen(&self) {
        unsafe {
            ffi::meta_window_shove_titlebar_onscreen(self.to_glib_none().0);
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if window would be visible, if its workspace was current
    #[doc(alias = "meta_window_showing_on_its_workspace")]
    pub fn showing_on_its_workspace(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_showing_on_its_workspace(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_shutdown_group")]
    pub fn shutdown_group(&self) {
        unsafe {
            ffi::meta_window_shutdown_group(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_stick")]
    pub fn stick(&self) {
        unsafe {
            ffi::meta_window_stick(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_titlebar_is_onscreen")]
    pub fn titlebar_is_onscreen(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_titlebar_is_onscreen(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_unmake_above")]
    pub fn unmake_above(&self) {
        unsafe {
            ffi::meta_window_unmake_above(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_unmake_fullscreen")]
    pub fn unmake_fullscreen(&self) {
        unsafe {
            ffi::meta_window_unmake_fullscreen(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_unmaximize")]
    pub fn unmaximize(&self, directions: MaximizeFlags) {
        unsafe {
            ffi::meta_window_unmaximize(self.to_glib_none().0, directions.into_glib());
        }
    }

    #[doc(alias = "meta_window_unminimize")]
    pub fn unminimize(&self) {
        unsafe {
            ffi::meta_window_unminimize(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_unset_demands_attention")]
    pub fn unset_demands_attention(&self) {
        unsafe {
            ffi::meta_window_unset_demands_attention(self.to_glib_none().0);
        }
    }

    #[doc(alias = "meta_window_unshade")]
    pub fn unshade(&self, timestamp: u32) {
        unsafe {
            ffi::meta_window_unshade(self.to_glib_none().0, timestamp);
        }
    }

    #[doc(alias = "meta_window_unstick")]
    pub fn unstick(&self) {
        unsafe {
            ffi::meta_window_unstick(self.to_glib_none().0);
        }
    }

    pub fn is_decorated(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"decorated\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `decorated` getter")
        }
    }

    #[doc(alias = "demands-attention")]
    pub fn is_demands_attention(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"demands-attention\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `demands-attention` getter")
        }
    }

    //pub fn icon(&self) -> /*Unimplemented*/Fundamental: Pointer {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"icon\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `icon` getter")
    //    }
    //}

    #[doc(alias = "maximized-horizontally")]
    pub fn is_maximized_horizontally(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"maximized-horizontally\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `maximized-horizontally` getter")
        }
    }

    #[doc(alias = "maximized-vertically")]
    pub fn is_maximized_vertically(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"maximized-vertically\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `maximized-vertically` getter")
        }
    }

    //#[doc(alias = "mini-icon")]
    //pub fn mini_icon(&self) -> /*Unimplemented*/Fundamental: Pointer {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"mini-icon\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `mini-icon` getter")
    //    }
    //}

    pub fn is_minimized(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"minimized\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `minimized` getter")
        }
    }

    pub fn is_resizeable(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"resizeable\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `resizeable` getter")
        }
    }

    pub fn is_urgent(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"urgent\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `urgent` getter")
        }
    }

    #[doc(alias = "focus")]
    pub fn connect_focus<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn focus_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"focus\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(focus_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// This is emitted when the window has changed monitor
    /// ## `old_monitor`
    /// the old monitor index or -1 if not known
    #[doc(alias = "monitor-changed")]
    pub fn connect_monitor_changed<F: Fn(&Self, i32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn monitor_changed_trampoline<F: Fn(&Window, i32) + 'static>(this: *mut ffi::MetaWindow, old_monitor: libc::c_int, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), old_monitor)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"monitor-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(monitor_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// This is emitted when the position of a window might
    /// have changed. Specifically, this is emitted when the
    /// position of the toplevel window has changed, or when
    /// the position of the client window has changed.
    #[doc(alias = "position-changed")]
    pub fn connect_position_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn position_changed_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"position-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(position_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "raised")]
    pub fn connect_raised<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn raised_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"raised\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(raised_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// This is emitted after a window has been shown.
    #[doc(alias = "shown")]
    pub fn connect_shown<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn shown_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"shown\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(shown_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// This is emitted when the size of a window might
    /// have changed. Specifically, this is emitted when the
    /// size of the toplevel window has changed, or when the
    /// size of the client window has changed.
    #[doc(alias = "size-changed")]
    pub fn connect_size_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn size_changed_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"size-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(size_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "unmanaged")]
    pub fn connect_unmanaged<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn unmanaged_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"unmanaged\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(unmanaged_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "unmanaging")]
    pub fn connect_unmanaging<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn unmanaging_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"unmanaging\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(unmanaging_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "workspace-changed")]
    pub fn connect_workspace_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn workspace_changed_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"workspace-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(workspace_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "above")]
    pub fn connect_above_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_above_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::above\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_above_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "appears-focused")]
    pub fn connect_appears_focused_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_appears_focused_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::appears-focused\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_appears_focused_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "decorated")]
    pub fn connect_decorated_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_decorated_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::decorated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_decorated_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "demands-attention")]
    pub fn connect_demands_attention_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_demands_attention_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::demands-attention\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_demands_attention_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "fullscreen")]
    pub fn connect_fullscreen_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_fullscreen_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::fullscreen\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_fullscreen_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "gtk-app-menu-object-path")]
    pub fn connect_gtk_app_menu_object_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_gtk_app_menu_object_path_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::gtk-app-menu-object-path\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_gtk_app_menu_object_path_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "gtk-application-id")]
    pub fn connect_gtk_application_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_gtk_application_id_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::gtk-application-id\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_gtk_application_id_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "gtk-application-object-path")]
    pub fn connect_gtk_application_object_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_gtk_application_object_path_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::gtk-application-object-path\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_gtk_application_object_path_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "gtk-menubar-object-path")]
    pub fn connect_gtk_menubar_object_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_gtk_menubar_object_path_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::gtk-menubar-object-path\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_gtk_menubar_object_path_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "gtk-unique-bus-name")]
    pub fn connect_gtk_unique_bus_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_gtk_unique_bus_name_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::gtk-unique-bus-name\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_gtk_unique_bus_name_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "gtk-window-object-path")]
    pub fn connect_gtk_window_object_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_gtk_window_object_path_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::gtk-window-object-path\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_gtk_window_object_path_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "icon")]
    pub fn connect_icon_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_icon_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::icon\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_icon_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "maximized-horizontally")]
    pub fn connect_maximized_horizontally_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_maximized_horizontally_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::maximized-horizontally\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_maximized_horizontally_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "maximized-vertically")]
    pub fn connect_maximized_vertically_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_maximized_vertically_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::maximized-vertically\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_maximized_vertically_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mini-icon")]
    pub fn connect_mini_icon_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mini_icon_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::mini-icon\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_mini_icon_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "minimized")]
    pub fn connect_minimized_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_minimized_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::minimized\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_minimized_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mutter-hints")]
    pub fn connect_mutter_hints_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mutter_hints_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::mutter-hints\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_mutter_hints_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "on-all-workspaces")]
    pub fn connect_on_all_workspaces_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_on_all_workspaces_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::on-all-workspaces\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_on_all_workspaces_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "resizeable")]
    pub fn connect_resizeable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_resizeable_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::resizeable\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_resizeable_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "skip-taskbar")]
    pub fn connect_skip_taskbar_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_skip_taskbar_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::skip-taskbar\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_skip_taskbar_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "title")]
    pub fn connect_title_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_title_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::title\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_title_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "urgent")]
    pub fn connect_urgent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_urgent_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::urgent\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_urgent_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "user-time")]
    pub fn connect_user_time_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_user_time_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::user-time\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_user_time_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "window-type")]
    pub fn connect_window_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_window_type_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::window-type\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_window_type_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "wm-class")]
    pub fn connect_wm_class_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_wm_class_trampoline<F: Fn(&Window) + 'static>(this: *mut ffi::MetaWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::wm-class\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_wm_class_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Window {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Window")
    }
}
