// Generated by gir (https://github.com/gtk-rs/gir @ b193568)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

use crate::Window;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "MetaWindowActor")]
    pub struct WindowActor(Object<ffi::MetaWindowActor, ffi::MetaWindowActorClass>) @extends clutter::Actor, @implements clutter::Animatable, clutter::Container, clutter::Scriptable;

    match fn {
        type_ => || ffi::meta_window_actor_get_type(),
    }
}

impl WindowActor {
    /// Freezes the [`WindowActor`][crate::WindowActor], which inhibits updates and geometry
    /// changes of the window. This property is refcounted, so make sure
    /// to call [`thaw()`][Self::thaw()] the exact same amount of times
    /// as this function to allow updates again.
    #[doc(alias = "meta_window_actor_freeze")]
    pub fn freeze(&self) {
        unsafe {
            ffi::meta_window_actor_freeze(self.to_glib_none().0);
        }
    }

    /// Gets the [`Window`][crate::Window] object that the the [`WindowActor`][crate::WindowActor] is displaying
    ///
    /// # Returns
    ///
    /// the displayed [`Window`][crate::Window]
    #[doc(alias = "meta_window_actor_get_meta_window")]
    #[doc(alias = "get_meta_window")]
    pub fn meta_window(&self) -> Option<Window> {
        unsafe {
            from_glib_none(ffi::meta_window_actor_get_meta_window(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "meta_window_actor_get_texture")]
    //#[doc(alias = "get_texture")]
    //pub fn texture(&self) -> /*Ignored*/Option<ShapedTexture> {
    //    unsafe { TODO: call ffi:meta_window_actor_get_texture() }
    //}

    /// Gets whether the X window that the actor was displaying has been destroyed
    ///
    /// # Returns
    ///
    /// [`true`] when the window is destroyed, otherwise [`false`]
    #[doc(alias = "meta_window_actor_is_destroyed")]
    pub fn is_destroyed(&self) -> bool {
        unsafe {
            from_glib(ffi::meta_window_actor_is_destroyed(self.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_window_actor_sync_visibility")]
    pub fn sync_visibility(&self) {
        unsafe {
            ffi::meta_window_actor_sync_visibility(self.to_glib_none().0);
        }
    }

    /// Thaws/unfreezes the [`WindowActor`][crate::WindowActor] to allow updates and geometry
    /// changes after a window was frozen using [`freeze()`][Self::freeze()].
    #[doc(alias = "meta_window_actor_thaw")]
    pub fn thaw(&self) {
        unsafe {
            ffi::meta_window_actor_thaw(self.to_glib_none().0);
        }
    }

    /// Notify that one or more of the surfaces of the window have been damaged.
    #[doc(alias = "damaged")]
    pub fn connect_damaged<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn damaged_trampoline<F: Fn(&WindowActor) + 'static>(this: *mut ffi::MetaWindowActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"damaged\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(damaged_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// The ::effects-completed signal will be emitted once all pending compositor
    /// effects are completed.
    #[doc(alias = "effects-completed")]
    pub fn connect_effects_completed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn effects_completed_trampoline<F: Fn(&WindowActor) + 'static>(this: *mut ffi::MetaWindowActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"effects-completed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(effects_completed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// The ::first-frame signal will be emitted the first time a frame
    /// of window contents has been drawn by the application and Mutter
    /// has had the chance to drawn that frame to the screen. If the
    /// window starts off initially hidden, obscured, or on on a
    /// different workspace, the ::first-frame signal will be emitted
    /// even though the user doesn't see the contents.
    ///
    /// MetaDisplay::window-created is a good place to connect to this
    /// signal - at that point, the MetaWindowActor for the window
    /// exists, but the window has reliably not yet been drawn.
    /// Connecting to an existing window that has already been drawn to
    /// the screen is not useful.
    #[doc(alias = "first-frame")]
    pub fn connect_first_frame<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn first_frame_trampoline<F: Fn(&WindowActor) + 'static>(this: *mut ffi::MetaWindowActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"first-frame\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(first_frame_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "thawed")]
    pub fn connect_thawed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn thawed_trampoline<F: Fn(&WindowActor) + 'static>(this: *mut ffi::MetaWindowActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"thawed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(thawed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for WindowActor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("WindowActor")
    }
}
