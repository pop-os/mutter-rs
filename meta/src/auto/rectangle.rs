// Generated by gir (https://github.com/gtk-rs/gir @ 5bbf6cb)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

use glib::translate::*;

glib::wrapper! {
    #[derive(Debug, PartialOrd, Ord, Hash)]
    pub struct Rectangle(Boxed<ffi::MetaRectangle>);

    match fn {
        copy => |ptr| ffi::meta_rectangle_copy(ptr),
        free => |ptr| ffi::meta_rectangle_free(ptr),
        type_ => || ffi::meta_rectangle_get_type(),
    }
}

impl Rectangle {
    #[doc(alias = "meta_rectangle_area")]
    pub fn area(&self) -> i32 {
        unsafe {
            ffi::meta_rectangle_area(self.to_glib_none().0)
        }
    }

    #[doc(alias = "meta_rectangle_contains_rect")]
    pub fn contains_rect(&self, inner_rect: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::meta_rectangle_contains_rect(self.to_glib_none().0, inner_rect.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_rectangle_could_fit_rect")]
    pub fn could_fit_rect(&self, inner_rect: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::meta_rectangle_could_fit_rect(self.to_glib_none().0, inner_rect.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_rectangle_equal")]
    fn equal(&self, src2: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::meta_rectangle_equal(self.to_glib_none().0, src2.to_glib_none().0))
        }
    }

    #[doc(alias = "meta_rectangle_horiz_overlap")]
    pub fn horiz_overlap(&self, rect2: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::meta_rectangle_horiz_overlap(self.to_glib_none().0, rect2.to_glib_none().0))
        }
    }

    /// ## `src2`
    /// another [`Rectangle`][crate::Rectangle]
    ///
    /// # Returns
    ///
    /// TRUE is some intersection exists and is not degenerate, FALSE
    ///  otherwise.
    ///
    /// ## `dest`
    /// an empty [`Rectangle`][crate::Rectangle], to be filled
    ///  with the coordinates of the intersection.
    #[doc(alias = "meta_rectangle_intersect")]
    pub fn intersect(&self, src2: &Rectangle) -> Option<Rectangle> {
        unsafe {
            let mut dest = Rectangle::uninitialized();
            let ret = from_glib(ffi::meta_rectangle_intersect(self.to_glib_none().0, src2.to_glib_none().0, dest.to_glib_none_mut().0));
            if ret { Some(dest) } else { None }
        }
    }

    #[doc(alias = "meta_rectangle_overlap")]
    pub fn overlap(&self, rect2: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::meta_rectangle_overlap(self.to_glib_none().0, rect2.to_glib_none().0))
        }
    }

    /// ## `rect2`
    /// another [`Rectangle`][crate::Rectangle]
    ///
    /// # Returns
    ///
    ///
    /// ## `dest`
    /// an empty [`Rectangle`][crate::Rectangle], to be filled
    ///  with the coordinates of the bounding box.
    #[doc(alias = "meta_rectangle_union")]
    pub fn union(&self, rect2: &Rectangle) -> Rectangle {
        unsafe {
            let mut dest = Rectangle::uninitialized();
            ffi::meta_rectangle_union(self.to_glib_none().0, rect2.to_glib_none().0, dest.to_glib_none_mut().0);
            dest
        }
    }

    #[doc(alias = "meta_rectangle_vert_overlap")]
    pub fn vert_overlap(&self, rect2: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::meta_rectangle_vert_overlap(self.to_glib_none().0, rect2.to_glib_none().0))
        }
    }
}

impl PartialEq for Rectangle {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.equal(other)
    }
}

impl Eq for Rectangle {}
