// Generated by gir (https://github.com/gtk-rs/gir @ b193568)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

use crate::Display;
use crate::MotionDirection;
use crate::Rectangle;
use crate::Window;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "MetaWorkspace")]
    pub struct Workspace(Object<ffi::MetaWorkspace, ffi::MetaWorkspaceClass>);

    match fn {
        type_ => || ffi::meta_workspace_get_type(),
    }
}

impl Workspace {
    #[doc(alias = "meta_workspace_activate")]
    pub fn activate(&self, timestamp: u32) {
        unsafe {
            ffi::meta_workspace_activate(self.to_glib_none().0, timestamp);
        }
    }

    /// Switches to `self` and possibly activates the window `focus_this`.
    ///
    /// The window `focus_this` is activated by calling [`Window::activate()`][crate::Window::activate()]
    /// which will unminimize it and transient parents, raise it and give it
    /// the focus.
    ///
    /// If a window is currently being moved by the user, it will be
    /// moved to `self`.
    ///
    /// The advantage of calling this function instead of [`activate()`][Self::activate()]
    /// followed by [`Window::activate()`][crate::Window::activate()] is that it happens as a unit, so
    /// no other window gets focused first before `focus_this`.
    /// ## `focus_this`
    /// the [`Window`][crate::Window] to be focused, or [`None`]
    /// ## `timestamp`
    /// timestamp for `focus_this`
    #[doc(alias = "meta_workspace_activate_with_focus")]
    pub fn activate_with_focus(&self, focus_this: &Window, timestamp: u32) {
        unsafe {
            ffi::meta_workspace_activate_with_focus(self.to_glib_none().0, focus_this.to_glib_none().0, timestamp);
        }
    }

    /// Gets the [`Display`][crate::Display] that the workspace is part of.
    ///
    /// # Returns
    ///
    /// the [`Display`][crate::Display] for the workspace
    #[doc(alias = "meta_workspace_get_display")]
    #[doc(alias = "get_display")]
    pub fn display(&self) -> Option<Display> {
        unsafe {
            from_glib_none(ffi::meta_workspace_get_display(self.to_glib_none().0))
        }
    }

    /// Calculate and retrieve the workspace that is next to `self`,
    /// according to `direction` and the current workspace layout, as set
    /// by `meta_screen_override_workspace_layout()`.
    /// ## `direction`
    /// a [`MotionDirection`][crate::MotionDirection], relative to `self`
    ///
    /// # Returns
    ///
    /// the workspace next to `self`, or
    ///  `self` itself if the neighbor would be outside the layout
    #[doc(alias = "meta_workspace_get_neighbor")]
    #[doc(alias = "get_neighbor")]
    pub fn neighbor(&self, direction: MotionDirection) -> Option<Workspace> {
        unsafe {
            from_glib_none(ffi::meta_workspace_get_neighbor(self.to_glib_none().0, direction.into_glib()))
        }
    }

    /// Stores the work area in `area`.
    ///
    /// # Returns
    ///
    ///
    /// ## `area`
    /// location to store the work area
    #[doc(alias = "meta_workspace_get_work_area_all_monitors")]
    #[doc(alias = "get_work_area_all_monitors")]
    pub fn work_area_all_monitors(&self) -> Rectangle {
        unsafe {
            let mut area = Rectangle::uninitialized();
            ffi::meta_workspace_get_work_area_all_monitors(self.to_glib_none().0, area.to_glib_none_mut().0);
            area
        }
    }

    /// Stores the work area for `which_monitor` on `self`
    /// in `area`.
    /// ## `which_monitor`
    /// a monitor index
    ///
    /// # Returns
    ///
    ///
    /// ## `area`
    /// location to store the work area
    #[doc(alias = "meta_workspace_get_work_area_for_monitor")]
    #[doc(alias = "get_work_area_for_monitor")]
    pub fn work_area_for_monitor(&self, which_monitor: i32) -> Rectangle {
        unsafe {
            let mut area = Rectangle::uninitialized();
            ffi::meta_workspace_get_work_area_for_monitor(self.to_glib_none().0, which_monitor, area.to_glib_none_mut().0);
            area
        }
    }

    #[doc(alias = "meta_workspace_index")]
    pub fn index(&self) -> i32 {
        unsafe {
            ffi::meta_workspace_index(self.to_glib_none().0)
        }
    }

    /// Gets windows contained on the workspace, including workspace->windows
    /// and also sticky windows. Override-redirect windows are not included.
    ///
    /// # Returns
    ///
    /// the list of windows.
    #[doc(alias = "meta_workspace_list_windows")]
    pub fn list_windows(&self) -> Vec<Window> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::meta_workspace_list_windows(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "meta_workspace_set_builtin_struts")]
    //pub fn set_builtin_struts(&self, struts: /*Ignored*/&[&Strut]) {
    //    unsafe { TODO: call ffi:meta_workspace_set_builtin_struts() }
    //}

    pub fn is_active(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"active\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `active` getter")
        }
    }

    #[doc(alias = "n-windows")]
    pub fn n_windows(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"n-windows\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `n-windows` getter")
        }
    }

    #[doc(alias = "workspace-index")]
    pub fn workspace_index(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"workspace-index\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `workspace-index` getter")
        }
    }

    #[doc(alias = "window-added")]
    pub fn connect_window_added<F: Fn(&Self, &Window) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn window_added_trampoline<F: Fn(&Workspace, &Window) + 'static>(this: *mut ffi::MetaWorkspace, object: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"window-added\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(window_added_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "window-removed")]
    pub fn connect_window_removed<F: Fn(&Self, &Window) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn window_removed_trampoline<F: Fn(&Workspace, &Window) + 'static>(this: *mut ffi::MetaWorkspace, object: *mut ffi::MetaWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"window-removed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(window_removed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "active")]
    pub fn connect_active_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_active_trampoline<F: Fn(&Workspace) + 'static>(this: *mut ffi::MetaWorkspace, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::active\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_active_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "n-windows")]
    pub fn connect_n_windows_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_n_windows_trampoline<F: Fn(&Workspace) + 'static>(this: *mut ffi::MetaWorkspace, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::n-windows\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_n_windows_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "workspace-index")]
    pub fn connect_workspace_index_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_workspace_index_trampoline<F: Fn(&Workspace) + 'static>(this: *mut ffi::MetaWorkspace, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::workspace-index\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_workspace_index_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Workspace {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Workspace")
    }
}
