// Generated by gir (https://github.com/gtk-rs/gir @ 5bbf6cb)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]

use cairo_sys as cairo;
use glib_sys as glib;
use gobject_sys as gobject;
use graphene_sys as graphene;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Aliases
pub type CoglAngle = i32;
pub type CoglHandle = *mut c_void;
pub type CoglPipelineKey = *const c_char;
pub type CoglUserDataDestroyCallback = glib::GDestroyNotify;

// Enums
pub type CoglAttributeType = c_int;
pub const COGL_ATTRIBUTE_TYPE_BYTE: CoglAttributeType = 5120;
pub const COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE: CoglAttributeType = 5121;
pub const COGL_ATTRIBUTE_TYPE_SHORT: CoglAttributeType = 5122;
pub const COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT: CoglAttributeType = 5123;
pub const COGL_ATTRIBUTE_TYPE_FLOAT: CoglAttributeType = 5126;

pub type CoglBitmapError = c_int;
pub const COGL_BITMAP_ERROR_FAILED: CoglBitmapError = 0;
pub const COGL_BITMAP_ERROR_UNKNOWN_TYPE: CoglBitmapError = 1;
pub const COGL_BITMAP_ERROR_CORRUPT_IMAGE: CoglBitmapError = 2;

pub type CoglBlendStringError = c_int;
pub const COGL_BLEND_STRING_ERROR_PARSE_ERROR: CoglBlendStringError = 0;
pub const COGL_BLEND_STRING_ERROR_ARGUMENT_PARSE_ERROR: CoglBlendStringError = 1;
pub const COGL_BLEND_STRING_ERROR_INVALID_ERROR: CoglBlendStringError = 2;
pub const COGL_BLEND_STRING_ERROR_GPU_UNSUPPORTED_ERROR: CoglBlendStringError = 3;

pub type CoglDepthTestFunction = c_int;
pub const COGL_DEPTH_TEST_FUNCTION_NEVER: CoglDepthTestFunction = 512;
pub const COGL_DEPTH_TEST_FUNCTION_LESS: CoglDepthTestFunction = 513;
pub const COGL_DEPTH_TEST_FUNCTION_EQUAL: CoglDepthTestFunction = 514;
pub const COGL_DEPTH_TEST_FUNCTION_LEQUAL: CoglDepthTestFunction = 515;
pub const COGL_DEPTH_TEST_FUNCTION_GREATER: CoglDepthTestFunction = 516;
pub const COGL_DEPTH_TEST_FUNCTION_NOTEQUAL: CoglDepthTestFunction = 517;
pub const COGL_DEPTH_TEST_FUNCTION_GEQUAL: CoglDepthTestFunction = 518;
pub const COGL_DEPTH_TEST_FUNCTION_ALWAYS: CoglDepthTestFunction = 519;

pub type CoglFeatureID = c_int;
pub const COGL_FEATURE_ID_UNSIGNED_INT_INDICES: CoglFeatureID = 0;
pub const COGL_FEATURE_ID_MAP_BUFFER_FOR_READ: CoglFeatureID = 1;
pub const COGL_FEATURE_ID_MAP_BUFFER_FOR_WRITE: CoglFeatureID = 2;
pub const COGL_FEATURE_ID_FENCE: CoglFeatureID = 3;
pub const COGL_FEATURE_ID_TEXTURE_RG: CoglFeatureID = 4;
pub const COGL_FEATURE_ID_BUFFER_AGE: CoglFeatureID = 5;
pub const COGL_FEATURE_ID_TEXTURE_EGL_IMAGE_EXTERNAL: CoglFeatureID = 6;
pub const COGL_FEATURE_ID_BLIT_FRAMEBUFFER: CoglFeatureID = 7;

pub type CoglFilterReturn = c_int;
pub const COGL_FILTER_CONTINUE: CoglFilterReturn = 0;
pub const COGL_FILTER_REMOVE: CoglFilterReturn = 1;

pub type CoglFrameEvent = c_int;
pub const COGL_FRAME_EVENT_SYNC: CoglFrameEvent = 1;
pub const COGL_FRAME_EVENT_COMPLETE: CoglFrameEvent = 2;

pub type CoglFramebufferError = c_int;
pub const COGL_FRAMEBUFFER_ERROR_ALLOCATE: CoglFramebufferError = 0;

pub type CoglGraphicsResetStatus = c_int;
pub const COGL_GRAPHICS_RESET_STATUS_NO_ERROR: CoglGraphicsResetStatus = 0;
pub const COGL_GRAPHICS_RESET_STATUS_GUILTY_CONTEXT_RESET: CoglGraphicsResetStatus = 1;
pub const COGL_GRAPHICS_RESET_STATUS_INNOCENT_CONTEXT_RESET: CoglGraphicsResetStatus = 2;
pub const COGL_GRAPHICS_RESET_STATUS_UNKNOWN_CONTEXT_RESET: CoglGraphicsResetStatus = 3;
pub const COGL_GRAPHICS_RESET_STATUS_PURGED_CONTEXT_RESET: CoglGraphicsResetStatus = 4;

pub type CoglIndicesType = c_int;
pub const COGL_INDICES_TYPE_UNSIGNED_BYTE: CoglIndicesType = 0;
pub const COGL_INDICES_TYPE_UNSIGNED_SHORT: CoglIndicesType = 1;
pub const COGL_INDICES_TYPE_UNSIGNED_INT: CoglIndicesType = 2;

pub type CoglMaterialAlphaFunc = c_int;
pub const COGL_MATERIAL_ALPHA_FUNC_NEVER: CoglMaterialAlphaFunc = 512;
pub const COGL_MATERIAL_ALPHA_FUNC_LESS: CoglMaterialAlphaFunc = 513;
pub const COGL_MATERIAL_ALPHA_FUNC_EQUAL: CoglMaterialAlphaFunc = 514;
pub const COGL_MATERIAL_ALPHA_FUNC_LEQUAL: CoglMaterialAlphaFunc = 515;
pub const COGL_MATERIAL_ALPHA_FUNC_GREATER: CoglMaterialAlphaFunc = 516;
pub const COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL: CoglMaterialAlphaFunc = 517;
pub const COGL_MATERIAL_ALPHA_FUNC_GEQUAL: CoglMaterialAlphaFunc = 518;
pub const COGL_MATERIAL_ALPHA_FUNC_ALWAYS: CoglMaterialAlphaFunc = 519;

pub type CoglMaterialFilter = c_int;
pub const COGL_MATERIAL_FILTER_NEAREST: CoglMaterialFilter = 9728;
pub const COGL_MATERIAL_FILTER_LINEAR: CoglMaterialFilter = 9729;
pub const COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST: CoglMaterialFilter = 9984;
pub const COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST: CoglMaterialFilter = 9985;
pub const COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR: CoglMaterialFilter = 9986;
pub const COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR: CoglMaterialFilter = 9987;

pub type CoglMaterialWrapMode = c_int;
pub const COGL_MATERIAL_WRAP_MODE_REPEAT: CoglMaterialWrapMode = 10497;
pub const COGL_MATERIAL_WRAP_MODE_CLAMP_TO_EDGE: CoglMaterialWrapMode = 33071;
pub const COGL_MATERIAL_WRAP_MODE_AUTOMATIC: CoglMaterialWrapMode = 519;

pub type CoglPipelineAlphaFunc = c_int;
pub const COGL_PIPELINE_ALPHA_FUNC_NEVER: CoglPipelineAlphaFunc = 512;
pub const COGL_PIPELINE_ALPHA_FUNC_LESS: CoglPipelineAlphaFunc = 513;
pub const COGL_PIPELINE_ALPHA_FUNC_EQUAL: CoglPipelineAlphaFunc = 514;
pub const COGL_PIPELINE_ALPHA_FUNC_LEQUAL: CoglPipelineAlphaFunc = 515;
pub const COGL_PIPELINE_ALPHA_FUNC_GREATER: CoglPipelineAlphaFunc = 516;
pub const COGL_PIPELINE_ALPHA_FUNC_NOTEQUAL: CoglPipelineAlphaFunc = 517;
pub const COGL_PIPELINE_ALPHA_FUNC_GEQUAL: CoglPipelineAlphaFunc = 518;
pub const COGL_PIPELINE_ALPHA_FUNC_ALWAYS: CoglPipelineAlphaFunc = 519;

pub type CoglPipelineCullFaceMode = c_int;
pub const COGL_PIPELINE_CULL_FACE_MODE_NONE: CoglPipelineCullFaceMode = 0;
pub const COGL_PIPELINE_CULL_FACE_MODE_FRONT: CoglPipelineCullFaceMode = 1;
pub const COGL_PIPELINE_CULL_FACE_MODE_BACK: CoglPipelineCullFaceMode = 2;
pub const COGL_PIPELINE_CULL_FACE_MODE_BOTH: CoglPipelineCullFaceMode = 3;

pub type CoglPipelineFilter = c_int;
pub const COGL_PIPELINE_FILTER_NEAREST: CoglPipelineFilter = 9728;
pub const COGL_PIPELINE_FILTER_LINEAR: CoglPipelineFilter = 9729;
pub const COGL_PIPELINE_FILTER_NEAREST_MIPMAP_NEAREST: CoglPipelineFilter = 9984;
pub const COGL_PIPELINE_FILTER_LINEAR_MIPMAP_NEAREST: CoglPipelineFilter = 9985;
pub const COGL_PIPELINE_FILTER_NEAREST_MIPMAP_LINEAR: CoglPipelineFilter = 9986;
pub const COGL_PIPELINE_FILTER_LINEAR_MIPMAP_LINEAR: CoglPipelineFilter = 9987;

pub type CoglPipelineWrapMode = c_int;
pub const COGL_PIPELINE_WRAP_MODE_REPEAT: CoglPipelineWrapMode = 10497;
pub const COGL_PIPELINE_WRAP_MODE_MIRRORED_REPEAT: CoglPipelineWrapMode = 33648;
pub const COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE: CoglPipelineWrapMode = 33071;
pub const COGL_PIPELINE_WRAP_MODE_AUTOMATIC: CoglPipelineWrapMode = 519;

pub type CoglRendererError = c_int;
pub const COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN: CoglRendererError = 0;
pub const COGL_RENDERER_ERROR_BAD_CONSTRAINT: CoglRendererError = 1;

pub type CoglScanoutError = c_int;
pub const COGL_SCANOUT_ERROR_INHIBITED: CoglScanoutError = 0;

pub type CoglShaderType = c_int;
pub const COGL_SHADER_TYPE_VERTEX: CoglShaderType = 0;
pub const COGL_SHADER_TYPE_FRAGMENT: CoglShaderType = 1;

pub type CoglStereoMode = c_int;
pub const COGL_STEREO_BOTH: CoglStereoMode = 0;
pub const COGL_STEREO_LEFT: CoglStereoMode = 1;
pub const COGL_STEREO_RIGHT: CoglStereoMode = 2;

pub type CoglSystemError = c_int;
pub const COGL_SYSTEM_ERROR_UNSUPPORTED: CoglSystemError = 0;
pub const COGL_SYSTEM_ERROR_NO_MEMORY: CoglSystemError = 1;

pub type CoglTextureComponents = c_int;
pub const COGL_TEXTURE_COMPONENTS_A: CoglTextureComponents = 1;
pub const COGL_TEXTURE_COMPONENTS_RG: CoglTextureComponents = 2;
pub const COGL_TEXTURE_COMPONENTS_RGB: CoglTextureComponents = 3;
pub const COGL_TEXTURE_COMPONENTS_RGBA: CoglTextureComponents = 4;
pub const COGL_TEXTURE_COMPONENTS_DEPTH: CoglTextureComponents = 5;

pub type CoglTextureError = c_int;
pub const COGL_TEXTURE_ERROR_SIZE: CoglTextureError = 0;
pub const COGL_TEXTURE_ERROR_FORMAT: CoglTextureError = 1;
pub const COGL_TEXTURE_ERROR_BAD_PARAMETER: CoglTextureError = 2;
pub const COGL_TEXTURE_ERROR_TYPE: CoglTextureError = 3;

pub type CoglVerticesMode = c_int;
pub const COGL_VERTICES_MODE_POINTS: CoglVerticesMode = 0;
pub const COGL_VERTICES_MODE_LINES: CoglVerticesMode = 1;
pub const COGL_VERTICES_MODE_LINE_LOOP: CoglVerticesMode = 2;
pub const COGL_VERTICES_MODE_LINE_STRIP: CoglVerticesMode = 3;
pub const COGL_VERTICES_MODE_TRIANGLES: CoglVerticesMode = 4;
pub const COGL_VERTICES_MODE_TRIANGLE_STRIP: CoglVerticesMode = 5;
pub const COGL_VERTICES_MODE_TRIANGLE_FAN: CoglVerticesMode = 6;

pub type CoglWinding = c_int;
pub const COGL_WINDING_CLOCKWISE: CoglWinding = 0;
pub const COGL_WINDING_COUNTER_CLOCKWISE: CoglWinding = 1;

pub type CoglWinsysFeature = c_int;
pub const COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN: CoglWinsysFeature = 0;
pub const COGL_WINSYS_FEATURE_VBLANK_COUNTER: CoglWinsysFeature = 1;
pub const COGL_WINSYS_FEATURE_VBLANK_WAIT: CoglWinsysFeature = 2;
pub const COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP: CoglWinsysFeature = 3;
pub const COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT: CoglWinsysFeature = 4;
pub const COGL_WINSYS_FEATURE_SWAP_REGION: CoglWinsysFeature = 5;
pub const COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE: CoglWinsysFeature = 6;
pub const COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED: CoglWinsysFeature = 7;
pub const COGL_WINSYS_FEATURE_BUFFER_AGE: CoglWinsysFeature = 8;
pub const COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT: CoglWinsysFeature = 9;
pub const COGL_WINSYS_FEATURE_N_FEATURES: CoglWinsysFeature = 10;

// Constants
pub const COGL_AFIRST_BIT: c_int = 64;
pub const COGL_A_BIT: c_int = 16;
pub const COGL_BGR_BIT: c_int = 32;
pub const COGL_DEPTH_BIT: c_int = 256;
pub const COGL_PIXEL_FORMAT_MAX_PLANES: c_int = 4;
pub const COGL_PREMULT_BIT: c_int = 128;
pub const COGL_STENCIL_BIT: c_int = 512;
pub const COGL_TEXTURE_MAX_WASTE: c_int = 127;

// Flags
pub type CoglBufferBit = c_uint;
pub const COGL_BUFFER_BIT_COLOR: CoglBufferBit = 1;
pub const COGL_BUFFER_BIT_DEPTH: CoglBufferBit = 2;
pub const COGL_BUFFER_BIT_STENCIL: CoglBufferBit = 4;

pub type CoglBufferTarget = c_uint;
pub const COGL_WINDOW_BUFFER: CoglBufferTarget = 2;
pub const COGL_OFFSCREEN_BUFFER: CoglBufferTarget = 4;

pub type CoglEglImageFlags = c_uint;
pub const COGL_EGL_IMAGE_FLAG_NONE: CoglEglImageFlags = 0;
pub const COGL_EGL_IMAGE_FLAG_NO_GET_DATA: CoglEglImageFlags = 1;

pub type CoglPixelFormat = c_uint;
pub const COGL_PIXEL_FORMAT_ANY: CoglPixelFormat = 0;
pub const COGL_PIXEL_FORMAT_A_8: CoglPixelFormat = 17;
pub const COGL_PIXEL_FORMAT_RGB_565: CoglPixelFormat = 4;
pub const COGL_PIXEL_FORMAT_RGBA_4444: CoglPixelFormat = 21;
pub const COGL_PIXEL_FORMAT_RGBA_5551: CoglPixelFormat = 22;
pub const COGL_PIXEL_FORMAT_YUV: CoglPixelFormat = 7;
pub const COGL_PIXEL_FORMAT_G_8: CoglPixelFormat = 8;
pub const COGL_PIXEL_FORMAT_RG_88: CoglPixelFormat = 9;
pub const COGL_PIXEL_FORMAT_RGB_888: CoglPixelFormat = 2;
pub const COGL_PIXEL_FORMAT_BGR_888: CoglPixelFormat = 34;
pub const COGL_PIXEL_FORMAT_RGBA_8888: CoglPixelFormat = 19;
pub const COGL_PIXEL_FORMAT_BGRA_8888: CoglPixelFormat = 51;
pub const COGL_PIXEL_FORMAT_ARGB_8888: CoglPixelFormat = 83;
pub const COGL_PIXEL_FORMAT_ABGR_8888: CoglPixelFormat = 115;
pub const COGL_PIXEL_FORMAT_RGBA_1010102: CoglPixelFormat = 29;
pub const COGL_PIXEL_FORMAT_BGRA_1010102: CoglPixelFormat = 61;
pub const COGL_PIXEL_FORMAT_ARGB_2101010: CoglPixelFormat = 93;
pub const COGL_PIXEL_FORMAT_ABGR_2101010: CoglPixelFormat = 125;
pub const COGL_PIXEL_FORMAT_RGBA_FP_16161616: CoglPixelFormat = 27;
pub const COGL_PIXEL_FORMAT_BGRA_FP_16161616: CoglPixelFormat = 59;
pub const COGL_PIXEL_FORMAT_ARGB_FP_16161616: CoglPixelFormat = 91;
pub const COGL_PIXEL_FORMAT_ABGR_FP_16161616: CoglPixelFormat = 123;
pub const COGL_PIXEL_FORMAT_RGBA_8888_PRE: CoglPixelFormat = 147;
pub const COGL_PIXEL_FORMAT_BGRA_8888_PRE: CoglPixelFormat = 179;
pub const COGL_PIXEL_FORMAT_ARGB_8888_PRE: CoglPixelFormat = 211;
pub const COGL_PIXEL_FORMAT_ABGR_8888_PRE: CoglPixelFormat = 243;
pub const COGL_PIXEL_FORMAT_RGBA_4444_PRE: CoglPixelFormat = 149;
pub const COGL_PIXEL_FORMAT_RGBA_5551_PRE: CoglPixelFormat = 150;
pub const COGL_PIXEL_FORMAT_RGBA_1010102_PRE: CoglPixelFormat = 157;
pub const COGL_PIXEL_FORMAT_BGRA_1010102_PRE: CoglPixelFormat = 189;
pub const COGL_PIXEL_FORMAT_ARGB_2101010_PRE: CoglPixelFormat = 221;
pub const COGL_PIXEL_FORMAT_ABGR_2101010_PRE: CoglPixelFormat = 253;
pub const COGL_PIXEL_FORMAT_RGBA_FP_16161616_PRE: CoglPixelFormat = 155;
pub const COGL_PIXEL_FORMAT_BGRA_FP_16161616_PRE: CoglPixelFormat = 187;
pub const COGL_PIXEL_FORMAT_ARGB_FP_16161616_PRE: CoglPixelFormat = 219;
pub const COGL_PIXEL_FORMAT_ABGR_FP_16161616_PRE: CoglPixelFormat = 251;
pub const COGL_PIXEL_FORMAT_DEPTH_16: CoglPixelFormat = 265;
pub const COGL_PIXEL_FORMAT_DEPTH_32: CoglPixelFormat = 259;
pub const COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8: CoglPixelFormat = 771;

pub type CoglReadPixelsFlags = c_uint;
pub const COGL_READ_PIXELS_COLOR_BUFFER: CoglReadPixelsFlags = 1;

pub type CoglTextureFlags = c_uint;
pub const COGL_TEXTURE_NONE: CoglTextureFlags = 0;
pub const COGL_TEXTURE_NO_AUTO_MIPMAP: CoglTextureFlags = 1;
pub const COGL_TEXTURE_NO_SLICING: CoglTextureFlags = 2;
pub const COGL_TEXTURE_NO_ATLAS: CoglTextureFlags = 4;

// Callbacks
pub type CoglDebugObjectForeachTypeCallback = Option<unsafe extern "C" fn(*const CoglDebugObjectTypeInfo, *mut c_void)>;
pub type CoglFeatureCallback = Option<unsafe extern "C" fn(CoglFeatureID, *mut c_void)>;
pub type CoglFrameCallback = Option<unsafe extern "C" fn(*mut CoglOnscreen, CoglFrameEvent, *mut CoglFrameInfo, *mut c_void)>;
pub type CoglOnscreenDirtyCallback = Option<unsafe extern "C" fn(*mut CoglOnscreen, *const CoglOnscreenDirtyInfo, *mut c_void)>;
pub type CoglPipelineLayerCallback = Option<unsafe extern "C" fn(*mut CoglPipeline, c_int, *mut c_void) -> gboolean>;
pub type CoglTexture2DEGLImageExternalAlloc = Option<unsafe extern "C" fn(*mut CoglTexture2D, gpointer, *mut *mut glib::GError) -> gboolean>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglColor {
    pub private_member_red: u8,
    pub private_member_green: u8,
    pub private_member_blue: u8,
    pub private_member_alpha: u8,
    pub private_member_padding0: u32,
    pub private_member_padding1: u32,
    pub private_member_padding2: u32,
}

impl ::std::fmt::Debug for CoglColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglColor @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglDebugObjectTypeInfo {
    pub name: *const c_char,
    pub instance_count: c_ulong,
}

impl ::std::fmt::Debug for CoglDebugObjectTypeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglDebugObjectTypeInfo @ {:p}", self))
         .field("name", &self.name)
         .field("instance_count", &self.instance_count)
         .finish()
    }
}

#[repr(C)]
pub struct _CoglDmaBufHandle(c_void);

pub type CoglDmaBufHandle = *mut _CoglDmaBufHandle;

#[repr(C)]
pub struct CoglFrameClosure(c_void);

impl ::std::fmt::Debug for CoglFrameClosure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglFrameClosure @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglFramebufferClass {
    pub parent_class: gobject::GObjectClass,
    pub allocate: Option<unsafe extern "C" fn(*mut CoglFramebuffer, *mut *mut glib::GError) -> gboolean>,
    pub is_y_flipped: Option<unsafe extern "C" fn(*mut CoglFramebuffer) -> gboolean>,
}

impl ::std::fmt::Debug for CoglFramebufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglFramebufferClass @ {:p}", self))
         .field("allocate", &self.allocate)
         .field("is_y_flipped", &self.is_y_flipped)
         .finish()
    }
}

#[repr(C)]
pub struct _CoglFramebufferDriverConfig(c_void);

pub type CoglFramebufferDriverConfig = *mut _CoglFramebufferDriverConfig;

#[repr(C)]
pub struct CoglMaterial(c_void);

impl ::std::fmt::Debug for CoglMaterial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglMaterial @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
pub struct _CoglMaterialLayer(c_void);

pub type CoglMaterialLayer = *mut _CoglMaterialLayer;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglOffscreenClass {
    pub parent_class: CoglFramebufferClass,
}

impl ::std::fmt::Debug for CoglOffscreenClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglOffscreenClass @ {:p}", self))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglOnscreenClass {
    pub parent_class: CoglFramebufferClass,
    pub bind: Option<unsafe extern "C" fn(*mut CoglOnscreen)>,
    pub swap_buffers_with_damage: Option<unsafe extern "C" fn(*mut CoglOnscreen, *const c_int, c_int, *mut CoglFrameInfo, gpointer)>,
    pub swap_region: Option<unsafe extern "C" fn(*mut CoglOnscreen, *const c_int, c_int, *mut CoglFrameInfo, gpointer)>,
    pub direct_scanout: Option<unsafe extern "C" fn(*mut CoglOnscreen, *mut CoglScanout, *mut CoglFrameInfo, gpointer, *mut *mut glib::GError) -> gboolean>,
    pub get_buffer_age: Option<unsafe extern "C" fn(*mut CoglOnscreen) -> c_int>,
}

impl ::std::fmt::Debug for CoglOnscreenClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglOnscreenClass @ {:p}", self))
         .field("bind", &self.bind)
         .field("swap_buffers_with_damage", &self.swap_buffers_with_damage)
         .field("swap_region", &self.swap_region)
         .field("direct_scanout", &self.direct_scanout)
         .field("get_buffer_age", &self.get_buffer_age)
         .finish()
    }
}

#[repr(C)]
pub struct CoglOnscreenDirtyClosure(c_void);

impl ::std::fmt::Debug for CoglOnscreenDirtyClosure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglOnscreenDirtyClosure @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglOnscreenDirtyInfo {
    pub x: c_int,
    pub y: c_int,
    pub width: c_int,
    pub height: c_int,
}

impl ::std::fmt::Debug for CoglOnscreenDirtyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglOnscreenDirtyInfo @ {:p}", self))
         .field("x", &self.x)
         .field("y", &self.y)
         .field("width", &self.width)
         .field("height", &self.height)
         .finish()
    }
}

#[repr(C)]
pub struct _CoglScanout(c_void);

pub type CoglScanout = *mut _CoglScanout;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglTextureVertex {
    pub x: c_float,
    pub y: c_float,
    pub z: c_float,
    pub tx: c_float,
    pub ty: c_float,
    pub color: CoglColor,
}

impl ::std::fmt::Debug for CoglTextureVertex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglTextureVertex @ {:p}", self))
         .field("x", &self.x)
         .field("y", &self.y)
         .field("z", &self.z)
         .field("tx", &self.tx)
         .field("ty", &self.ty)
         .field("color", &self.color)
         .finish()
    }
}

#[repr(C)]
pub struct _CoglTraceContext(c_void);

pub type CoglTraceContext = *mut _CoglTraceContext;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglTraceHead {
    pub begin_time: u64,
    pub name: *const c_char,
}

impl ::std::fmt::Debug for CoglTraceHead {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglTraceHead @ {:p}", self))
         .field("begin_time", &self.begin_time)
         .field("name", &self.name)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglUserDataKey {
    pub unused: c_int,
}

impl ::std::fmt::Debug for CoglUserDataKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglUserDataKey @ {:p}", self))
         .field("unused", &self.unused)
         .finish()
    }
}

#[repr(C)]
pub struct _CoglColorSizeCheck {
    _truncated_record_marker: c_void,
    // /*Ignored*/field compile_time_assert_CoglColor_size has empty c:type
}

impl ::std::fmt::Debug for _CoglColorSizeCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("_CoglColorSizeCheck @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
pub struct _CoglTextureVertexSizeCheck {
    _truncated_record_marker: c_void,
    // /*Ignored*/field compile_time_assert_CoglTextureVertex_size has empty c:type
}

impl ::std::fmt::Debug for _CoglTextureVertexSizeCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("_CoglTextureVertexSizeCheck @ {:p}", self))
         .finish()
    }
}

// Classes
#[repr(C)]
pub struct CoglBitmap(c_void);

impl ::std::fmt::Debug for CoglBitmap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglBitmap @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
pub struct CoglContext(c_void);

impl ::std::fmt::Debug for CoglContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglContext @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
pub struct CoglFrameInfo(c_void);

impl ::std::fmt::Debug for CoglFrameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglFrameInfo @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglFramebuffer {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for CoglFramebuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglFramebuffer @ {:p}", self))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct CoglObject(c_void);

impl ::std::fmt::Debug for CoglObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglObject @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
pub struct CoglOffscreen(c_void);

impl ::std::fmt::Debug for CoglOffscreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglOffscreen @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoglOnscreen {
    pub parent_instance: CoglFramebuffer,
}

impl ::std::fmt::Debug for CoglOnscreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglOnscreen @ {:p}", self))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct CoglPipeline(c_void);

impl ::std::fmt::Debug for CoglPipeline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglPipeline @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
pub struct CoglTexture2D(c_void);

impl ::std::fmt::Debug for CoglTexture2D {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglTexture2D @ {:p}", self))
         .finish()
    }
}

#[repr(C)]
pub struct CoglTexture2DSliced(c_void);

impl ::std::fmt::Debug for CoglTexture2DSliced {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("CoglTexture2DSliced @ {:p}", self))
         .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct CoglTexture(c_void);

impl ::std::fmt::Debug for CoglTexture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "CoglTexture @ {:p}", self)
    }
}


#[link(name = "mutter-cogl-8")]
extern "C" {

    //=========================================================================
    // CoglColor
    //=========================================================================
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_gtype() -> GType;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_new() -> *mut CoglColor;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_copy(color: *const CoglColor) -> *mut CoglColor;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_free(color: *mut CoglColor);
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_alpha(color: *const CoglColor) -> c_float;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_alpha_byte(color: *const CoglColor) -> u8;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_alpha_float(color: *const CoglColor) -> c_float;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_blue(color: *const CoglColor) -> c_float;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_blue_byte(color: *const CoglColor) -> u8;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_blue_float(color: *const CoglColor) -> c_float;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_green(color: *const CoglColor) -> c_float;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_green_byte(color: *const CoglColor) -> u8;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_green_float(color: *const CoglColor) -> c_float;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_red(color: *const CoglColor) -> c_float;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_red_byte(color: *const CoglColor) -> u8;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_get_red_float(color: *const CoglColor) -> c_float;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_init_from_4f(color: *mut CoglColor, red: c_float, green: c_float, blue: c_float, alpha: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_init_from_4fv(color: *mut CoglColor, color_array: *const c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_init_from_4ub(color: *mut CoglColor, red: u8, green: u8, blue: u8, alpha: u8);
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_premultiply(color: *mut CoglColor);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_alpha(color: *mut CoglColor, alpha: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_alpha_byte(color: *mut CoglColor, alpha: u8);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_alpha_float(color: *mut CoglColor, alpha: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_blue(color: *mut CoglColor, blue: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_blue_byte(color: *mut CoglColor, blue: u8);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_blue_float(color: *mut CoglColor, blue: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_green(color: *mut CoglColor, green: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_green_byte(color: *mut CoglColor, green: u8);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_green_float(color: *mut CoglColor, green: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_red(color: *mut CoglColor, red: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_red_byte(color: *mut CoglColor, red: u8);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_set_red_float(color: *mut CoglColor, red: c_float);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_color_to_hsl(color: *const CoglColor, hue: *mut c_float, saturation: *mut c_float, luminance: *mut c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_color_unpremultiply(color: *mut CoglColor);
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_color_equal(v1: *mut c_void, v2: *mut c_void) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_color_init_from_hsl(color: *mut CoglColor, hue: c_float, saturation: c_float, luminance: c_float);

    //=========================================================================
    // CoglFrameClosure
    //=========================================================================
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    pub fn cogl_frame_closure_get_gtype() -> GType;

    //=========================================================================
    // CoglMaterial
    //=========================================================================
    pub fn cogl_material_get_type() -> GType;
    pub fn cogl_material_new() -> *mut CoglMaterial;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_material_set_alpha_test_function(material: *mut CoglMaterial, alpha_func: CoglMaterialAlphaFunc, alpha_reference: c_float);
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_material_set_blend(material: *mut CoglMaterial, blend_string: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_material_set_blend_constant(material: *mut CoglMaterial, constant_color: *const CoglColor);
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_material_set_color(material: *mut CoglMaterial, color: *const CoglColor);
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_material_set_color4ub(material: *mut CoglMaterial, red: u8, green: u8, blue: u8, alpha: u8);
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_material_set_layer(material: *mut CoglMaterial, layer_index: c_int, texture: CoglHandle);
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_material_set_layer_combine(material: *mut CoglMaterial, layer_index: c_int, blend_string: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_material_set_layer_combine_constant(material: *mut CoglMaterial, layer_index: c_int, constant: *const CoglColor);
    pub fn cogl_material_set_layer_filters(material: *mut CoglMaterial, layer_index: c_int, min_filter: CoglMaterialFilter, mag_filter: CoglMaterialFilter);
    pub fn cogl_material_set_layer_matrix(material: *mut CoglMaterial, layer_index: c_int, matrix: *const graphene::graphene_matrix_t);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_material_set_layer_point_sprite_coords_enabled(material: *mut CoglMaterial, layer_index: c_int, enable: gboolean, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_material_set_point_size(material: *mut CoglMaterial, point_size: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_material_set_user_program(material: *mut CoglMaterial, program: CoglHandle);

    //=========================================================================
    // CoglOnscreenDirtyClosure
    //=========================================================================
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_onscreen_dirty_closure_get_gtype() -> GType;

    //=========================================================================
    // CoglScanout
    //=========================================================================
    pub fn cogl_scanout_error_quark() -> glib::GQuark;

    //=========================================================================
    // CoglBitmap
    //=========================================================================
    pub fn cogl_bitmap_get_gtype() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_bitmap_new_for_data(context: *mut CoglContext, width: c_int, height: c_int, format: CoglPixelFormat, rowstride: c_int, data: *mut u8) -> *mut CoglBitmap;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_bitmap_new_from_file(filename: *const c_char, error: *mut *mut glib::GError) -> *mut CoglBitmap;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_bitmap_new_with_size(context: *mut CoglContext, width: c_uint, height: c_uint, format: CoglPixelFormat) -> *mut CoglBitmap;
    pub fn cogl_bitmap_error_quark() -> u32;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_bitmap_get_size_from_file(filename: *const c_char, width: *mut c_int, height: *mut c_int) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_bitmap_get_format(bitmap: *mut CoglBitmap) -> CoglPixelFormat;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_bitmap_get_height(bitmap: *mut CoglBitmap) -> c_int;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_bitmap_get_rowstride(bitmap: *mut CoglBitmap) -> c_int;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_bitmap_get_width(bitmap: *mut CoglBitmap) -> c_int;

    //=========================================================================
    // CoglContext
    //=========================================================================
    pub fn cogl_context_get_gtype() -> GType;
    pub fn cogl_context_get_named_pipeline(context: *mut CoglContext, key: *mut CoglPipelineKey) -> *mut CoglPipeline;
    pub fn cogl_context_is_hardware_accelerated(context: *mut CoglContext) -> gboolean;
    pub fn cogl_context_set_named_pipeline(context: *mut CoglContext, key: *mut CoglPipelineKey, pipeline: *mut CoglPipeline);

    //=========================================================================
    // CoglFrameInfo
    //=========================================================================
    pub fn cogl_frame_info_get_gtype() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    pub fn cogl_frame_info_get_frame_counter(info: *mut CoglFrameInfo) -> i64;
    pub fn cogl_frame_info_get_global_frame_counter(info: *mut CoglFrameInfo) -> i64;
    pub fn cogl_frame_info_get_is_symbolic(info: *mut CoglFrameInfo) -> gboolean;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    pub fn cogl_frame_info_get_presentation_time_us(info: *mut CoglFrameInfo) -> i64;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    pub fn cogl_frame_info_get_refresh_rate(info: *mut CoglFrameInfo) -> c_float;
    pub fn cogl_frame_info_get_sequence(info: *mut CoglFrameInfo) -> c_uint;
    pub fn cogl_frame_info_is_hw_clock(info: *mut CoglFrameInfo) -> gboolean;
    pub fn cogl_frame_info_is_vsync(info: *mut CoglFrameInfo) -> gboolean;
    pub fn cogl_frame_info_is_zero_copy(info: *mut CoglFrameInfo) -> gboolean;

    //=========================================================================
    // CoglFramebuffer
    //=========================================================================
    pub fn cogl_framebuffer_get_type() -> GType;
    pub fn cogl_framebuffer_error_quark() -> u32;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_allocate(framebuffer: *mut CoglFramebuffer, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_clear(framebuffer: *mut CoglFramebuffer, buffers: c_ulong, color: *const CoglColor);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_clear4f(framebuffer: *mut CoglFramebuffer, buffers: c_ulong, red: c_float, green: c_float, blue: c_float, alpha: c_float);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_discard_buffers(framebuffer: *mut CoglFramebuffer, buffers: c_ulong);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_draw_multitextured_rectangle(framebuffer: *mut CoglFramebuffer, pipeline: *mut CoglPipeline, x_1: c_float, y_1: c_float, x_2: c_float, y_2: c_float, tex_coords: *const c_float, tex_coords_len: c_int);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_draw_rectangle(framebuffer: *mut CoglFramebuffer, pipeline: *mut CoglPipeline, x_1: c_float, y_1: c_float, x_2: c_float, y_2: c_float);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_draw_rectangles(framebuffer: *mut CoglFramebuffer, pipeline: *mut CoglPipeline, coordinates: *const c_float, n_rectangles: c_uint);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_draw_textured_rectangle(framebuffer: *mut CoglFramebuffer, pipeline: *mut CoglPipeline, x_1: c_float, y_1: c_float, x_2: c_float, y_2: c_float, s_1: c_float, t_1: c_float, s_2: c_float, t_2: c_float);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_draw_textured_rectangles(framebuffer: *mut CoglFramebuffer, pipeline: *mut CoglPipeline, coordinates: *const c_float, n_rectangles: c_uint);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_finish(framebuffer: *mut CoglFramebuffer);
    pub fn cogl_framebuffer_flush(framebuffer: *mut CoglFramebuffer);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_frustum(framebuffer: *mut CoglFramebuffer, left: c_float, right: c_float, bottom: c_float, top: c_float, z_near: c_float, z_far: c_float);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_alpha_bits(framebuffer: *mut CoglFramebuffer) -> c_int;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_blue_bits(framebuffer: *mut CoglFramebuffer) -> c_int;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_context(framebuffer: *mut CoglFramebuffer) -> *mut CoglContext;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_framebuffer_get_depth_bits(framebuffer: *mut CoglFramebuffer) -> c_int;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn cogl_framebuffer_get_depth_write_enabled(framebuffer: *mut CoglFramebuffer) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_dither_enabled(framebuffer: *mut CoglFramebuffer) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_green_bits(framebuffer: *mut CoglFramebuffer) -> c_int;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_height(framebuffer: *mut CoglFramebuffer) -> c_int;
    pub fn cogl_framebuffer_get_is_stereo(framebuffer: *mut CoglFramebuffer) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_get_modelview_matrix(framebuffer: *mut CoglFramebuffer, matrix: *mut graphene::graphene_matrix_t);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_get_projection_matrix(framebuffer: *mut CoglFramebuffer, matrix: *mut graphene::graphene_matrix_t);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_red_bits(framebuffer: *mut CoglFramebuffer) -> c_int;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_get_samples_per_pixel(framebuffer: *mut CoglFramebuffer) -> c_int;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn cogl_framebuffer_get_stereo_mode(framebuffer: *mut CoglFramebuffer) -> CoglStereoMode;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_viewport4fv(framebuffer: *mut CoglFramebuffer, viewport: *mut [c_float; 4]);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_viewport_height(framebuffer: *mut CoglFramebuffer) -> c_float;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_viewport_width(framebuffer: *mut CoglFramebuffer) -> c_float;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_viewport_x(framebuffer: *mut CoglFramebuffer) -> c_float;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_viewport_y(framebuffer: *mut CoglFramebuffer) -> c_float;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_get_width(framebuffer: *mut CoglFramebuffer) -> c_int;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_identity_matrix(framebuffer: *mut CoglFramebuffer);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_orthographic(framebuffer: *mut CoglFramebuffer, x_1: c_float, y_1: c_float, x_2: c_float, y_2: c_float, near: c_float, far: c_float);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_perspective(framebuffer: *mut CoglFramebuffer, fov_y: c_float, aspect: c_float, z_near: c_float, z_far: c_float);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_pop_clip(framebuffer: *mut CoglFramebuffer);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_pop_matrix(framebuffer: *mut CoglFramebuffer);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_push_matrix(framebuffer: *mut CoglFramebuffer);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_push_rectangle_clip(framebuffer: *mut CoglFramebuffer, x_1: c_float, y_1: c_float, x_2: c_float, y_2: c_float);
    pub fn cogl_framebuffer_push_region_clip(framebuffer: *mut CoglFramebuffer, region: *mut cairo::cairo_region_t);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_push_scissor_clip(framebuffer: *mut CoglFramebuffer, x: c_int, y: c_int, width: c_int, height: c_int);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_read_pixels(framebuffer: *mut CoglFramebuffer, x: c_int, y: c_int, width: c_int, height: c_int, format: CoglPixelFormat, pixels: *mut u8) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_read_pixels_into_bitmap(framebuffer: *mut CoglFramebuffer, x: c_int, y: c_int, source: CoglReadPixelsFlags, bitmap: *mut CoglBitmap) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_resolve_samples(framebuffer: *mut CoglFramebuffer);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_resolve_samples_region(framebuffer: *mut CoglFramebuffer, x: c_int, y: c_int, width: c_int, height: c_int);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_rotate(framebuffer: *mut CoglFramebuffer, angle: c_float, x: c_float, y: c_float, z: c_float);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_framebuffer_rotate_euler(framebuffer: *mut CoglFramebuffer, euler: *const graphene::graphene_euler_t);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_scale(framebuffer: *mut CoglFramebuffer, x: c_float, y: c_float, z: c_float);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn cogl_framebuffer_set_depth_write_enabled(framebuffer: *mut CoglFramebuffer, depth_write_enabled: gboolean);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_set_dither_enabled(framebuffer: *mut CoglFramebuffer, dither_enabled: gboolean);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_set_modelview_matrix(framebuffer: *mut CoglFramebuffer, matrix: *const graphene::graphene_matrix_t);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_set_projection_matrix(framebuffer: *mut CoglFramebuffer, matrix: *const graphene::graphene_matrix_t);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_set_samples_per_pixel(framebuffer: *mut CoglFramebuffer, samples_per_pixel: c_int);
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn cogl_framebuffer_set_stereo_mode(framebuffer: *mut CoglFramebuffer, stereo_mode: CoglStereoMode);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_framebuffer_set_viewport(framebuffer: *mut CoglFramebuffer, x: c_float, y: c_float, width: c_float, height: c_float);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_transform(framebuffer: *mut CoglFramebuffer, matrix: *const graphene::graphene_matrix_t);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_framebuffer_translate(framebuffer: *mut CoglFramebuffer, x: c_float, y: c_float, z: c_float);

    //=========================================================================
    // CoglObject
    //=========================================================================
    pub fn cogl_object_get_gtype() -> GType;
    pub fn cogl_object_ref(object: *mut c_void) -> *mut c_void;
    pub fn cogl_object_unref(object: *mut c_void);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_object_get_user_data(object: *mut CoglObject, key: *mut CoglUserDataKey) -> *mut c_void;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_object_set_user_data(object: *mut CoglObject, key: *mut CoglUserDataKey, user_data: *mut c_void, destroy: CoglUserDataDestroyCallback);

    //=========================================================================
    // CoglOffscreen
    //=========================================================================
    pub fn cogl_offscreen_get_type() -> GType;
    pub fn cogl_offscreen_new_with_texture(texture: *mut CoglTexture) -> *mut CoglOffscreen;
    pub fn cogl_offscreen_get_texture(offscreen: *mut CoglOffscreen) -> *mut CoglTexture;

    //=========================================================================
    // CoglOnscreen
    //=========================================================================
    pub fn cogl_onscreen_get_type() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_onscreen_add_dirty_callback(onscreen: *mut CoglOnscreen, callback: CoglOnscreenDirtyCallback, user_data: *mut c_void, destroy: CoglUserDataDestroyCallback) -> *mut CoglOnscreenDirtyClosure;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    pub fn cogl_onscreen_add_frame_callback(onscreen: *mut CoglOnscreen, callback: CoglFrameCallback, user_data: *mut c_void, destroy: CoglUserDataDestroyCallback) -> *mut CoglFrameClosure;
    pub fn cogl_onscreen_add_frame_info(onscreen: *mut CoglOnscreen, info: *mut CoglFrameInfo);
    pub fn cogl_onscreen_direct_scanout(onscreen: *mut CoglOnscreen, scanout: *mut CoglScanout, info: *mut CoglFrameInfo, user_data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    pub fn cogl_onscreen_get_buffer_age(onscreen: *mut CoglOnscreen) -> c_int;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    pub fn cogl_onscreen_get_frame_counter(onscreen: *mut CoglOnscreen) -> i64;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_onscreen_hide(onscreen: *mut CoglOnscreen);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_onscreen_remove_dirty_callback(onscreen: *mut CoglOnscreen, closure: *mut CoglOnscreenDirtyClosure);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    pub fn cogl_onscreen_remove_frame_callback(onscreen: *mut CoglOnscreen, closure: *mut CoglFrameClosure);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_onscreen_show(onscreen: *mut CoglOnscreen);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_onscreen_swap_buffers(onscreen: *mut CoglOnscreen, frame_info: *mut CoglFrameInfo, user_data: gpointer);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_onscreen_swap_buffers_with_damage(onscreen: *mut CoglOnscreen, rectangles: *const c_int, n_rectangles: c_int, info: *mut CoglFrameInfo, user_data: gpointer);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_onscreen_swap_region(onscreen: *mut CoglOnscreen, rectangles: *const c_int, n_rectangles: c_int, info: *mut CoglFrameInfo, user_data: gpointer);

    //=========================================================================
    // CoglPipeline
    //=========================================================================
    pub fn cogl_pipeline_get_gtype() -> GType;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_new(context: *mut CoglContext) -> *mut CoglPipeline;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_copy(source: *mut CoglPipeline) -> *mut CoglPipeline;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_foreach_layer(pipeline: *mut CoglPipeline, callback: CoglPipelineLayerCallback, user_data: *mut c_void);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_alpha_test_function(pipeline: *mut CoglPipeline) -> CoglPipelineAlphaFunc;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_alpha_test_reference(pipeline: *mut CoglPipeline) -> c_float;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_color(pipeline: *mut CoglPipeline, color: *mut CoglColor);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_cull_face_mode(pipeline: *mut CoglPipeline) -> CoglPipelineCullFaceMode;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_front_face_winding(pipeline: *mut CoglPipeline) -> CoglWinding;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_pipeline_get_layer_mag_filter(pipeline: *mut CoglPipeline, layer_index: c_int) -> CoglPipelineFilter;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_pipeline_get_layer_min_filter(pipeline: *mut CoglPipeline, layer_index: c_int) -> CoglPipelineFilter;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_layer_point_sprite_coords_enabled(pipeline: *mut CoglPipeline, layer_index: c_int) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_pipeline_get_layer_texture(pipeline: *mut CoglPipeline, layer_index: c_int) -> *mut CoglTexture;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_layer_wrap_mode_s(pipeline: *mut CoglPipeline, layer_index: c_int) -> CoglPipelineWrapMode;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_layer_wrap_mode_t(pipeline: *mut CoglPipeline, layer_index: c_int) -> CoglPipelineWrapMode;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_n_layers(pipeline: *mut CoglPipeline) -> c_int;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_per_vertex_point_size(pipeline: *mut CoglPipeline) -> gboolean;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_point_size(pipeline: *mut CoglPipeline) -> c_float;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_uniform_location(pipeline: *mut CoglPipeline, uniform_name: *const c_char) -> c_int;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_get_user_program(pipeline: *mut CoglPipeline) -> CoglHandle;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_pipeline_remove_layer(pipeline: *mut CoglPipeline, layer_index: c_int);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_alpha_test_function(pipeline: *mut CoglPipeline, alpha_func: CoglPipelineAlphaFunc, alpha_reference: c_float);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_blend(pipeline: *mut CoglPipeline, blend_string: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_blend_constant(pipeline: *mut CoglPipeline, constant_color: *const CoglColor);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_color(pipeline: *mut CoglPipeline, color: *const CoglColor);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_color4f(pipeline: *mut CoglPipeline, red: c_float, green: c_float, blue: c_float, alpha: c_float);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_color4ub(pipeline: *mut CoglPipeline, red: u8, green: u8, blue: u8, alpha: u8);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_cull_face_mode(pipeline: *mut CoglPipeline, cull_face_mode: CoglPipelineCullFaceMode);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_front_face_winding(pipeline: *mut CoglPipeline, front_winding: CoglWinding);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_layer_combine(pipeline: *mut CoglPipeline, layer_index: c_int, blend_string: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_layer_combine_constant(pipeline: *mut CoglPipeline, layer_index: c_int, constant: *const CoglColor);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_pipeline_set_layer_filters(pipeline: *mut CoglPipeline, layer_index: c_int, min_filter: CoglPipelineFilter, mag_filter: CoglPipelineFilter);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_pipeline_set_layer_matrix(pipeline: *mut CoglPipeline, layer_index: c_int, matrix: *const graphene::graphene_matrix_t);
    pub fn cogl_pipeline_set_layer_max_mipmap_level(pipeline: *mut CoglPipeline, layer: c_int, max_level: c_int);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_pipeline_set_layer_null_texture(pipeline: *mut CoglPipeline, layer_index: c_int);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_layer_point_sprite_coords_enabled(pipeline: *mut CoglPipeline, layer_index: c_int, enable: gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn cogl_pipeline_set_layer_texture(pipeline: *mut CoglPipeline, layer_index: c_int, texture: *mut CoglTexture);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_layer_wrap_mode(pipeline: *mut CoglPipeline, layer_index: c_int, mode: CoglPipelineWrapMode);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_layer_wrap_mode_s(pipeline: *mut CoglPipeline, layer_index: c_int, mode: CoglPipelineWrapMode);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_layer_wrap_mode_t(pipeline: *mut CoglPipeline, layer_index: c_int, mode: CoglPipelineWrapMode);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_per_vertex_point_size(pipeline: *mut CoglPipeline, enable: gboolean, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_point_size(pipeline: *mut CoglPipeline, point_size: c_float);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_uniform_1f(pipeline: *mut CoglPipeline, uniform_location: c_int, value: c_float);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_uniform_1i(pipeline: *mut CoglPipeline, uniform_location: c_int, value: c_int);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_uniform_float(pipeline: *mut CoglPipeline, uniform_location: c_int, n_components: c_int, count: c_int, value: *const c_float);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_uniform_int(pipeline: *mut CoglPipeline, uniform_location: c_int, n_components: c_int, count: c_int, value: *const c_int);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_uniform_matrix(pipeline: *mut CoglPipeline, uniform_location: c_int, dimensions: c_int, count: c_int, transpose: gboolean, value: *const c_float);
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_pipeline_set_user_program(pipeline: *mut CoglPipeline, program: CoglHandle);

    //=========================================================================
    // CoglTexture2D
    //=========================================================================
    pub fn cogl_texture_2d_get_gtype() -> GType;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_texture_2d_new_from_bitmap(bitmap: *mut CoglBitmap) -> *mut CoglTexture2D;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_texture_2d_new_from_data(ctx: *mut CoglContext, width: c_int, height: c_int, format: CoglPixelFormat, rowstride: c_int, data: *const u8, error: *mut *mut glib::GError) -> *mut CoglTexture2D;
    pub fn cogl_texture_2d_new_from_egl_image_external(ctx: *mut CoglContext, width: c_int, height: c_int, alloc: CoglTexture2DEGLImageExternalAlloc, user_data: gpointer, destroy: glib::GDestroyNotify, error: *mut *mut glib::GError) -> *mut CoglTexture2D;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_texture_2d_new_from_file(ctx: *mut CoglContext, filename: *const c_char, error: *mut *mut glib::GError) -> *mut CoglTexture2D;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_texture_2d_new_with_size(ctx: *mut CoglContext, width: c_int, height: c_int) -> *mut CoglTexture2D;
    pub fn cogl_texture_2d_egl_image_external_alloc_finish(tex_2d: *mut CoglTexture2D, user_data: *mut c_void, destroy: glib::GDestroyNotify);
    pub fn cogl_texture_2d_egl_image_external_bind(tex_2d: *mut CoglTexture2D);

    //=========================================================================
    // CoglTexture2DSliced
    //=========================================================================
    pub fn cogl_texture_2d_sliced_get_gtype() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_texture_2d_sliced_new_from_bitmap(bmp: *mut CoglBitmap, max_waste: c_int) -> *mut CoglTexture2DSliced;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_texture_2d_sliced_new_from_data(ctx: *mut CoglContext, width: c_int, height: c_int, max_waste: c_int, format: CoglPixelFormat, rowstride: c_int, data: *const u8, error: *mut *mut glib::GError) -> *mut CoglTexture2DSliced;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn cogl_texture_2d_sliced_new_from_file(ctx: *mut CoglContext, filename: *const c_char, max_waste: c_int, error: *mut *mut glib::GError) -> *mut CoglTexture2DSliced;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_texture_2d_sliced_new_with_size(ctx: *mut CoglContext, width: c_int, height: c_int, max_waste: c_int) -> *mut CoglTexture2DSliced;

    //=========================================================================
    // CoglTexture
    //=========================================================================
    pub fn cogl_texture_get_gtype() -> GType;
    pub fn cogl_texture_error_quark() -> u32;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_texture_new_from_bitmap(bitmap: *mut CoglBitmap, flags: CoglTextureFlags, internal_format: CoglPixelFormat) -> *mut CoglTexture;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_texture_new_from_data(width: c_int, height: c_int, flags: CoglTextureFlags, format: CoglPixelFormat, internal_format: CoglPixelFormat, rowstride: c_int, data: *const u8) -> *mut CoglTexture;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_texture_new_from_file(filename: *const c_char, flags: CoglTextureFlags, internal_format: CoglPixelFormat, error: *mut *mut glib::GError) -> *mut CoglTexture;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_texture_new_with_size(width: c_uint, height: c_uint, flags: CoglTextureFlags, internal_format: CoglPixelFormat) -> *mut CoglTexture;
    pub fn cogl_texture_allocate(texture: *mut CoglTexture, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn cogl_texture_get_components(texture: *mut CoglTexture) -> CoglTextureComponents;
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    pub fn cogl_texture_get_data(texture: *mut CoglTexture, format: CoglPixelFormat, rowstride: c_uint, data: *mut u8) -> c_int;
    pub fn cogl_texture_get_gl_texture(texture: *mut CoglTexture, out_gl_handle: *mut c_uint, out_gl_target: *mut c_uint) -> gboolean;
    pub fn cogl_texture_get_height(texture: *mut CoglTexture) -> c_uint;
    pub fn cogl_texture_get_max_waste(texture: *mut CoglTexture) -> c_int;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn cogl_texture_get_premultiplied(texture: *mut CoglTexture) -> gboolean;
    pub fn cogl_texture_get_width(texture: *mut CoglTexture) -> c_uint;
    pub fn cogl_texture_is_get_data_supported(texture: *mut CoglTexture) -> gboolean;
    pub fn cogl_texture_is_sliced(texture: *mut CoglTexture) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    pub fn cogl_texture_new_from_sub_texture(full_texture: *mut CoglTexture, sub_x: c_int, sub_y: c_int, sub_width: c_int, sub_height: c_int) -> *mut CoglTexture;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn cogl_texture_set_components(texture: *mut CoglTexture, components: CoglTextureComponents);
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    pub fn cogl_texture_set_data(texture: *mut CoglTexture, format: CoglPixelFormat, rowstride: c_int, data: *const u8, level: c_int, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn cogl_texture_set_premultiplied(texture: *mut CoglTexture, premultiplied: gboolean);
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    pub fn cogl_texture_set_region(texture: *mut CoglTexture, src_x: c_int, src_y: c_int, dst_x: c_int, dst_y: c_int, dst_width: c_uint, dst_height: c_uint, width: c_int, height: c_int, format: CoglPixelFormat, rowstride: c_uint, data: *const u8) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_texture_set_region_from_bitmap(texture: *mut CoglTexture, src_x: c_int, src_y: c_int, dst_x: c_int, dst_y: c_int, dst_width: c_uint, dst_height: c_uint, bitmap: *mut CoglBitmap) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn cogl_blend_string_error_quark() -> u32;
    pub fn cogl_blit_framebuffer(framebuffer: *mut CoglFramebuffer, dst: *mut CoglFramebuffer, src_x: c_int, src_y: c_int, dst_x: c_int, dst_y: c_int, width: c_int, height: c_int, error: *mut *mut glib::GError) -> gboolean;
    pub fn cogl_clutter_winsys_has_feature_CLUTTER(feature: CoglWinsysFeature) -> gboolean;
    pub fn cogl_create_program() -> CoglHandle;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_create_shader(shader_type: CoglShaderType) -> CoglHandle;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_debug_object_foreach_type(func: CoglDebugObjectForeachTypeCallback, user_data: *mut c_void);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    pub fn cogl_debug_object_print_instances();
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_flush();
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_foreach_feature(context: *mut CoglContext, callback: CoglFeatureCallback, user_data: *mut c_void);
    pub fn cogl_get_backface_culling_enabled() -> gboolean;
    pub fn cogl_get_depth_test_enabled() -> gboolean;
    pub fn cogl_get_graphics_reset_status(context: *mut CoglContext) -> CoglGraphicsResetStatus;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_get_option_group() -> *mut glib::GOptionGroup;
    pub fn cogl_get_proc_address(name: *const c_char) -> gobject::GCallback;
    pub fn cogl_handle_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_has_feature(context: *mut CoglContext, feature: CoglFeatureID) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_has_features(context: *mut CoglContext, ...) -> gboolean;
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_is_bitmap(object: *mut c_void) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_is_context(object: *mut c_void) -> gboolean;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_is_frame_info(object: *mut c_void) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_is_framebuffer(object: *mut c_void) -> gboolean;
    #[cfg(any(feature = "v2_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_0")))]
    pub fn cogl_is_pipeline(object: *mut c_void) -> gboolean;
    pub fn cogl_is_program(handle: CoglHandle) -> gboolean;
    pub fn cogl_is_shader(handle: CoglHandle) -> gboolean;
    pub fn cogl_is_texture(object: *mut c_void) -> gboolean;
    pub fn cogl_is_texture_2d(object: *mut c_void) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn cogl_is_texture_2d_sliced(object: *mut c_void) -> gboolean;
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    pub fn cogl_pixel_format_get_bytes_per_pixel(format: CoglPixelFormat, plane: c_int) -> c_int;
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    pub fn cogl_pixel_format_get_n_planes(format: CoglPixelFormat) -> c_int;
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    pub fn cogl_pixel_format_to_string(format: CoglPixelFormat) -> *const c_char;
    pub fn cogl_program_attach_shader(program_handle: CoglHandle, shader_handle: CoglHandle);
    pub fn cogl_program_get_uniform_location(handle: CoglHandle, uniform_name: *const c_char) -> c_int;
    pub fn cogl_program_link(handle: CoglHandle);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_program_set_uniform_1f(program: CoglHandle, uniform_location: c_int, value: c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_program_set_uniform_1i(program: CoglHandle, uniform_location: c_int, value: c_int);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_program_set_uniform_float(program: CoglHandle, uniform_location: c_int, n_components: c_int, count: c_int, value: *const c_float);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_program_set_uniform_int(program: CoglHandle, uniform_location: c_int, n_components: c_int, count: c_int, value: *const c_int);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    pub fn cogl_program_set_uniform_matrix(program: CoglHandle, uniform_location: c_int, dimensions: c_int, count: c_int, transpose: gboolean, value: *const c_float);
    pub fn cogl_set_backface_culling_enabled(setting: gboolean);
    pub fn cogl_set_depth_test_enabled(setting: gboolean);
    pub fn cogl_set_tracing_disabled_on_thread(main_context: *mut glib::GMainContext);
    pub fn cogl_set_tracing_enabled_on_thread(main_context: *mut glib::GMainContext, group: *const c_char, filename: *const c_char);
    pub fn cogl_set_tracing_enabled_on_thread_with_fd(main_context: *mut glib::GMainContext, group: *const c_char, fd: c_int);
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    pub fn cogl_shader_get_type(handle: CoglHandle) -> CoglShaderType;
    pub fn cogl_shader_source(shader: CoglHandle, source: *const c_char);
    pub fn cogl_trace_end(head: *mut CoglTraceHead);

}
