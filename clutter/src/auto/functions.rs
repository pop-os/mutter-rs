// Generated by gir (https://github.com/gtk-rs/gir @ 5bbf6cb)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

use glib::translate::*;
#[cfg(any(feature = "v0_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
use std::boxed::Box as Box_;


//#[doc(alias = "clutter_add_debug_flags")]
//pub fn add_debug_flags(debug_flags: /*Ignored*/DebugFlag, draw_flags: /*Ignored*/DrawDebugFlag, pick_flags: /*Ignored*/PickDebugFlag) {
//    unsafe { TODO: call ffi:clutter_add_debug_flags() }
//}

#[doc(alias = "clutter_base_init")]
pub fn base_init() {
    unsafe {
        ffi::clutter_base_init();
    }
}

//#[cfg(any(feature = "v1_12", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
//#[doc(alias = "clutter_cairo_clear")]
//pub fn cairo_clear(cr: /*Ignored*/&mut cairo::Context) {
//    unsafe { TODO: call ffi:clutter_cairo_clear() }
//}

//#[cfg(any(feature = "v1_0", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
//#[doc(alias = "clutter_cairo_set_source_color")]
//pub fn cairo_set_source_color(cr: /*Ignored*/&mut cairo::Context, color: &Color) {
//    unsafe { TODO: call ffi:clutter_cairo_set_source_color() }
//}

/// Disable loading the accessibility support. It has the same effect
/// as setting the environment variable
/// CLUTTER_DISABLE_ACCESSIBILITY. For the same reason, this method
/// should be called before `clutter_init()`.
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(alias = "clutter_disable_accessibility")]
pub fn disable_accessibility() {
    unsafe {
        ffi::clutter_disable_accessibility();
    }
}

//#[cfg(any(feature = "v0_4", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
//#[doc(alias = "clutter_do_event")]
//pub fn do_event(event: /*Ignored*/&mut Event) {
//    unsafe { TODO: call ffi:clutter_do_event() }
//}

/// Checks if events are pending in the event queue.
///
/// # Returns
///
/// TRUE if there are pending events, FALSE otherwise.
#[cfg(any(feature = "v0_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
#[doc(alias = "clutter_events_pending")]
pub fn events_pending() -> bool {
    unsafe {
        from_glib(ffi::clutter_events_pending())
    }
}

//#[cfg(any(feature = "v0_4", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
//#[doc(alias = "clutter_feature_available")]
//pub fn feature_available(feature: /*Ignored*/FeatureFlags) -> bool {
//    unsafe { TODO: call ffi:clutter_feature_available() }
//}

//#[cfg(any(feature = "v0_4", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
//#[doc(alias = "clutter_feature_get_all")]
//pub fn feature_get_all() -> /*Ignored*/FeatureFlags {
//    unsafe { TODO: call ffi:clutter_feature_get_all() }
//}

/// Returns whether Clutter has accessibility support enabled. As
/// least, a value of TRUE means that there are a proper AtkUtil
/// implementation available
///
/// # Returns
///
/// [`true`] if Clutter has accessibility support enabled
#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
#[doc(alias = "clutter_get_accessibility_enabled")]
#[doc(alias = "get_accessibility_enabled")]
pub fn is_accessibility_enabled() -> bool {
    unsafe {
        from_glib(ffi::clutter_get_accessibility_enabled())
    }
}

//#[cfg(any(feature = "v1_2", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
//#[doc(alias = "clutter_get_current_event")]
//#[doc(alias = "get_current_event")]
//pub fn current_event() -> /*Ignored*/Option<Event> {
//    unsafe { TODO: call ffi:clutter_get_current_event() }
//}

/// Retrieves the timestamp of the last event, if there is an
/// event or if the event has a timestamp.
///
/// # Returns
///
/// the event timestamp, or `CLUTTER_CURRENT_TIME`
#[cfg(any(feature = "v1_0", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
#[doc(alias = "clutter_get_current_event_time")]
#[doc(alias = "get_current_event_time")]
pub fn current_event_time() -> u32 {
    unsafe {
        ffi::clutter_get_current_event_time()
    }
}

//#[cfg(any(feature = "v0_4", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
//#[doc(alias = "clutter_get_default_backend")]
//#[doc(alias = "get_default_backend")]
//pub fn default_backend() -> /*Ignored*/Option<Backend> {
//    unsafe { TODO: call ffi:clutter_get_default_backend() }
//}

/// Retrieves the default frame rate. See `clutter_set_default_frame_rate()`.
///
/// # Returns
///
/// the default frame rate
#[cfg(any(feature = "v0_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
#[doc(alias = "clutter_get_default_frame_rate")]
#[doc(alias = "get_default_frame_rate")]
pub fn default_frame_rate() -> u32 {
    unsafe {
        ffi::clutter_get_default_frame_rate()
    }
}

//#[cfg(any(feature = "v1_2", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
//#[doc(alias = "clutter_get_default_text_direction")]
//#[doc(alias = "get_default_text_direction")]
//pub fn default_text_direction() -> /*Ignored*/TextDirection {
//    unsafe { TODO: call ffi:clutter_get_default_text_direction() }
//}

//#[cfg(any(feature = "v1_0", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
//#[doc(alias = "clutter_get_font_map")]
//#[doc(alias = "get_font_map")]
//pub fn font_map() -> /*Ignored*/Option<pango::FontMap> {
//    unsafe { TODO: call ffi:clutter_get_font_map() }
//}

//#[cfg(any(feature = "v0_2", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
//#[doc(alias = "clutter_get_option_group")]
//#[doc(alias = "get_option_group")]
//pub fn option_group() -> /*Ignored*/Option<glib::OptionGroup> {
//    unsafe { TODO: call ffi:clutter_get_option_group() }
//}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_get_option_group_without_init")]
//#[doc(alias = "get_option_group_without_init")]
//pub fn option_group_without_init() -> /*Ignored*/Option<glib::OptionGroup> {
//    unsafe { TODO: call ffi:clutter_get_option_group_without_init() }
//}

//#[cfg(any(feature = "v0_6", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
//#[doc(alias = "clutter_get_script_id")]
//#[doc(alias = "get_script_id")]
//pub fn script_id(gobject: /*Ignored*/&glib::Object) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:clutter_get_script_id() }
//}

//#[cfg(any(feature = "v0_2", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
//#[doc(alias = "clutter_init_with_args")]
//pub fn init_with_args(argv: /*Unimplemented*/Vec<glib::GString>, parameter_string: Option<&str>, entries: /*Ignored*/&[&glib::OptionEntry], translation_domain: Option<&str>) -> Result</*Ignored*/InitError, glib::Error> {
//    unsafe { TODO: call ffi:clutter_init_with_args() }
//}

/// Converts `keyval` from a Clutter key symbol to the corresponding
/// ISO10646 (Unicode) character.
/// ## `keyval`
/// a key symbol
///
/// # Returns
///
/// a Unicode character, or 0 if there is no corresponding
///  character.
#[doc(alias = "clutter_keysym_to_unicode")]
pub fn keysym_to_unicode(keyval: u32) -> u32 {
    unsafe {
        ffi::clutter_keysym_to_unicode(keyval)
    }
}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_param_spec_color")]
//pub fn param_spec_color(name: &str, nick: &str, blurb: &str, default_value: &Color, flags: /*Ignored*/glib::ParamFlags) -> /*Ignored*/Option<glib::ParamSpec> {
//    unsafe { TODO: call ffi:clutter_param_spec_color() }
//}

//#[cfg(any(feature = "v1_0", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
//#[doc(alias = "clutter_param_spec_units")]
//pub fn param_spec_units(name: &str, nick: &str, blurb: &str, default_type: /*Ignored*/UnitType, minimum: f32, maximum: f32, default_value: f32, flags: /*Ignored*/glib::ParamFlags) -> /*Ignored*/Option<glib::ParamSpec> {
//    unsafe { TODO: call ffi:clutter_param_spec_units() }
//}

//#[doc(alias = "clutter_remove_debug_flags")]
//pub fn remove_debug_flags(debug_flags: /*Ignored*/DebugFlag, draw_flags: /*Ignored*/DrawDebugFlag, pick_flags: /*Ignored*/PickDebugFlag) {
//    unsafe { TODO: call ffi:clutter_remove_debug_flags() }
//}

//#[doc(alias = "clutter_set_custom_backend_func")]
//pub fn set_custom_backend_func(func: /*Unimplemented*/Option<Fundamental: Pointer>) {
//    unsafe { TODO: call ffi:clutter_set_custom_backend_func() }
//}

/// Simple wrapper around [`threads_add_idle_full()`][crate::threads_add_idle_full()] using the
/// default priority.
/// ## `func`
/// function to call
///
/// # Returns
///
/// the ID (greater than 0) of the event source.
#[cfg(any(feature = "v0_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
#[doc(alias = "clutter_threads_add_idle")]
pub fn threads_add_idle<P: Fn() -> bool + Send + Sync + 'static>(func: P) -> u32 {
    let func_data: Box_<P> = Box_::new(func);
    unsafe extern "C" fn func_func<P: Fn() -> bool + Send + Sync + 'static>(user_data: glib::ffi::gpointer) -> glib::ffi::gboolean {
        let callback: &P = &*(user_data as *mut _);
        let res = (*callback)();
        res.into_glib()
    }
    let func = Some(func_func::<P> as _);
    let super_callback0: Box_<P> = func_data;
    unsafe {
        ffi::clutter_threads_add_idle(func, Box_::into_raw(super_callback0) as *mut _)
    }
}

/// Adds a function to be called whenever there are no higher priority
/// events pending. If the function returns [`false`] it is automatically
/// removed from the list of event sources and will not be called again.
///
/// This function can be considered a thread-safe variant of `g_idle_add_full()`:
/// it will call `function` while holding the Clutter lock. It is logically
/// equivalent to the following implementation:
///
///
/// ```text
/// static gboolean
/// idle_safe_callback (gpointer data)
/// {
///    SafeClosure *closure = data;
///    gboolean res = FALSE;
///
///    // the callback does not need to acquire the Clutter
///     / lock itself, as it is held by the this proxy handler
///     //
///    res = closure->callback (closure->data);
///
///    return res;
/// }
/// static gulong
/// add_safe_idle (GSourceFunc callback,
///                gpointer    data)
/// {
///   SafeClosure *closure = g_new0 (SafeClosure, 1);
///
///   closure->callback = callback;
///   closure->data = data;
///
///   return g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,
///                           idle_safe_callback,
///                           closure,
///                           g_free)
/// }
/// ```
///
/// This function should be used by threaded applications to make sure
/// that `func` is emitted under the Clutter threads lock and invoked
/// from the same thread that started the Clutter main loop. For instance,
/// it can be used to update the UI using the results from a worker
/// thread:
///
///
/// ```text
/// static gboolean
/// update_ui (gpointer data)
/// {
///   SomeClosure *closure = data;
///
///   // it is safe to call Clutter API from this function because
///    / it is invoked from the same thread that started the main
///    / loop and under the Clutter thread lock
///    //
///   clutter_label_set_text (CLUTTER_LABEL (closure->label),
///                           closure->text);
///
///   g_object_unref (closure->label);
///   g_free (closure);
///
///   return FALSE;
/// }
///
///   // within another thread //
///   closure = g_new0 (SomeClosure, 1);
///   // always take a reference on GObject instances //
///   closure->label = g_object_ref (my_application->label);
///   closure->text = g_strdup (processed_text_to_update_the_label);
///
///   clutter_threads_add_idle_full (G_PRIORITY_HIGH_IDLE,
///                                  update_ui,
///                                  closure,
///                                  NULL);
/// ```
/// ## `priority`
/// the priority of the timeout source. Typically this will be in the
///  range between `G_PRIORITY_DEFAULT_IDLE` and `G_PRIORITY_HIGH_IDLE`
/// ## `func`
/// function to call
/// ## `notify`
/// functio to call when the idle source is removed
///
/// # Returns
///
/// the ID (greater than 0) of the event source.
#[cfg(any(feature = "v0_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
#[doc(alias = "clutter_threads_add_idle_full")]
pub fn threads_add_idle_full<P: Fn() -> bool + Send + Sync + 'static>(priority: i32, func: P) -> u32 {
    let func_data: Box_<P> = Box_::new(func);
    unsafe extern "C" fn func_func<P: Fn() -> bool + Send + Sync + 'static>(user_data: glib::ffi::gpointer) -> glib::ffi::gboolean {
        let callback: &P = &*(user_data as *mut _);
        let res = (*callback)();
        res.into_glib()
    }
    let func = Some(func_func::<P> as _);
    unsafe extern "C" fn notify_func<P: Fn() -> bool + Send + Sync + 'static>(data: glib::ffi::gpointer) {
        let _callback: Box_<P> = Box_::from_raw(data as *mut _);
    }
    let destroy_call3 = Some(notify_func::<P> as _);
    let super_callback0: Box_<P> = func_data;
    unsafe {
        ffi::clutter_threads_add_idle_full(priority, func, Box_::into_raw(super_callback0) as *mut _, destroy_call3)
    }
}

/// Adds a function to be called whenever Clutter is processing a new
/// frame.
///
/// If the function returns [`false`] it is automatically removed from the
/// list of repaint functions and will not be called again.
///
/// This function is guaranteed to be called from within the same thread
/// that called `clutter_main()`, and while the Clutter lock is being held;
/// the function will be called within the main loop, so it is imperative
/// that it does not block, otherwise the frame time budget may be lost.
///
/// A repaint function is useful to ensure that an update of the scenegraph
/// is performed before the scenegraph is repainted. By default, a repaint
/// function added using this function will be invoked prior to the frame
/// being processed.
///
/// Adding a repaint function does not automatically ensure that a new
/// frame will be queued.
///
/// When the repaint function is removed (either because it returned [`false`]
/// or because [`threads_remove_repaint_func()`][crate::threads_remove_repaint_func()] has been called) the
/// `notify` function will be called, if any is set.
///
/// See also: `clutter_threads_add_repaint_func_full()`
/// ## `func`
/// the function to be called within the paint cycle
/// ## `notify`
/// function to be called when removing the repaint
///  function, or [`None`]
///
/// # Returns
///
/// the ID (greater than 0) of the repaint function. You
///  can use the returned integer to remove the repaint function by
///  calling [`threads_remove_repaint_func()`][crate::threads_remove_repaint_func()].
#[cfg(any(feature = "v1_0", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
#[doc(alias = "clutter_threads_add_repaint_func")]
pub fn threads_add_repaint_func<P: Fn() -> bool + Send + Sync + 'static>(func: P) -> u32 {
    let func_data: Box_<P> = Box_::new(func);
    unsafe extern "C" fn func_func<P: Fn() -> bool + Send + Sync + 'static>(user_data: glib::ffi::gpointer) -> glib::ffi::gboolean {
        let callback: &P = &*(user_data as *mut _);
        let res = (*callback)();
        res.into_glib()
    }
    let func = Some(func_func::<P> as _);
    unsafe extern "C" fn notify_func<P: Fn() -> bool + Send + Sync + 'static>(data: glib::ffi::gpointer) {
        let _callback: Box_<P> = Box_::from_raw(data as *mut _);
    }
    let destroy_call2 = Some(notify_func::<P> as _);
    let super_callback0: Box_<P> = func_data;
    unsafe {
        ffi::clutter_threads_add_repaint_func(func, Box_::into_raw(super_callback0) as *mut _, destroy_call2)
    }
}

//#[cfg(any(feature = "v1_10", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
//#[doc(alias = "clutter_threads_add_repaint_func_full")]
//pub fn threads_add_repaint_func_full<P: Fn() -> bool + Send + Sync + 'static>(flags: /*Ignored*/RepaintFlags, func: P) -> u32 {
//    unsafe { TODO: call ffi:clutter_threads_add_repaint_func_full() }
//}

/// Simple wrapper around [`threads_add_timeout_full()`][crate::threads_add_timeout_full()].
/// ## `interval`
/// the time between calls to the function, in milliseconds
/// ## `func`
/// function to call
///
/// # Returns
///
/// the ID (greater than 0) of the event source.
#[cfg(any(feature = "v0_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
#[doc(alias = "clutter_threads_add_timeout")]
pub fn threads_add_timeout<P: Fn() -> bool + Send + Sync + 'static>(interval: u32, func: P) -> u32 {
    let func_data: Box_<P> = Box_::new(func);
    unsafe extern "C" fn func_func<P: Fn() -> bool + Send + Sync + 'static>(user_data: glib::ffi::gpointer) -> glib::ffi::gboolean {
        let callback: &P = &*(user_data as *mut _);
        let res = (*callback)();
        res.into_glib()
    }
    let func = Some(func_func::<P> as _);
    let super_callback0: Box_<P> = func_data;
    unsafe {
        ffi::clutter_threads_add_timeout(interval, func, Box_::into_raw(super_callback0) as *mut _)
    }
}

/// Sets a function to be called at regular intervals holding the Clutter
/// threads lock, with the given priority. The function is called repeatedly
/// until it returns [`false`], at which point the timeout is automatically
/// removed and the function will not be called again. The `notify` function
/// is called when the timeout is removed.
///
/// The first call to the function will be at the end of the first `interval`.
///
/// It is important to note that, due to how the Clutter main loop is
/// implemented, the timing will not be accurate and it will not try to
/// "keep up" with the interval.
///
/// See also [`threads_add_idle_full()`][crate::threads_add_idle_full()].
/// ## `priority`
/// the priority of the timeout source. Typically this will be in the
///  range between `G_PRIORITY_DEFAULT` and `G_PRIORITY_HIGH`.
/// ## `interval`
/// the time between calls to the function, in milliseconds
/// ## `func`
/// function to call
/// ## `notify`
/// function to call when the timeout source is removed
///
/// # Returns
///
/// the ID (greater than 0) of the event source.
#[cfg(any(feature = "v0_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
#[doc(alias = "clutter_threads_add_timeout_full")]
pub fn threads_add_timeout_full<P: Fn() -> bool + Send + Sync + 'static>(priority: i32, interval: u32, func: P) -> u32 {
    let func_data: Box_<P> = Box_::new(func);
    unsafe extern "C" fn func_func<P: Fn() -> bool + Send + Sync + 'static>(user_data: glib::ffi::gpointer) -> glib::ffi::gboolean {
        let callback: &P = &*(user_data as *mut _);
        let res = (*callback)();
        res.into_glib()
    }
    let func = Some(func_func::<P> as _);
    unsafe extern "C" fn notify_func<P: Fn() -> bool + Send + Sync + 'static>(data: glib::ffi::gpointer) {
        let _callback: Box_<P> = Box_::from_raw(data as *mut _);
    }
    let destroy_call4 = Some(notify_func::<P> as _);
    let super_callback0: Box_<P> = func_data;
    unsafe {
        ffi::clutter_threads_add_timeout_full(priority, interval, func, Box_::into_raw(super_callback0) as *mut _, destroy_call4)
    }
}

/// Removes the repaint function with `handle_id` as its id
/// ## `handle_id`
/// an unsigned integer greater than zero
#[cfg(any(feature = "v1_0", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
#[doc(alias = "clutter_threads_remove_repaint_func")]
pub fn threads_remove_repaint_func(handle_id: u32) {
    unsafe {
        ffi::clutter_threads_remove_repaint_func(handle_id);
    }
}

/// Convert from a ISO10646 character to a key symbol.
/// ## `wc`
/// a ISO10646 encoded character
///
/// # Returns
///
/// the corresponding Clutter key symbol, if one exists.
///  or, if there is no corresponding symbol, wc | 0x01000000
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
#[doc(alias = "clutter_unicode_to_keysym")]
pub fn unicode_to_keysym(wc: u32) -> u32 {
    unsafe {
        ffi::clutter_unicode_to_keysym(wc)
    }
}

//#[cfg(any(feature = "v1_10", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
//#[doc(alias = "clutter_value_dup_paint_node")]
//pub fn value_dup_paint_node(value: /*Ignored*/&glib::Value) -> /*Ignored*/Option<PaintNode> {
//    unsafe { TODO: call ffi:clutter_value_dup_paint_node() }
//}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_value_get_color")]
//pub fn value_get_color(value: /*Ignored*/&glib::Value) -> Option<Color> {
//    unsafe { TODO: call ffi:clutter_value_get_color() }
//}

//#[cfg(any(feature = "v1_10", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
//#[doc(alias = "clutter_value_get_paint_node")]
//pub fn value_get_paint_node(value: /*Ignored*/&glib::Value) -> /*Ignored*/Option<PaintNode> {
//    unsafe { TODO: call ffi:clutter_value_get_paint_node() }
//}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_value_get_shader_float")]
//pub fn value_get_shader_float(value: /*Ignored*/&glib::Value) -> Vec<f32> {
//    unsafe { TODO: call ffi:clutter_value_get_shader_float() }
//}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_value_get_shader_int")]
//pub fn value_get_shader_int(value: /*Ignored*/&glib::Value) -> Vec<i32> {
//    unsafe { TODO: call ffi:clutter_value_get_shader_int() }
//}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_value_get_shader_matrix")]
//pub fn value_get_shader_matrix(value: /*Ignored*/&glib::Value) -> Vec<f32> {
//    unsafe { TODO: call ffi:clutter_value_get_shader_matrix() }
//}

//#[cfg(any(feature = "v1_0", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
//#[doc(alias = "clutter_value_get_units")]
//pub fn value_get_units(value: /*Ignored*/&glib::Value) -> /*Ignored*/Option<Units> {
//    unsafe { TODO: call ffi:clutter_value_get_units() }
//}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_value_set_color")]
//pub fn value_set_color(value: /*Ignored*/&mut glib::Value, color: &Color) {
//    unsafe { TODO: call ffi:clutter_value_set_color() }
//}

//#[cfg(any(feature = "v1_10", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
//#[doc(alias = "clutter_value_set_paint_node")]
//pub fn value_set_paint_node(value: /*Ignored*/&mut glib::Value, node: /*Ignored*/Option<&PaintNode>) {
//    unsafe { TODO: call ffi:clutter_value_set_paint_node() }
//}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_value_set_shader_float")]
//pub fn value_set_shader_float(value: /*Ignored*/&mut glib::Value, floats: &[f32]) {
//    unsafe { TODO: call ffi:clutter_value_set_shader_float() }
//}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_value_set_shader_int")]
//pub fn value_set_shader_int(value: /*Ignored*/&mut glib::Value, ints: &[i32]) {
//    unsafe { TODO: call ffi:clutter_value_set_shader_int() }
//}

//#[cfg(any(feature = "v0_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
//#[doc(alias = "clutter_value_set_shader_matrix")]
//pub fn value_set_shader_matrix(value: /*Ignored*/&mut glib::Value, matrix: &[f32]) {
//    unsafe { TODO: call ffi:clutter_value_set_shader_matrix() }
//}

//#[cfg(any(feature = "v1_0", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
//#[doc(alias = "clutter_value_set_units")]
//pub fn value_set_units(value: /*Ignored*/&mut glib::Value, units: /*Ignored*/&Units) {
//    unsafe { TODO: call ffi:clutter_value_set_units() }
//}

//#[cfg(any(feature = "v1_10", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
//#[doc(alias = "clutter_value_take_paint_node")]
//pub fn value_take_paint_node(value: /*Ignored*/&mut glib::Value, node: /*Ignored*/Option<&PaintNode>) {
//    unsafe { TODO: call ffi:clutter_value_take_paint_node() }
//}
