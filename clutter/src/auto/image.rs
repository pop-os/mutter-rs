// Generated by gir (https://github.com/gtk-rs/gir @ 45cd7bc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

use crate::Content;
use glib::object::IsA;
use glib::translate::*;
use std::fmt;
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
use std::ptr;

glib::wrapper! {
    #[doc(alias = "ClutterImage")]
    pub struct Image(Object<ffi::ClutterImage, ffi::ClutterImageClass>) @implements Content;

    match fn {
        type_ => || ffi::clutter_image_get_type(),
    }
}

impl Image {
    /// Creates a new [`Image`][crate::Image] instance.
    ///
    /// # Returns
    ///
    /// the newly created [`Image`][crate::Image] instance.
    ///  Use `g_object_unref()` when done.
    #[doc(alias = "clutter_image_new")]
    pub fn new() -> Option<Content> {
        unsafe {
            from_glib_full(ffi::clutter_image_new())
        }
    }
}

pub const NONE_IMAGE: Option<&Image> = None;

/// Trait containing all [`struct@Image`] methods.
///
/// # Implementors
///
/// [`Image`][struct@crate::Image]
pub trait ImageExt: 'static {
    /// Retrieves a pointer to the Cogl texture used by `self`.
    ///
    /// If you change the contents of the returned Cogl texture you will need
    /// to manually invalidate the `self` with [`ContentExt::invalidate()`][crate::prelude::ContentExt::invalidate()]
    /// in order to update the actors using `self` as their content.
    ///
    /// # Returns
    ///
    /// a pointer to the Cogl texture, or [`None`]
    #[doc(alias = "clutter_image_get_texture")]
    #[doc(alias = "get_texture")]
    fn texture(&self) -> Option<cogl::Texture>;

    //#[doc(alias = "clutter_image_set_area")]
    //fn set_area(&self, data: &[u8], pixel_format: cogl::PixelFormat, rect: &cairo::RectangleInt, row_stride: u32) -> Result<(), glib::Error>;

    /// Sets the image data stored inside a [`glib::Bytes`][crate::glib::Bytes] to be displayed by `self`.
    ///
    /// If the image data was successfully loaded, the `self` will be invalidated.
    ///
    /// In case of error, the `error` value will be set, and this function will
    /// return [`false`].
    ///
    /// The image data contained inside the [`glib::Bytes`][crate::glib::Bytes] is copied in texture memory,
    /// and no additional reference is acquired on the `data`.
    /// ## `data`
    /// the image data, as a [`glib::Bytes`][crate::glib::Bytes]
    /// ## `pixel_format`
    /// the Cogl pixel format of the image data
    /// ## `width`
    /// the width of the image data
    /// ## `height`
    /// the height of the image data
    /// ## `row_stride`
    /// the length of each row inside `data`
    ///
    /// # Returns
    ///
    /// [`true`] if the image data was successfully loaded,
    ///  and [`false`] otherwise.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_image_set_bytes")]
    fn set_bytes(&self, data: &glib::Bytes, pixel_format: cogl::PixelFormat, width: u32, height: u32, row_stride: u32) -> Result<(), glib::Error>;

    //#[doc(alias = "clutter_image_set_data")]
    //fn set_data(&self, data: &[u8], pixel_format: cogl::PixelFormat, width: u32, height: u32, row_stride: u32) -> Result<(), glib::Error>;
}

impl<O: IsA<Image>> ImageExt for O {
    fn texture(&self) -> Option<cogl::Texture> {
        unsafe {
            from_glib_none(ffi::clutter_image_get_texture(self.as_ref().to_glib_none().0))
        }
    }

    //fn set_area(&self, data: &[u8], pixel_format: cogl::PixelFormat, rect: &cairo::RectangleInt, row_stride: u32) -> Result<(), glib::Error> {
    //    unsafe { TODO: call ffi:clutter_image_set_area() }
    //}

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_bytes(&self, data: &glib::Bytes, pixel_format: cogl::PixelFormat, width: u32, height: u32, row_stride: u32) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ffi::clutter_image_set_bytes(self.as_ref().to_glib_none().0, data.to_glib_none().0, pixel_format.into_glib(), width, height, row_stride, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    //fn set_data(&self, data: &[u8], pixel_format: cogl::PixelFormat, width: u32, height: u32, row_stride: u32) -> Result<(), glib::Error> {
    //    unsafe { TODO: call ffi:clutter_image_set_data() }
    //}
}

impl fmt::Display for Image {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Image")
    }
}
