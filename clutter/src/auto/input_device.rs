// Generated by gir (https://github.com/gtk-rs/gir @ 5bbf6cb)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use crate::Actor;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use glib::object::IsA;
use glib::object::ObjectType as ObjectType_;
use glib::translate::*;
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
use glib::StaticType;
use std::fmt;

glib::wrapper! {
    #[doc(alias = "ClutterInputDevice")]
    pub struct InputDevice(Object<ffi::ClutterInputDevice, ffi::ClutterInputDeviceClass>);

    match fn {
        type_ => || ffi::clutter_input_device_get_type(),
    }
}

impl InputDevice {
    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //#[doc(alias = "clutter_input_device_get_axis")]
    //#[doc(alias = "get_axis")]
    //pub fn axis(&self, index_: u32) -> /*Ignored*/InputAxis {
    //    unsafe { TODO: call ffi:clutter_input_device_get_axis() }
    //}

    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //#[doc(alias = "clutter_input_device_get_axis_value")]
    //#[doc(alias = "get_axis_value")]
    //pub fn is_axis_value(&self, axes: f64, axis: /*Ignored*/InputAxis, value: f64) -> bool {
    //    unsafe { TODO: call ffi:clutter_input_device_get_axis_value() }
    //}

    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //#[doc(alias = "clutter_input_device_get_device_mode")]
    //#[doc(alias = "get_device_mode")]
    //pub fn device_mode(&self) -> /*Ignored*/InputMode {
    //    unsafe { TODO: call ffi:clutter_input_device_get_device_mode() }
    //}

    /// Retrieves the name of the `self`
    ///
    /// # Returns
    ///
    /// the name of the device, or [`None`]. The returned string
    ///  is owned by the [`InputDevice`][crate::InputDevice] and should never be modified
    ///  or freed
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "clutter_input_device_get_device_name")]
    #[doc(alias = "get_device_name")]
    pub fn device_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::clutter_input_device_get_device_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "clutter_input_device_get_device_node")]
    #[doc(alias = "get_device_node")]
    pub fn device_node(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::clutter_input_device_get_device_node(self.to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v1_0", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    //#[doc(alias = "clutter_input_device_get_device_type")]
    //#[doc(alias = "get_device_type")]
    //pub fn device_type(&self) -> /*Ignored*/InputDeviceType {
    //    unsafe { TODO: call ffi:clutter_input_device_get_device_type() }
    //}

    /// Retrieves a pointer to the [`Actor`][crate::Actor] currently grabbing all
    /// the events coming from `self`.
    ///
    /// # Returns
    ///
    /// a [`Actor`][crate::Actor], or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_input_device_get_grabbed_actor")]
    #[doc(alias = "get_grabbed_actor")]
    pub fn grabbed_actor(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_input_device_get_grabbed_actor(self.to_glib_none().0))
        }
    }

    #[doc(alias = "clutter_input_device_get_group_n_modes")]
    #[doc(alias = "get_group_n_modes")]
    pub fn group_n_modes(&self, group: i32) -> i32 {
        unsafe {
            ffi::clutter_input_device_get_group_n_modes(self.to_glib_none().0, group)
        }
    }

    /// Retrieves whether `self` has a pointer that follows the
    /// device motion.
    ///
    /// # Returns
    ///
    /// [`true`] if the device has a cursor
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    #[doc(alias = "clutter_input_device_get_has_cursor")]
    #[doc(alias = "get_has_cursor")]
    pub fn has_cursor(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_input_device_get_has_cursor(self.to_glib_none().0))
        }
    }

    #[doc(alias = "clutter_input_device_get_mode_switch_button_group")]
    #[doc(alias = "get_mode_switch_button_group")]
    pub fn mode_switch_button_group(&self, button: u32) -> i32 {
        unsafe {
            ffi::clutter_input_device_get_mode_switch_button_group(self.to_glib_none().0, button)
        }
    }

    #[doc(alias = "clutter_input_device_get_n_axes")]
    #[doc(alias = "get_n_axes")]
    pub fn n_axes(&self) -> u32 {
        unsafe {
            ffi::clutter_input_device_get_n_axes(self.to_glib_none().0)
        }
    }

    #[doc(alias = "clutter_input_device_get_n_buttons")]
    #[doc(alias = "get_n_buttons")]
    pub fn n_buttons(&self) -> i32 {
        unsafe {
            ffi::clutter_input_device_get_n_buttons(self.to_glib_none().0)
        }
    }

    #[doc(alias = "clutter_input_device_get_n_mode_groups")]
    #[doc(alias = "get_n_mode_groups")]
    pub fn n_mode_groups(&self) -> i32 {
        unsafe {
            ffi::clutter_input_device_get_n_mode_groups(self.to_glib_none().0)
        }
    }

    #[doc(alias = "clutter_input_device_get_n_rings")]
    #[doc(alias = "get_n_rings")]
    pub fn n_rings(&self) -> i32 {
        unsafe {
            ffi::clutter_input_device_get_n_rings(self.to_glib_none().0)
        }
    }

    #[doc(alias = "clutter_input_device_get_n_strips")]
    #[doc(alias = "get_n_strips")]
    pub fn n_strips(&self) -> i32 {
        unsafe {
            ffi::clutter_input_device_get_n_strips(self.to_glib_none().0)
        }
    }

    //#[doc(alias = "clutter_input_device_get_pad_feature_group")]
    //#[doc(alias = "get_pad_feature_group")]
    //pub fn pad_feature_group(&self, feature: /*Ignored*/InputDevicePadFeature, n_feature: i32) -> i32 {
    //    unsafe { TODO: call ffi:clutter_input_device_get_pad_feature_group() }
    //}

    /// Gets the product ID of this device.
    ///
    /// # Returns
    ///
    /// the product ID
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    #[doc(alias = "clutter_input_device_get_product_id")]
    #[doc(alias = "get_product_id")]
    pub fn product_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::clutter_input_device_get_product_id(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "clutter_input_device_get_seat")]
    //#[doc(alias = "get_seat")]
    //pub fn seat(&self) -> /*Ignored*/Option<Seat> {
    //    unsafe { TODO: call ffi:clutter_input_device_get_seat() }
    //}

    /// Gets the vendor ID of this device.
    ///
    /// # Returns
    ///
    /// the vendor ID
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    #[doc(alias = "clutter_input_device_get_vendor_id")]
    #[doc(alias = "get_vendor_id")]
    pub fn vendor_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::clutter_input_device_get_vendor_id(self.to_glib_none().0))
        }
    }

    /// Acquires a grab on `actor` for the given `self`.
    ///
    /// Any event coming from `self` will be delivered to `actor`, bypassing
    /// the usual event delivery mechanism, until the grab is released by
    /// calling [`ungrab()`][Self::ungrab()].
    ///
    /// The grab is client-side: even if the windowing system used by the Clutter
    /// backend has the concept of "device grabs", Clutter will not use them.
    ///
    /// Only [`InputDevice`][crate::InputDevice] of types `CLUTTER_POINTER_DEVICE`,
    /// `CLUTTER_TABLET_DEVICE` and `CLUTTER_KEYBOARD_DEVICE` can hold a grab.
    /// ## `actor`
    /// a [`Actor`][crate::Actor]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_input_device_grab")]
    pub fn grab<P: IsA<Actor>>(&self, actor: &P) {
        unsafe {
            ffi::clutter_input_device_grab(self.to_glib_none().0, actor.as_ref().to_glib_none().0);
        }
    }

    #[doc(alias = "clutter_input_device_is_grouped")]
    pub fn is_grouped(&self, other_device: &InputDevice) -> bool {
        unsafe {
            from_glib(ffi::clutter_input_device_is_grouped(self.to_glib_none().0, other_device.to_glib_none().0))
        }
    }

    #[doc(alias = "clutter_input_device_is_mode_switch_button")]
    pub fn is_mode_switch_button(&self, group: u32, button: u32) -> bool {
        unsafe {
            from_glib(ffi::clutter_input_device_is_mode_switch_button(self.to_glib_none().0, group, button))
        }
    }

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_input_device_sequence_get_grabbed_actor")]
    //pub fn sequence_get_grabbed_actor(&self, sequence: /*Ignored*/&mut EventSequence) -> Option<Actor> {
    //    unsafe { TODO: call ffi:clutter_input_device_sequence_get_grabbed_actor() }
    //}

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_input_device_sequence_grab")]
    //pub fn sequence_grab<P: IsA<Actor>>(&self, sequence: /*Ignored*/&mut EventSequence, actor: &P) {
    //    unsafe { TODO: call ffi:clutter_input_device_sequence_grab() }
    //}

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_input_device_sequence_ungrab")]
    //pub fn sequence_ungrab(&self, sequence: /*Ignored*/&mut EventSequence) {
    //    unsafe { TODO: call ffi:clutter_input_device_sequence_ungrab() }
    //}

    /// Releases the grab on the `self`, if one is in place.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_input_device_ungrab")]
    pub fn ungrab(&self) {
        unsafe {
            ffi::clutter_input_device_ungrab(self.to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //pub fn backend(&self) -> /*Ignored*/Option<Backend> {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"backend\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `backend` getter")
    //    }
    //}

    //#[doc(alias = "device-mode")]
    //pub fn get_property_device_mode(&self) -> /*Ignored*/InputMode {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"device-mode\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `device-mode` getter")
    //    }
    //}

    /// The name of the device
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    pub fn name(&self) -> Option<glib::GString> {
        unsafe {
            let mut value = glib::Value::from_type(<glib::GString as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"name\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `name` getter")
        }
    }
}

impl fmt::Display for InputDevice {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("InputDevice")
    }
}
