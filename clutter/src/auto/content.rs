// Generated by gir (https://github.com/gtk-rs/gir @ 45cd7bc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use crate::Actor;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use glib::object::Cast;
use glib::object::IsA;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use glib::signal::connect_raw;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use glib::signal::SignalHandlerId;
use glib::translate::*;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use std::boxed::Box as Box_;
use std::fmt;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use std::mem;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "ClutterContent")]
    pub struct Content(Interface<ffi::ClutterContent, ffi::ClutterContentInterface>);

    match fn {
        type_ => || ffi::clutter_content_get_type(),
    }
}

pub const NONE_CONTENT: Option<&Content> = None;

/// Trait containing all [`struct@Content`] methods.
///
/// # Implementors
///
/// [`Canvas`][struct@crate::Canvas], [`Content`][struct@crate::Content]
pub trait ContentExt: 'static {
    /// Retrieves the natural size of the `self`, if any.
    ///
    /// The natural size of a [`Content`][crate::Content] is defined as the size the content
    /// would have regardless of the allocation of the actor that is painting it,
    /// for instance the size of an image data.
    ///
    /// # Returns
    ///
    /// [`true`] if the content has a preferred size, and [`false`]
    ///  otherwise
    ///
    /// ## `width`
    /// return location for the natural width of the content
    ///
    /// ## `height`
    /// return location for the natural height of the content
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_content_get_preferred_size")]
    #[doc(alias = "get_preferred_size")]
    fn preferred_size(&self) -> Option<(f32, f32)>;

    /// Invalidates a [`Content`][crate::Content].
    ///
    /// This function should be called by [`Content`][crate::Content] implementations when
    /// they change the way a the content should be painted regardless of the
    /// actor state.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_content_invalidate")]
    fn invalidate(&self);

    /// Signals that `self`'s size changed. Attached actors with request mode
    /// set to [`RequestMode::ContentSize`][crate::RequestMode::ContentSize] will have a relayout queued.
    ///
    /// Attached actors with other request modes are not redrawn. To redraw them
    /// too, use [`invalidate()`][Self::invalidate()].
    #[doc(alias = "clutter_content_invalidate_size")]
    fn invalidate_size(&self);

    /// This signal is emitted each time a [`Content`][crate::Content] implementation is
    /// assigned to a [`Actor`][crate::Actor].
    /// ## `actor`
    /// a [`Actor`][crate::Actor]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "attached")]
    fn connect_attached<F: Fn(&Self, &Actor) + 'static>(&self, f: F) -> SignalHandlerId;

    /// This signal is emitted each time a [`Content`][crate::Content] implementation is
    /// removed from a [`Actor`][crate::Actor].
    /// ## `actor`
    /// a [`Actor`][crate::Actor]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "detached")]
    fn connect_detached<F: Fn(&Self, &Actor) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Content>> ContentExt for O {
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn preferred_size(&self) -> Option<(f32, f32)> {
        unsafe {
            let mut width = mem::MaybeUninit::uninit();
            let mut height = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::clutter_content_get_preferred_size(self.as_ref().to_glib_none().0, width.as_mut_ptr(), height.as_mut_ptr()));
            let width = width.assume_init();
            let height = height.assume_init();
            if ret { Some((width, height)) } else { None }
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn invalidate(&self) {
        unsafe {
            ffi::clutter_content_invalidate(self.as_ref().to_glib_none().0);
        }
    }

    fn invalidate_size(&self) {
        unsafe {
            ffi::clutter_content_invalidate_size(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_attached<F: Fn(&Self, &Actor) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn attached_trampoline<P: IsA<Content>, F: Fn(&P, &Actor) + 'static>(this: *mut ffi::ClutterContent, actor: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Content::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(actor))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"attached\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(attached_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_detached<F: Fn(&Self, &Actor) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn detached_trampoline<P: IsA<Content>, F: Fn(&P, &Actor) + 'static>(this: *mut ffi::ClutterContent, actor: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Content::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(actor))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"detached\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(detached_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Content {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Content")
    }
}
