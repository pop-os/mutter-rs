// Generated by gir (https://github.com/gtk-rs/gir @ 45cd7bc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

use crate::Actor;
use crate::Animatable;
use crate::Color;
use crate::Container;
use crate::Scriptable;
#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
use crate::TextBuffer;
use glib::object::Cast;
use glib::object::IsA;
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
use glib::object::ObjectExt;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use glib::ToValue;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "ClutterText")]
    pub struct Text(Object<ffi::ClutterText, ffi::ClutterTextClass>) @extends Actor, @implements Animatable, Container, Scriptable;

    match fn {
        type_ => || ffi::clutter_text_get_type(),
    }
}

impl Text {
    /// Creates a new [`Text`][crate::Text] actor. This actor can be used to
    /// display and edit text.
    ///
    /// # Returns
    ///
    /// the newly created [`Text`][crate::Text] actor
    #[doc(alias = "clutter_text_new")]
    pub fn new() -> Text {
        unsafe {
            Actor::from_glib_none(ffi::clutter_text_new()).unsafe_cast()
        }
    }

    /// Creates a new [`Text`][crate::Text] actor, using `font_name` as the font
    /// description; `text` will be used to set the contents of the actor;
    /// and `color` will be used as the color to render `text`.
    ///
    /// This function is equivalent to calling [`new()`][Self::new()],
    /// [`TextExt::set_font_name()`][crate::prelude::TextExt::set_font_name()], [`TextExt::set_text()`][crate::prelude::TextExt::set_text()] and
    /// [`TextExt::set_color()`][crate::prelude::TextExt::set_color()].
    /// ## `font_name`
    /// a string with a font description
    /// ## `text`
    /// the contents of the actor
    /// ## `color`
    /// the color to be used to render `text`
    ///
    /// # Returns
    ///
    /// the newly created [`Text`][crate::Text] actor
    #[doc(alias = "clutter_text_new_full")]
    pub fn new_full(font_name: &str, text: &str, color: &Color) -> Text {
        unsafe {
            Actor::from_glib_none(ffi::clutter_text_new_full(font_name.to_glib_none().0, text.to_glib_none().0, color.to_glib_none().0)).unsafe_cast()
        }
    }

    /// Creates a new entry with the specified text buffer.
    /// ## `buffer`
    /// The buffer to use for the new [`Text`][crate::Text].
    ///
    /// # Returns
    ///
    /// a new [`Text`][crate::Text]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_text_new_with_buffer")]
    #[doc(alias = "new_with_buffer")]
    pub fn with_buffer<P: IsA<TextBuffer>>(buffer: &P) -> Text {
        unsafe {
            Actor::from_glib_none(ffi::clutter_text_new_with_buffer(buffer.as_ref().to_glib_none().0)).unsafe_cast()
        }
    }

    /// Creates a new [`Text`][crate::Text] actor, using `font_name` as the font
    /// description; `text` will be used to set the contents of the actor.
    ///
    /// This function is equivalent to calling [`new()`][Self::new()],
    /// [`TextExt::set_font_name()`][crate::prelude::TextExt::set_font_name()], and [`TextExt::set_text()`][crate::prelude::TextExt::set_text()].
    /// ## `font_name`
    /// a string with a font description
    /// ## `text`
    /// the contents of the actor
    ///
    /// # Returns
    ///
    /// the newly created [`Text`][crate::Text] actor
    #[doc(alias = "clutter_text_new_with_text")]
    #[doc(alias = "new_with_text")]
    pub fn with_text(font_name: Option<&str>, text: &str) -> Text {
        unsafe {
            Actor::from_glib_none(ffi::clutter_text_new_with_text(font_name.to_glib_none().0, text.to_glib_none().0)).unsafe_cast()
        }
    }
}

#[cfg(any(feature = "v1_0", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
impl Default for Text {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_TEXT: Option<&Text> = None;

/// Trait containing all [`struct@Text`] methods.
///
/// # Implementors
///
/// [`Text`][struct@crate::Text]
pub trait TextExt: 'static {
    /// Emits the `signal::Text::activate` signal, if `self` has been set
    /// as activatable using [`set_activatable()`][Self::set_activatable()].
    ///
    /// This function can be used to emit the ::activate signal inside
    /// a `signal::Actor::captured-event` or `signal::Actor::key-press-event`
    /// signal handlers before the default signal handler for the
    /// [`Text`][crate::Text] is invoked.
    ///
    /// # Returns
    ///
    /// [`true`] if the ::activate signal has been emitted,
    ///  and [`false`] otherwise
    #[doc(alias = "clutter_text_activate")]
    fn activate(&self) -> bool;

    /// Retrieves the position of the character at the given coordinates.
    /// ## `x`
    /// the X coordinate, relative to the actor
    /// ## `y`
    /// the Y coordinate, relative to the actor
    ///
    /// # Returns
    ///
    /// the position of the character
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_text_coords_to_position")]
    fn coords_to_position(&self, x: f32, y: f32) -> i32;

    /// Deletes `n_chars` inside a [`Text`][crate::Text] actor, starting from the
    /// current cursor position.
    ///
    /// Somewhat awkwardly, the cursor position is decremented by the same
    /// number of characters you've deleted.
    /// ## `n_chars`
    /// the number of characters to delete
    #[doc(alias = "clutter_text_delete_chars")]
    fn delete_chars(&self, n_chars: u32);

    /// Deletes the currently selected text
    ///
    /// This function is only useful in subclasses of [`Text`][crate::Text]
    ///
    /// # Returns
    ///
    /// [`true`] if text was deleted or if the text actor
    ///  is empty, and [`false`] otherwise
    #[doc(alias = "clutter_text_delete_selection")]
    fn delete_selection(&self) -> bool;

    /// Deletes the text inside a [`Text`][crate::Text] actor between `start_pos`
    /// and `end_pos`.
    ///
    /// The starting and ending positions are expressed in characters,
    /// not in bytes.
    /// ## `start_pos`
    /// starting position
    /// ## `end_pos`
    /// ending position
    #[doc(alias = "clutter_text_delete_text")]
    fn delete_text(&self, start_pos: isize, end_pos: isize);

    /// Retrieves whether a [`Text`][crate::Text] is activatable or not.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor is activatable
    #[doc(alias = "clutter_text_get_activatable")]
    #[doc(alias = "get_activatable")]
    fn is_activatable(&self) -> bool;

    /// Gets the attribute list that was set on the [`Text`][crate::Text] actor
    /// [`set_attributes()`][Self::set_attributes()], if any.
    ///
    /// # Returns
    ///
    /// the attribute list, or [`None`] if none was set. The
    ///  returned value is owned by the [`Text`][crate::Text] and should not be unreferenced.
    #[doc(alias = "clutter_text_get_attributes")]
    #[doc(alias = "get_attributes")]
    fn attributes(&self) -> Option<pango::AttrList>;

    /// Get the [`TextBuffer`][crate::TextBuffer] object which holds the text for
    /// this widget.
    ///
    /// # Returns
    ///
    /// A `GtkEntryBuffer` object.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_text_get_buffer")]
    #[doc(alias = "get_buffer")]
    fn buffer(&self) -> Option<TextBuffer>;

    /// Retrieves the contents of the [`Text`][crate::Text] actor between
    /// `start_pos` and `end_pos`, but not including `end_pos`.
    ///
    /// The positions are specified in characters, not in bytes.
    /// ## `start_pos`
    /// start of text, in characters
    /// ## `end_pos`
    /// end of text, in characters
    ///
    /// # Returns
    ///
    /// a newly allocated string with the contents of
    ///  the text actor between the specified positions. Use `g_free()`
    ///  to free the resources when done
    #[doc(alias = "clutter_text_get_chars")]
    #[doc(alias = "get_chars")]
    fn chars(&self, start_pos: isize, end_pos: isize) -> Option<glib::GString>;

    /// Retrieves the text color as set by [`set_color()`][Self::set_color()].
    ///
    /// # Returns
    ///
    ///
    /// ## `color`
    /// return location for a [`Color`][crate::Color]
    #[doc(alias = "clutter_text_get_color")]
    #[doc(alias = "get_color")]
    fn color(&self) -> Color;

    /// Retrieves the color of the cursor of a [`Text`][crate::Text] actor.
    ///
    /// # Returns
    ///
    ///
    /// ## `color`
    /// return location for a [`Color`][crate::Color]
    #[doc(alias = "clutter_text_get_cursor_color")]
    #[doc(alias = "get_cursor_color")]
    fn cursor_color(&self) -> Color;

    /// Retrieves the cursor position.
    ///
    /// # Returns
    ///
    /// the cursor position, in characters
    #[doc(alias = "clutter_text_get_cursor_position")]
    #[doc(alias = "get_cursor_position")]
    fn cursor_position(&self) -> i32;

    //#[cfg(any(feature = "v1_16", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    //#[doc(alias = "clutter_text_get_cursor_rect")]
    //#[doc(alias = "get_cursor_rect")]
    //fn cursor_rect(&self, rect: /*Ignored*/graphene::Rect);

    /// Retrieves the size of the cursor of a [`Text`][crate::Text] actor.
    ///
    /// # Returns
    ///
    /// the size of the cursor, in pixels
    #[doc(alias = "clutter_text_get_cursor_size")]
    #[doc(alias = "get_cursor_size")]
    fn cursor_size(&self) -> u32;

    /// Retrieves whether the cursor of a [`Text`][crate::Text] actor is visible.
    ///
    /// # Returns
    ///
    /// [`true`] if the cursor is visible
    #[doc(alias = "clutter_text_get_cursor_visible")]
    #[doc(alias = "get_cursor_visible")]
    fn is_cursor_visible(&self) -> bool;

    /// Retrieves whether a [`Text`][crate::Text] is editable or not.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor is editable
    #[doc(alias = "clutter_text_get_editable")]
    #[doc(alias = "get_editable")]
    fn is_editable(&self) -> bool;

    /// Returns the ellipsizing position of a [`Text`][crate::Text] actor, as
    /// set by [`set_ellipsize()`][Self::set_ellipsize()].
    ///
    /// # Returns
    ///
    /// [`pango::EllipsizeMode`][crate::pango::EllipsizeMode]
    #[doc(alias = "clutter_text_get_ellipsize")]
    #[doc(alias = "get_ellipsize")]
    fn ellipsize(&self) -> pango::EllipsizeMode;

    /// Retrieves the [`pango::FontDescription`][crate::pango::FontDescription] used by `self`
    ///
    /// # Returns
    ///
    /// a [`pango::FontDescription`][crate::pango::FontDescription]. The returned value is owned
    ///  by the [`Text`][crate::Text] actor and it should not be modified or freed
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "clutter_text_get_font_description")]
    #[doc(alias = "get_font_description")]
    fn font_description(&self) -> Option<pango::FontDescription>;

    /// Retrieves the font name as set by [`set_font_name()`][Self::set_font_name()].
    ///
    /// # Returns
    ///
    /// a string containing the font name. The returned
    ///  string is owned by the [`Text`][crate::Text] actor and should not be
    ///  modified or freed
    #[doc(alias = "clutter_text_get_font_name")]
    #[doc(alias = "get_font_name")]
    fn font_name(&self) -> Option<glib::GString>;

    //#[doc(alias = "clutter_text_get_input_hints")]
    //#[doc(alias = "get_input_hints")]
    //fn input_hints(&self) -> /*Ignored*/InputContentHintFlags;

    //#[doc(alias = "clutter_text_get_input_purpose")]
    //#[doc(alias = "get_input_purpose")]
    //fn input_purpose(&self) -> /*Ignored*/InputContentPurpose;

    /// Retrieves whether the [`Text`][crate::Text] actor should justify its contents
    /// on both margins.
    ///
    /// # Returns
    ///
    /// [`true`] if the text should be justified
    #[doc(alias = "clutter_text_get_justify")]
    #[doc(alias = "get_justify")]
    fn is_justify(&self) -> bool;

    /// Retrieves the current [`pango::Layout`][crate::pango::Layout] used by a [`Text`][crate::Text] actor.
    ///
    /// # Returns
    ///
    /// a [`pango::Layout`][crate::pango::Layout]. The returned object is owned by
    ///  the [`Text`][crate::Text] actor and should not be modified or freed
    #[doc(alias = "clutter_text_get_layout")]
    #[doc(alias = "get_layout")]
    fn layout(&self) -> Option<pango::Layout>;

    /// Obtains the coordinates where the [`Text`][crate::Text] will draw the [`pango::Layout`][crate::pango::Layout]
    /// representing the text.
    ///
    /// # Returns
    ///
    ///
    /// ## `x`
    /// location to store X offset of layout, or [`None`]
    ///
    /// ## `y`
    /// location to store Y offset of layout, or [`None`]
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "clutter_text_get_layout_offsets")]
    #[doc(alias = "get_layout_offsets")]
    fn layout_offsets(&self) -> (i32, i32);

    /// Retrieves the alignment of a [`Text`][crate::Text], as set by
    /// [`set_line_alignment()`][Self::set_line_alignment()].
    ///
    /// # Returns
    ///
    /// a [`pango::Alignment`][crate::pango::Alignment]
    #[doc(alias = "clutter_text_get_line_alignment")]
    #[doc(alias = "get_line_alignment")]
    fn line_alignment(&self) -> pango::Alignment;

    /// Retrieves the value set using [`set_line_wrap()`][Self::set_line_wrap()].
    ///
    /// # Returns
    ///
    /// [`true`] if the [`Text`][crate::Text] actor should wrap
    ///  its contents
    #[doc(alias = "clutter_text_get_line_wrap")]
    #[doc(alias = "get_line_wrap")]
    fn is_line_wrap(&self) -> bool;

    /// Retrieves the line wrap mode used by the [`Text`][crate::Text] actor.
    ///
    /// See clutter_text_set_line_wrap_mode ().
    ///
    /// # Returns
    ///
    /// the wrap mode used by the [`Text`][crate::Text]
    #[doc(alias = "clutter_text_get_line_wrap_mode")]
    #[doc(alias = "get_line_wrap_mode")]
    fn line_wrap_mode(&self) -> pango::WrapMode;

    /// Gets the maximum length of text that can be set into a text actor.
    ///
    /// See [`set_max_length()`][Self::set_max_length()].
    ///
    /// # Returns
    ///
    /// the maximum number of characters.
    #[doc(alias = "clutter_text_get_max_length")]
    #[doc(alias = "get_max_length")]
    fn max_length(&self) -> i32;

    /// Retrieves the character to use in place of the actual text
    /// as set by [`set_password_char()`][Self::set_password_char()].
    ///
    /// # Returns
    ///
    /// a Unicode character or 0 if the password
    ///  character is not set
    #[doc(alias = "clutter_text_get_password_char")]
    #[doc(alias = "get_password_char")]
    fn password_char(&self) -> char;

    /// Retrieves whether a [`Text`][crate::Text] is selectable or not.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor is selectable
    #[doc(alias = "clutter_text_get_selectable")]
    #[doc(alias = "get_selectable")]
    fn is_selectable(&self) -> bool;

    /// Retrieves the color of selected text of a [`Text`][crate::Text] actor.
    ///
    /// # Returns
    ///
    ///
    /// ## `color`
    /// return location for a [`Color`][crate::Color]
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "clutter_text_get_selected_text_color")]
    #[doc(alias = "get_selected_text_color")]
    fn selected_text_color(&self) -> Color;

    /// Retrieves the currently selected text.
    ///
    /// # Returns
    ///
    /// a newly allocated string containing the currently
    ///  selected text, or [`None`]. Use `g_free()` to free the returned
    ///  string.
    #[doc(alias = "clutter_text_get_selection")]
    #[doc(alias = "get_selection")]
    fn selection(&self) -> Option<glib::GString>;

    /// Retrieves the other end of the selection of a [`Text`][crate::Text] actor,
    /// in characters from the current cursor position.
    ///
    /// # Returns
    ///
    /// the position of the other end of the selection
    #[doc(alias = "clutter_text_get_selection_bound")]
    #[doc(alias = "get_selection_bound")]
    fn selection_bound(&self) -> i32;

    /// Retrieves the color of the selection of a [`Text`][crate::Text] actor.
    ///
    /// # Returns
    ///
    ///
    /// ## `color`
    /// return location for a [`Color`][crate::Color]
    #[doc(alias = "clutter_text_get_selection_color")]
    #[doc(alias = "get_selection_color")]
    fn selection_color(&self) -> Color;

    /// Retrieves whether the [`Text`][crate::Text] actor is in single line mode.
    ///
    /// # Returns
    ///
    /// [`true`] if the [`Text`][crate::Text] actor is in single line mode
    #[doc(alias = "clutter_text_get_single_line_mode")]
    #[doc(alias = "get_single_line_mode")]
    fn is_single_line_mode(&self) -> bool;

    /// Retrieves a pointer to the current contents of a [`Text`][crate::Text]
    /// actor.
    ///
    /// If you need a copy of the contents for manipulating, either
    /// use `g_strdup()` on the returned string, or use:
    ///
    ///
    /// ```text
    ///    copy = clutter_text_get_chars (text, 0, -1);
    /// ```
    ///
    /// Which will return a newly allocated string.
    ///
    /// If the [`Text`][crate::Text] actor is empty, this function will return
    /// an empty string, and not [`None`].
    ///
    /// # Returns
    ///
    /// the contents of the actor. The returned
    ///  string is owned by the [`Text`][crate::Text] actor and should never be modified
    ///  or freed
    #[doc(alias = "clutter_text_get_text")]
    #[doc(alias = "get_text")]
    fn text(&self) -> Option<glib::GString>;

    /// Retrieves whether the contents of the [`Text`][crate::Text] actor should be
    /// parsed for the Pango text markup.
    ///
    /// # Returns
    ///
    /// [`true`] if the contents will be parsed for markup
    #[doc(alias = "clutter_text_get_use_markup")]
    #[doc(alias = "get_use_markup")]
    fn uses_markup(&self) -> bool;

    #[doc(alias = "clutter_text_has_preedit")]
    fn has_preedit(&self) -> bool;

    /// Inserts `text` into a [`Actor`][crate::Actor] at the given position.
    ///
    /// If `position` is a negative number, the text will be appended
    /// at the end of the current contents of the [`Text`][crate::Text].
    ///
    /// The position is expressed in characters, not in bytes.
    /// ## `text`
    /// the text to be inserted
    /// ## `position`
    /// the position of the insertion, or -1
    #[doc(alias = "clutter_text_insert_text")]
    fn insert_text(&self, text: &str, position: isize);

    /// Inserts `wc` at the current cursor position of a
    /// [`Text`][crate::Text] actor.
    /// ## `wc`
    /// a Unicode character
    #[doc(alias = "clutter_text_insert_unichar")]
    fn insert_unichar(&self, wc: char);

    /// Retrieves the coordinates of the given `position`.
    /// ## `position`
    /// position in characters
    ///
    /// # Returns
    ///
    /// [`true`] if the conversion was successful
    ///
    /// ## `x`
    /// return location for the X coordinate, or [`None`]
    ///
    /// ## `y`
    /// return location for the Y coordinate, or [`None`]
    ///
    /// ## `line_height`
    /// return location for the line height, or [`None`]
    #[doc(alias = "clutter_text_position_to_coords")]
    fn position_to_coords(&self, position: i32) -> Option<(f32, f32, f32)>;

    /// Sets whether a [`Text`][crate::Text] actor should be activatable.
    ///
    /// An activatable [`Text`][crate::Text] actor will emit the `signal::Text::activate`
    /// signal whenever the 'Enter' (or 'Return') key is pressed; if it is not
    /// activatable, a new line will be appended to the current content.
    ///
    /// An activatable [`Text`][crate::Text] must also be set as editable using
    /// [`set_editable()`][Self::set_editable()].
    /// ## `activatable`
    /// whether the [`Text`][crate::Text] actor should be activatable
    #[doc(alias = "clutter_text_set_activatable")]
    fn set_activatable(&self, activatable: bool);

    /// Sets the attributes list that are going to be applied to the
    /// [`Text`][crate::Text] contents.
    ///
    /// The [`Text`][crate::Text] actor will take a reference on the [`pango::AttrList`][crate::pango::AttrList]
    /// passed to this function.
    /// ## `attrs`
    /// a [`pango::AttrList`][crate::pango::AttrList] or [`None`] to unset the attributes
    #[doc(alias = "clutter_text_set_attributes")]
    fn set_attributes(&self, attrs: Option<&pango::AttrList>);

    /// Set the [`TextBuffer`][crate::TextBuffer] object which holds the text for
    /// this widget.
    /// ## `buffer`
    /// a [`TextBuffer`][crate::TextBuffer]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_text_set_buffer")]
    fn set_buffer<P: IsA<TextBuffer>>(&self, buffer: &P);

    /// Sets the color of the contents of a [`Text`][crate::Text] actor.
    ///
    /// The overall opacity of the [`Text`][crate::Text] actor will be the
    /// result of the alpha value of `color` and the composited
    /// opacity of the actor itself on the scenegraph, as returned
    /// by [`ActorExt::paint_opacity()`][crate::prelude::ActorExt::paint_opacity()].
    /// ## `color`
    /// a [`Color`][crate::Color]
    #[doc(alias = "clutter_text_set_color")]
    fn set_color(&self, color: &Color);

    /// Sets the color of the cursor of a [`Text`][crate::Text] actor.
    ///
    /// If `color` is [`None`], the cursor color will be the same as the
    /// text color.
    /// ## `color`
    /// the color of the cursor, or [`None`] to unset it
    #[doc(alias = "clutter_text_set_cursor_color")]
    fn set_cursor_color(&self, color: Option<&Color>);

    /// Sets the cursor of a [`Text`][crate::Text] actor at `position`.
    ///
    /// The position is expressed in characters, not in bytes.
    /// ## `position`
    /// the new cursor position, in characters
    #[doc(alias = "clutter_text_set_cursor_position")]
    fn set_cursor_position(&self, position: i32);

    /// Sets the size of the cursor of a [`Text`][crate::Text]. The cursor
    /// will only be visible if the `property::Text::cursor-visible` property
    /// is set to [`true`].
    /// ## `size`
    /// the size of the cursor, in pixels, or -1 to use the
    ///  default value
    #[doc(alias = "clutter_text_set_cursor_size")]
    fn set_cursor_size(&self, size: i32);

    /// Sets whether the cursor of a [`Text`][crate::Text] actor should be
    /// visible or not.
    ///
    /// The color of the cursor will be the same as the text color
    /// unless [`set_cursor_color()`][Self::set_cursor_color()] has been called.
    ///
    /// The size of the cursor can be set using [`set_cursor_size()`][Self::set_cursor_size()].
    ///
    /// The position of the cursor can be changed programmatically using
    /// [`set_cursor_position()`][Self::set_cursor_position()].
    /// ## `cursor_visible`
    /// whether the cursor should be visible
    #[doc(alias = "clutter_text_set_cursor_visible")]
    fn set_cursor_visible(&self, cursor_visible: bool);

    /// Sets whether the [`Text`][crate::Text] actor should be editable.
    ///
    /// An editable [`Text`][crate::Text] with key focus set using
    /// [`ActorExt::grab_key_focus()`][crate::prelude::ActorExt::grab_key_focus()] or [`StageExt::set_key_focus()`][crate::prelude::StageExt::set_key_focus()]
    /// will receive key events and will update its contents accordingly.
    /// ## `editable`
    /// whether the [`Text`][crate::Text] should be editable
    #[doc(alias = "clutter_text_set_editable")]
    fn set_editable(&self, editable: bool);

    /// Sets the mode used to ellipsize (add an ellipsis: "...") to the
    /// text if there is not enough space to render the entire contents
    /// of a [`Text`][crate::Text] actor
    /// ## `mode`
    /// a [`pango::EllipsizeMode`][crate::pango::EllipsizeMode]
    #[doc(alias = "clutter_text_set_ellipsize")]
    fn set_ellipsize(&self, mode: pango::EllipsizeMode);

    /// Sets `font_desc` as the font description for a [`Text`][crate::Text]
    ///
    /// The [`pango::FontDescription`][crate::pango::FontDescription] is copied by the [`Text`][crate::Text] actor
    /// so you can safely call `pango_font_description_free()` on it after
    /// calling this function.
    /// ## `font_desc`
    /// a [`pango::FontDescription`][crate::pango::FontDescription]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "clutter_text_set_font_description")]
    fn set_font_description(&self, font_desc: &mut pango::FontDescription);

    /// Sets the font used by a [`Text`][crate::Text]. The `font_name` string
    /// must either be [`None`], which means that the font name from the
    /// default [`Backend`][crate::Backend] will be used; or be something that can
    /// be parsed by the [`pango::FontDescription::from_string()`][crate::pango::FontDescription::from_string()] function,
    /// like:
    ///
    ///
    /// ```text
    ///   // Set the font to the system's Sans, 10 points
    ///   clutter_text_set_font_name (text, "Sans 10");
    ///
    ///   // Set the font to the system's Serif, 16 pixels
    ///   clutter_text_set_font_name (text, "Serif 16px");
    ///
    ///   // Set the font to Helvetica, 10 points
    ///   clutter_text_set_font_name (text, "Helvetica 10");
    /// ```
    /// ## `font_name`
    /// a font name, or [`None`] to set the default font name
    #[doc(alias = "clutter_text_set_font_name")]
    fn set_font_name(&self, font_name: Option<&str>);

    //#[doc(alias = "clutter_text_set_input_hints")]
    //fn set_input_hints(&self, hints: /*Ignored*/InputContentHintFlags);

    //#[doc(alias = "clutter_text_set_input_purpose")]
    //fn set_input_purpose(&self, purpose: /*Ignored*/InputContentPurpose);

    /// Sets whether the text of the [`Text`][crate::Text] actor should be justified
    /// on both margins. This setting is ignored if Clutter is compiled
    /// against Pango &lt; 1.18.
    /// ## `justify`
    /// whether the text should be justified
    #[doc(alias = "clutter_text_set_justify")]
    fn set_justify(&self, justify: bool);

    /// Sets the way that the lines of a wrapped label are aligned with
    /// respect to each other. This does not affect the overall alignment
    /// of the label within its allocated or specified width.
    ///
    /// To align a [`Text`][crate::Text] actor you should add it to a container
    /// that supports alignment, or use the anchor point.
    /// ## `alignment`
    /// A [`pango::Alignment`][crate::pango::Alignment]
    #[doc(alias = "clutter_text_set_line_alignment")]
    fn set_line_alignment(&self, alignment: pango::Alignment);

    /// Sets whether the contents of a [`Text`][crate::Text] actor should wrap,
    /// if they don't fit the size assigned to the actor.
    /// ## `line_wrap`
    /// whether the contents should wrap
    #[doc(alias = "clutter_text_set_line_wrap")]
    fn set_line_wrap(&self, line_wrap: bool);

    /// If line wrapping is enabled (see [`set_line_wrap()`][Self::set_line_wrap()]) this
    /// function controls how the line wrapping is performed. The default is
    /// [`pango::WrapMode::Word`][crate::pango::WrapMode::Word] which means wrap on word boundaries.
    /// ## `wrap_mode`
    /// the line wrapping mode
    #[doc(alias = "clutter_text_set_line_wrap_mode")]
    fn set_line_wrap_mode(&self, wrap_mode: pango::WrapMode);

    /// Sets `markup` as the contents of a [`Text`][crate::Text].
    ///
    /// This is a convenience function for setting a string containing
    /// Pango markup, and it is logically equivalent to:
    ///
    ///
    /// ```text
    ///   /&ast; the order is important &ast;/
    ///   clutter_text_set_text (CLUTTER_TEXT (actor), markup);
    ///   clutter_text_set_use_markup (CLUTTER_TEXT (actor), TRUE);
    /// ```
    /// ## `markup`
    /// a string containing Pango markup.
    ///  Passing [`None`] is the same as passing "" (the empty string)
    #[doc(alias = "clutter_text_set_markup")]
    fn set_markup(&self, markup: Option<&str>);

    /// Sets the maximum allowed length of the contents of the actor. If the
    /// current contents are longer than the given length, then they will be
    /// truncated to fit.
    /// ## `max`
    /// the maximum number of characters allowed in the text actor; 0
    ///  to disable or -1 to set the length of the current string
    #[doc(alias = "clutter_text_set_max_length")]
    fn set_max_length(&self, max: i32);

    /// Sets the character to use in place of the actual text in a
    /// password text actor.
    ///
    /// If `wc` is 0 the text will be displayed as it is entered in the
    /// [`Text`][crate::Text] actor.
    /// ## `wc`
    /// a Unicode character, or 0 to unset the password character
    #[doc(alias = "clutter_text_set_password_char")]
    fn set_password_char(&self, wc: char);

    /// Sets, or unsets, the pre-edit string. This function is useful
    /// for input methods to display a string (with eventual specific
    /// Pango attributes) before it is entered inside the [`Text`][crate::Text]
    /// buffer.
    ///
    /// The preedit string and attributes are ignored if the [`Text`][crate::Text]
    /// actor is not editable.
    ///
    /// This function should not be used by applications
    /// ## `preedit_str`
    /// the pre-edit string, or [`None`] to unset it
    /// ## `preedit_attrs`
    /// the pre-edit string attributes
    /// ## `cursor_pos`
    /// the cursor position for the pre-edit string
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "clutter_text_set_preedit_string")]
    fn set_preedit_string(&self, preedit_str: Option<&str>, preedit_attrs: Option<&pango::AttrList>, cursor_pos: u32);

    /// Sets whether a [`Text`][crate::Text] actor should be selectable.
    ///
    /// A selectable [`Text`][crate::Text] will allow selecting its contents using
    /// the pointer or the keyboard.
    /// ## `selectable`
    /// whether the [`Text`][crate::Text] actor should be selectable
    #[doc(alias = "clutter_text_set_selectable")]
    fn set_selectable(&self, selectable: bool);

    /// Sets the selected text color of a [`Text`][crate::Text] actor.
    ///
    /// If `color` is [`None`], the selected text color will be the same as the
    /// selection color, which then falls back to cursor, and then text color.
    /// ## `color`
    /// the selected text color, or [`None`] to unset it
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "clutter_text_set_selected_text_color")]
    fn set_selected_text_color(&self, color: Option<&Color>);

    /// Selects the region of text between `start_pos` and `end_pos`.
    ///
    /// This function changes the position of the cursor to match
    /// `start_pos` and the selection bound to match `end_pos`.
    /// ## `start_pos`
    /// start of the selection, in characters
    /// ## `end_pos`
    /// end of the selection, in characters
    #[doc(alias = "clutter_text_set_selection")]
    fn set_selection(&self, start_pos: isize, end_pos: isize);

    /// Sets the other end of the selection, starting from the current
    /// cursor position.
    ///
    /// If `selection_bound` is -1, the selection unset.
    /// ## `selection_bound`
    /// the position of the end of the selection, in characters
    #[doc(alias = "clutter_text_set_selection_bound")]
    fn set_selection_bound(&self, selection_bound: i32);

    /// Sets the color of the selection of a [`Text`][crate::Text] actor.
    ///
    /// If `color` is [`None`], the selection color will be the same as the
    /// cursor color, or if no cursor color is set either then it will be
    /// the same as the text color.
    /// ## `color`
    /// the color of the selection, or [`None`] to unset it
    #[doc(alias = "clutter_text_set_selection_color")]
    fn set_selection_color(&self, color: Option<&Color>);

    /// Sets whether a [`Text`][crate::Text] actor should be in single line mode
    /// or not. Only editable [`Text`][crate::Text]<!-- -->s can be in single line
    /// mode.
    ///
    /// A text actor in single line mode will not wrap text and will clip
    /// the visible area to the predefined size. The contents of the
    /// text actor will scroll to display the end of the text if its length
    /// is bigger than the allocated width.
    ///
    /// When setting the single line mode the `property::Text::activatable`
    /// property is also set as a side effect. Instead of entering a new
    /// line character, the text actor will emit the `signal::Text::activate`
    /// signal.
    /// ## `single_line`
    /// whether to enable single line mode
    #[doc(alias = "clutter_text_set_single_line_mode")]
    fn set_single_line_mode(&self, single_line: bool);

    /// Sets the contents of a [`Text`][crate::Text] actor.
    ///
    /// If the `property::Text::use-markup` property was set to [`true`] it
    /// will be reset to [`false`] as a side effect. If you want to
    /// maintain the `property::Text::use-markup` you should use the
    /// [`set_markup()`][Self::set_markup()] function instead
    /// ## `text`
    /// the text to set. Passing [`None`] is the same
    ///  as passing "" (the empty string)
    #[doc(alias = "clutter_text_set_text")]
    fn set_text(&self, text: Option<&str>);

    /// Sets whether the contents of the [`Text`][crate::Text] actor contains markup
    /// in <link linkend="PangoMarkupFormat">Pango's text markup language`</link>`.
    ///
    /// Setting `property::Text::use-markup` on an editable [`Text`][crate::Text] will
    /// not have any effect except hiding the markup.
    ///
    /// See also `property::Text::use-markup`.
    /// ## `setting`
    /// [`true`] if the text should be parsed for markup.
    #[doc(alias = "clutter_text_set_use_markup")]
    fn set_use_markup(&self, setting: bool);

    /// The buffer which stores the text for this [`Text`][crate::Text].
    ///
    /// If set to [`None`], a default buffer will be created.
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn get_property_buffer(&self) -> Option<TextBuffer>;

    /// The buffer which stores the text for this [`Text`][crate::Text].
    ///
    /// If set to [`None`], a default buffer will be created.
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn set_property_buffer<P: IsA<TextBuffer>>(&self, buffer: Option<&P>);

    /// Will be set to [`true`] if `property::Text::cursor-color` has been set.
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "cursor-color-set")]
    fn is_cursor_color_set(&self) -> bool;

    //#[doc(alias = "input-hints")]
    //fn get_property_input_hints(&self) -> /*Ignored*/InputContentHintFlags;

    //#[doc(alias = "input-hints")]
    //fn set_property_input_hints(&self, input_hints: /*Ignored*/InputContentHintFlags);

    //#[doc(alias = "input-purpose")]
    //fn get_property_input_purpose(&self) -> /*Ignored*/InputContentPurpose;

    //#[doc(alias = "input-purpose")]
    //fn set_property_input_purpose(&self, input_purpose: /*Ignored*/InputContentPurpose);

    /// The current input cursor position. -1 is taken to be the end of the text
    ///
    /// # Deprecated since 1.12
    ///
    /// Use ClutterText:cursor-position instead.
    #[cfg_attr(feature = "v1_12", deprecated = "Since 1.12")]
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn position(&self) -> i32;

    /// The current input cursor position. -1 is taken to be the end of the text
    ///
    /// # Deprecated since 1.12
    ///
    /// Use ClutterText:cursor-position instead.
    #[cfg_attr(feature = "v1_12", deprecated = "Since 1.12")]
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn set_position(&self, position: i32);

    /// Will be set to [`true`] if `property::Text::selected-text-color` has been set.
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "selected-text-color-set")]
    fn is_selected_text_color_set(&self) -> bool;

    /// Will be set to [`true`] if `property::Text::selection-color` has been set.
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "selection-color-set")]
    fn is_selection_color_set(&self) -> bool;

    /// The ::activate signal is emitted each time the actor is 'activated'
    /// by the user, normally by pressing the 'Enter' key. The signal is
    /// emitted only if `property::Text::activatable` is set to [`true`].
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "activate")]
    fn connect_activate<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    /// The ::cursor-changed signal is emitted whenever the cursor
    /// position or size changes.
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    #[doc(alias = "cursor-changed")]
    fn connect_cursor_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg_attr(feature = "v1_16", deprecated = "Since 1.16")]
    //#[cfg(any(feature = "v1_0", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    //#[doc(alias = "cursor-event")]
    //fn connect_cursor_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    /// This signal is emitted when text is deleted from the actor by
    /// the user. It is emitted before `self_` text changes.
    /// ## `start_pos`
    /// the starting position
    /// ## `end_pos`
    /// the end position
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "delete-text")]
    fn connect_delete_text<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn emit_delete_text(&self, start_pos: i32, end_pos: i32);

    //#[cfg(any(feature = "v1_2", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    //#[doc(alias = "insert-text")]
    //fn connect_insert_text<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    /// The ::text-changed signal is emitted after `actor`'s text changes
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "text-changed")]
    fn connect_text_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "activatable")]
    fn connect_activatable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "attributes")]
    fn connect_attributes_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "buffer")]
    fn connect_buffer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "color")]
    fn connect_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "cursor-color")]
    fn connect_cursor_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "cursor-color-set")]
    fn connect_cursor_color_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "cursor-position")]
    fn connect_cursor_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "cursor-size")]
    fn connect_cursor_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "cursor-visible")]
    fn connect_cursor_visible_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "editable")]
    fn connect_editable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "ellipsize")]
    fn connect_ellipsize_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "font-description")]
    fn connect_font_description_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "font-name")]
    fn connect_font_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "input-hints")]
    fn connect_input_hints_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "input-purpose")]
    fn connect_input_purpose_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "justify")]
    fn connect_justify_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "line-alignment")]
    fn connect_line_alignment_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "line-wrap")]
    fn connect_line_wrap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "line-wrap-mode")]
    fn connect_line_wrap_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "max-length")]
    fn connect_max_length_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "password-char")]
    fn connect_password_char_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg_attr(feature = "v1_12", deprecated = "Since 1.12")]
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "position")]
    fn connect_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "selectable")]
    fn connect_selectable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "selected-text-color")]
    fn connect_selected_text_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "selected-text-color-set")]
    fn connect_selected_text_color_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "selection-bound")]
    fn connect_selection_bound_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "selection-color")]
    fn connect_selection_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "selection-color-set")]
    fn connect_selection_color_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "single-line-mode")]
    fn connect_single_line_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "text")]
    fn connect_text_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "use-markup")]
    fn connect_use_markup_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Text>> TextExt for O {
    fn activate(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_activate(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn coords_to_position(&self, x: f32, y: f32) -> i32 {
        unsafe {
            ffi::clutter_text_coords_to_position(self.as_ref().to_glib_none().0, x, y)
        }
    }

    fn delete_chars(&self, n_chars: u32) {
        unsafe {
            ffi::clutter_text_delete_chars(self.as_ref().to_glib_none().0, n_chars);
        }
    }

    fn delete_selection(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_delete_selection(self.as_ref().to_glib_none().0))
        }
    }

    fn delete_text(&self, start_pos: isize, end_pos: isize) {
        unsafe {
            ffi::clutter_text_delete_text(self.as_ref().to_glib_none().0, start_pos, end_pos);
        }
    }

    fn is_activatable(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_activatable(self.as_ref().to_glib_none().0))
        }
    }

    fn attributes(&self) -> Option<pango::AttrList> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_attributes(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn buffer(&self) -> Option<TextBuffer> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_buffer(self.as_ref().to_glib_none().0))
        }
    }

    fn chars(&self, start_pos: isize, end_pos: isize) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::clutter_text_get_chars(self.as_ref().to_glib_none().0, start_pos, end_pos))
        }
    }

    fn color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_text_get_color(self.as_ref().to_glib_none().0, color.to_glib_none_mut().0);
            color
        }
    }

    fn cursor_color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_text_get_cursor_color(self.as_ref().to_glib_none().0, color.to_glib_none_mut().0);
            color
        }
    }

    fn cursor_position(&self) -> i32 {
        unsafe {
            ffi::clutter_text_get_cursor_position(self.as_ref().to_glib_none().0)
        }
    }

    //#[cfg(any(feature = "v1_16", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    //fn cursor_rect(&self, rect: /*Ignored*/graphene::Rect) {
    //    unsafe { TODO: call ffi:clutter_text_get_cursor_rect() }
    //}

    fn cursor_size(&self) -> u32 {
        unsafe {
            ffi::clutter_text_get_cursor_size(self.as_ref().to_glib_none().0)
        }
    }

    fn is_cursor_visible(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_cursor_visible(self.as_ref().to_glib_none().0))
        }
    }

    fn is_editable(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_editable(self.as_ref().to_glib_none().0))
        }
    }

    fn ellipsize(&self) -> pango::EllipsizeMode {
        unsafe {
            from_glib(ffi::clutter_text_get_ellipsize(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn font_description(&self) -> Option<pango::FontDescription> {
        unsafe {
            from_glib_full(ffi::clutter_text_get_font_description(self.as_ref().to_glib_none().0))
        }
    }

    fn font_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_font_name(self.as_ref().to_glib_none().0))
        }
    }

    //fn input_hints(&self) -> /*Ignored*/InputContentHintFlags {
    //    unsafe { TODO: call ffi:clutter_text_get_input_hints() }
    //}

    //fn input_purpose(&self) -> /*Ignored*/InputContentPurpose {
    //    unsafe { TODO: call ffi:clutter_text_get_input_purpose() }
    //}

    fn is_justify(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_justify(self.as_ref().to_glib_none().0))
        }
    }

    fn layout(&self) -> Option<pango::Layout> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_layout(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn layout_offsets(&self) -> (i32, i32) {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            ffi::clutter_text_get_layout_offsets(self.as_ref().to_glib_none().0, x.as_mut_ptr(), y.as_mut_ptr());
            let x = x.assume_init();
            let y = y.assume_init();
            (x, y)
        }
    }

    fn line_alignment(&self) -> pango::Alignment {
        unsafe {
            from_glib(ffi::clutter_text_get_line_alignment(self.as_ref().to_glib_none().0))
        }
    }

    fn is_line_wrap(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_line_wrap(self.as_ref().to_glib_none().0))
        }
    }

    fn line_wrap_mode(&self) -> pango::WrapMode {
        unsafe {
            from_glib(ffi::clutter_text_get_line_wrap_mode(self.as_ref().to_glib_none().0))
        }
    }

    fn max_length(&self) -> i32 {
        unsafe {
            ffi::clutter_text_get_max_length(self.as_ref().to_glib_none().0)
        }
    }

    fn password_char(&self) -> char {
        unsafe {
            std::convert::TryFrom::try_from(ffi::clutter_text_get_password_char(self.as_ref().to_glib_none().0)).expect("conversion from an invalid Unicode value attempted")
        }
    }

    fn is_selectable(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_selectable(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn selected_text_color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_text_get_selected_text_color(self.as_ref().to_glib_none().0, color.to_glib_none_mut().0);
            color
        }
    }

    fn selection(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::clutter_text_get_selection(self.as_ref().to_glib_none().0))
        }
    }

    fn selection_bound(&self) -> i32 {
        unsafe {
            ffi::clutter_text_get_selection_bound(self.as_ref().to_glib_none().0)
        }
    }

    fn selection_color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_text_get_selection_color(self.as_ref().to_glib_none().0, color.to_glib_none_mut().0);
            color
        }
    }

    fn is_single_line_mode(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_single_line_mode(self.as_ref().to_glib_none().0))
        }
    }

    fn text(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_text(self.as_ref().to_glib_none().0))
        }
    }

    fn uses_markup(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_use_markup(self.as_ref().to_glib_none().0))
        }
    }

    fn has_preedit(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_has_preedit(self.as_ref().to_glib_none().0))
        }
    }

    fn insert_text(&self, text: &str, position: isize) {
        unsafe {
            ffi::clutter_text_insert_text(self.as_ref().to_glib_none().0, text.to_glib_none().0, position);
        }
    }

    fn insert_unichar(&self, wc: char) {
        unsafe {
            ffi::clutter_text_insert_unichar(self.as_ref().to_glib_none().0, wc.into_glib());
        }
    }

    fn position_to_coords(&self, position: i32) -> Option<(f32, f32, f32)> {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            let mut line_height = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::clutter_text_position_to_coords(self.as_ref().to_glib_none().0, position, x.as_mut_ptr(), y.as_mut_ptr(), line_height.as_mut_ptr()));
            let x = x.assume_init();
            let y = y.assume_init();
            let line_height = line_height.assume_init();
            if ret { Some((x, y, line_height)) } else { None }
        }
    }

    fn set_activatable(&self, activatable: bool) {
        unsafe {
            ffi::clutter_text_set_activatable(self.as_ref().to_glib_none().0, activatable.into_glib());
        }
    }

    fn set_attributes(&self, attrs: Option<&pango::AttrList>) {
        unsafe {
            ffi::clutter_text_set_attributes(self.as_ref().to_glib_none().0, attrs.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_buffer<P: IsA<TextBuffer>>(&self, buffer: &P) {
        unsafe {
            ffi::clutter_text_set_buffer(self.as_ref().to_glib_none().0, buffer.as_ref().to_glib_none().0);
        }
    }

    fn set_color(&self, color: &Color) {
        unsafe {
            ffi::clutter_text_set_color(self.as_ref().to_glib_none().0, color.to_glib_none().0);
        }
    }

    fn set_cursor_color(&self, color: Option<&Color>) {
        unsafe {
            ffi::clutter_text_set_cursor_color(self.as_ref().to_glib_none().0, color.to_glib_none().0);
        }
    }

    fn set_cursor_position(&self, position: i32) {
        unsafe {
            ffi::clutter_text_set_cursor_position(self.as_ref().to_glib_none().0, position);
        }
    }

    fn set_cursor_size(&self, size: i32) {
        unsafe {
            ffi::clutter_text_set_cursor_size(self.as_ref().to_glib_none().0, size);
        }
    }

    fn set_cursor_visible(&self, cursor_visible: bool) {
        unsafe {
            ffi::clutter_text_set_cursor_visible(self.as_ref().to_glib_none().0, cursor_visible.into_glib());
        }
    }

    fn set_editable(&self, editable: bool) {
        unsafe {
            ffi::clutter_text_set_editable(self.as_ref().to_glib_none().0, editable.into_glib());
        }
    }

    fn set_ellipsize(&self, mode: pango::EllipsizeMode) {
        unsafe {
            ffi::clutter_text_set_ellipsize(self.as_ref().to_glib_none().0, mode.into_glib());
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn set_font_description(&self, font_desc: &mut pango::FontDescription) {
        unsafe {
            ffi::clutter_text_set_font_description(self.as_ref().to_glib_none().0, font_desc.to_glib_none_mut().0);
        }
    }

    fn set_font_name(&self, font_name: Option<&str>) {
        unsafe {
            ffi::clutter_text_set_font_name(self.as_ref().to_glib_none().0, font_name.to_glib_none().0);
        }
    }

    //fn set_input_hints(&self, hints: /*Ignored*/InputContentHintFlags) {
    //    unsafe { TODO: call ffi:clutter_text_set_input_hints() }
    //}

    //fn set_input_purpose(&self, purpose: /*Ignored*/InputContentPurpose) {
    //    unsafe { TODO: call ffi:clutter_text_set_input_purpose() }
    //}

    fn set_justify(&self, justify: bool) {
        unsafe {
            ffi::clutter_text_set_justify(self.as_ref().to_glib_none().0, justify.into_glib());
        }
    }

    fn set_line_alignment(&self, alignment: pango::Alignment) {
        unsafe {
            ffi::clutter_text_set_line_alignment(self.as_ref().to_glib_none().0, alignment.into_glib());
        }
    }

    fn set_line_wrap(&self, line_wrap: bool) {
        unsafe {
            ffi::clutter_text_set_line_wrap(self.as_ref().to_glib_none().0, line_wrap.into_glib());
        }
    }

    fn set_line_wrap_mode(&self, wrap_mode: pango::WrapMode) {
        unsafe {
            ffi::clutter_text_set_line_wrap_mode(self.as_ref().to_glib_none().0, wrap_mode.into_glib());
        }
    }

    fn set_markup(&self, markup: Option<&str>) {
        unsafe {
            ffi::clutter_text_set_markup(self.as_ref().to_glib_none().0, markup.to_glib_none().0);
        }
    }

    fn set_max_length(&self, max: i32) {
        unsafe {
            ffi::clutter_text_set_max_length(self.as_ref().to_glib_none().0, max);
        }
    }

    fn set_password_char(&self, wc: char) {
        unsafe {
            ffi::clutter_text_set_password_char(self.as_ref().to_glib_none().0, wc.into_glib());
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn set_preedit_string(&self, preedit_str: Option<&str>, preedit_attrs: Option<&pango::AttrList>, cursor_pos: u32) {
        unsafe {
            ffi::clutter_text_set_preedit_string(self.as_ref().to_glib_none().0, preedit_str.to_glib_none().0, preedit_attrs.to_glib_none().0, cursor_pos);
        }
    }

    fn set_selectable(&self, selectable: bool) {
        unsafe {
            ffi::clutter_text_set_selectable(self.as_ref().to_glib_none().0, selectable.into_glib());
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn set_selected_text_color(&self, color: Option<&Color>) {
        unsafe {
            ffi::clutter_text_set_selected_text_color(self.as_ref().to_glib_none().0, color.to_glib_none().0);
        }
    }

    fn set_selection(&self, start_pos: isize, end_pos: isize) {
        unsafe {
            ffi::clutter_text_set_selection(self.as_ref().to_glib_none().0, start_pos, end_pos);
        }
    }

    fn set_selection_bound(&self, selection_bound: i32) {
        unsafe {
            ffi::clutter_text_set_selection_bound(self.as_ref().to_glib_none().0, selection_bound);
        }
    }

    fn set_selection_color(&self, color: Option<&Color>) {
        unsafe {
            ffi::clutter_text_set_selection_color(self.as_ref().to_glib_none().0, color.to_glib_none().0);
        }
    }

    fn set_single_line_mode(&self, single_line: bool) {
        unsafe {
            ffi::clutter_text_set_single_line_mode(self.as_ref().to_glib_none().0, single_line.into_glib());
        }
    }

    fn set_text(&self, text: Option<&str>) {
        unsafe {
            ffi::clutter_text_set_text(self.as_ref().to_glib_none().0, text.to_glib_none().0);
        }
    }

    fn set_use_markup(&self, setting: bool) {
        unsafe {
            ffi::clutter_text_set_use_markup(self.as_ref().to_glib_none().0, setting.into_glib());
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn get_property_buffer(&self) -> Option<TextBuffer> {
        unsafe {
            let mut value = glib::Value::from_type(<TextBuffer as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"buffer\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `buffer` getter")
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn set_property_buffer<P: IsA<TextBuffer>>(&self, buffer: Option<&P>) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"buffer\0".as_ptr() as *const _, buffer.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn is_cursor_color_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"cursor-color-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `cursor-color-set` getter")
        }
    }

    //fn get_property_input_hints(&self) -> /*Ignored*/InputContentHintFlags {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"input-hints\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `input-hints` getter")
    //    }
    //}

    //fn set_property_input_hints(&self, input_hints: /*Ignored*/InputContentHintFlags) {
    //    unsafe {
    //        glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"input-hints\0".as_ptr() as *const _, input_hints.to_value().to_glib_none().0);
    //    }
    //}

    //fn get_property_input_purpose(&self) -> /*Ignored*/InputContentPurpose {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"input-purpose\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `input-purpose` getter")
    //    }
    //}

    //fn set_property_input_purpose(&self, input_purpose: /*Ignored*/InputContentPurpose) {
    //    unsafe {
    //        glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"input-purpose\0".as_ptr() as *const _, input_purpose.to_value().to_glib_none().0);
    //    }
    //}

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn position(&self) -> i32 {
        unsafe {
            let mut value = glib::Value::from_type(<i32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"position\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `position` getter")
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn set_position(&self, position: i32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"position\0".as_ptr() as *const _, position.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn is_selected_text_color_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"selected-text-color-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `selected-text-color-set` getter")
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn is_selection_color_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"selection-color-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `selection-color-set` getter")
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_activate<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn activate_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"activate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(activate_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    fn connect_cursor_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn cursor_changed_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"cursor-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(cursor_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v1_0", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    //fn connect_cursor_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored rect: Graphene.Rect
    //}

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn connect_delete_text<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn delete_text_trampoline<P: IsA<Text>, F: Fn(&P, i32, i32) + 'static>(this: *mut ffi::ClutterText, start_pos: libc::c_int, end_pos: libc::c_int, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref(), start_pos, end_pos)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"delete-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(delete_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn emit_delete_text(&self, start_pos: i32, end_pos: i32) {
        let _ = unsafe { glib::Object::from_glib_borrow(self.as_ptr() as *mut glib::gobject_ffi::GObject).emit_by_name("delete-text", &[&start_pos, &end_pos]).unwrap() };
    }

    //#[cfg(any(feature = "v1_2", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    //fn connect_insert_text<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Unimplemented position: *.Pointer
    //}

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_text_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn text_changed_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"text-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(text_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_activatable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_activatable_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::activatable\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_activatable_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_attributes_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_attributes_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::attributes\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_attributes_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn connect_buffer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_buffer_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::buffer\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_buffer_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_color_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_color_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_cursor_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_color_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::cursor-color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_cursor_color_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_cursor_color_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_color_set_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::cursor-color-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_cursor_color_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_cursor_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_position_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::cursor-position\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_cursor_position_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_cursor_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_size_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::cursor-size\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_cursor_size_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_cursor_visible_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_visible_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::cursor-visible\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_cursor_visible_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_editable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_editable_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::editable\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_editable_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_ellipsize_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ellipsize_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::ellipsize\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_ellipsize_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn connect_font_description_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_font_description_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::font-description\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_font_description_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_font_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_font_name_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::font-name\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_font_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_input_hints_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_input_hints_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::input-hints\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_input_hints_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_input_purpose_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_input_purpose_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::input-purpose\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_input_purpose_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_justify_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_justify_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::justify\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_justify_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_line_alignment_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_line_alignment_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::line-alignment\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_line_alignment_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_line_wrap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_line_wrap_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::line-wrap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_line_wrap_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_line_wrap_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_line_wrap_mode_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::line-wrap-mode\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_line_wrap_mode_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_max_length_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_max_length_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::max-length\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_max_length_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_password_char_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_char_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::password-char\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_password_char_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_position_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::position\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_position_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_selectable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_selectable_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::selectable\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_selectable_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn connect_selected_text_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_selected_text_color_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::selected-text-color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_selected_text_color_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn connect_selected_text_color_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_selected_text_color_set_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::selected-text-color-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_selected_text_color_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_selection_bound_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_selection_bound_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::selection-bound\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_selection_bound_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_selection_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_selection_color_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::selection-color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_selection_color_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_selection_color_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_selection_color_set_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::selection-color-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_selection_color_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_single_line_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_single_line_mode_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::single-line-mode\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_single_line_mode_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_text_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_text_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_use_markup_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_use_markup_trampoline<P: IsA<Text>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterText, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::use-markup\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_use_markup_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Text {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Text")
    }
}
