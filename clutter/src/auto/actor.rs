// Generated by gir (https://github.com/gtk-rs/gir @ 45cd7bc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 8e47c67)
// from mutter-gir-files
// DO NOT EDIT

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
use crate::Action;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use crate::ActorAlign;
#[cfg(any(feature = "v1_0", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
use crate::ActorFlags;
use crate::Animatable;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use crate::AnimationMode;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use crate::Color;
#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
use crate::Constraint;
use crate::Container;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use crate::Content;
#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
use crate::Effect;
#[cfg(any(feature = "v0_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
use crate::KeyEvent;
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
use crate::Orientation;
#[cfg(any(feature = "v0_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
use crate::RequestMode;
use crate::Scriptable;
#[cfg(any(feature = "v0_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
use crate::Stage;
#[cfg(any(feature = "v1_0", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
use crate::TextDirection;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use glib::ToValue;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "ClutterActor")]
    pub struct Actor(Object<ffi::ClutterActor, ffi::ClutterActorClass>) @implements Animatable, Container, Scriptable;

    match fn {
        type_ => || ffi::clutter_actor_get_type(),
    }
}

impl Actor {
    /// Creates a new [`Actor`][crate::Actor].
    ///
    /// A newly created actor has a floating reference, which will be sunk
    /// when it is added to another actor.
    ///
    /// # Returns
    ///
    /// the newly created [`Actor`][crate::Actor]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_new")]
    pub fn new() -> Actor {
        unsafe {
            from_glib_none(ffi::clutter_actor_new())
        }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl Default for Actor {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_ACTOR: Option<&Actor> = None;

/// Trait containing all [`struct@Actor`] methods.
///
/// # Implementors
///
/// [`Actor`][struct@crate::Actor], [`Stage`][struct@crate::Stage], [`Text`][struct@crate::Text]
pub trait ActorExt: 'static {
    /// Adds `action` to the list of actions applied to `self`
    ///
    /// A [`Action`][crate::Action] can only belong to one actor at a time
    ///
    /// The [`Actor`][crate::Actor] will hold a reference on `action` until either
    /// [`remove_action()`][Self::remove_action()] or [`clear_actions()`][Self::clear_actions()]
    /// is called
    /// ## `action`
    /// a [`Action`][crate::Action]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_add_action")]
    fn add_action<P: IsA<Action>>(&self, action: &P);

    /// A convenience function for setting the name of a [`Action`][crate::Action]
    /// while adding it to the list of actions applied to `self`
    ///
    /// This function is the logical equivalent of:
    ///
    ///
    ///
    /// **⚠️ The following code is in C ⚠️**
    ///
    /// ```C
    ///   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
    ///   clutter_actor_add_action (self, action);
    /// ```
    /// ## `name`
    /// the name to set on the action
    /// ## `action`
    /// a [`Action`][crate::Action]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_add_action_with_name")]
    fn add_action_with_name<P: IsA<Action>>(&self, name: &str, action: &P);

    /// Adds `child` to the children of `self`.
    ///
    /// This function will acquire a reference on `child` that will only
    /// be released when calling [`remove_child()`][Self::remove_child()].
    ///
    /// This function will take into consideration the `property::Actor::depth`
    /// of `child`, and will keep the list of children sorted.
    ///
    /// This function will emit the `signal::Container::actor-added` signal
    /// on `self`.
    /// ## `child`
    /// a [`Actor`][crate::Actor]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_add_child")]
    fn add_child<P: IsA<Actor>>(&self, child: &P);

    /// Adds `constraint` to the list of [`Constraint`][crate::Constraint]<!-- -->s applied
    /// to `self`
    ///
    /// The [`Actor`][crate::Actor] will hold a reference on the `constraint` until
    /// either [`remove_constraint()`][Self::remove_constraint()] or
    /// [`clear_constraints()`][Self::clear_constraints()] is called.
    /// ## `constraint`
    /// a [`Constraint`][crate::Constraint]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_add_constraint")]
    fn add_constraint<P: IsA<Constraint>>(&self, constraint: &P);

    /// A convenience function for setting the name of a [`Constraint`][crate::Constraint]
    /// while adding it to the list of constraints applied to `self`
    ///
    /// This function is the logical equivalent of:
    ///
    ///
    ///
    /// **⚠️ The following code is in C ⚠️**
    ///
    /// ```C
    ///   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
    ///   clutter_actor_add_constraint (self, constraint);
    /// ```
    /// ## `name`
    /// the name to set on the constraint
    /// ## `constraint`
    /// a [`Constraint`][crate::Constraint]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_add_constraint_with_name")]
    fn add_constraint_with_name<P: IsA<Constraint>>(&self, name: &str, constraint: &P);

    /// Adds `effect` to the list of [`Effect`][crate::Effect]<!-- -->s applied to `self`
    ///
    /// The [`Actor`][crate::Actor] will hold a reference on the `effect` until either
    /// [`remove_effect()`][Self::remove_effect()] or [`clear_effects()`][Self::clear_effects()] is
    /// called.
    /// ## `effect`
    /// a [`Effect`][crate::Effect]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_add_effect")]
    fn add_effect<P: IsA<Effect>>(&self, effect: &P);

    /// A convenience function for setting the name of a [`Effect`][crate::Effect]
    /// while adding it to the list of effectss applied to `self`
    ///
    /// This function is the logical equivalent of:
    ///
    ///
    ///
    /// **⚠️ The following code is in C ⚠️**
    ///
    /// ```C
    ///   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
    ///   clutter_actor_add_effect (self, effect);
    /// ```
    /// ## `name`
    /// the name to set on the effect
    /// ## `effect`
    /// a [`Effect`][crate::Effect]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_add_effect_with_name")]
    fn add_effect_with_name<P: IsA<Effect>>(&self, name: &str, effect: &P);

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_add_transition")]
    //fn add_transition(&self, name: &str, transition: /*Ignored*/&Transition);

    //#[cfg(any(feature = "v0_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    //#[doc(alias = "clutter_actor_allocate")]
    //fn allocate(&self, box_: /*Ignored*/&ActorBox);

    //#[cfg(any(feature = "v1_4", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    //#[doc(alias = "clutter_actor_allocate_align_fill")]
    //fn allocate_align_fill(&self, box_: /*Ignored*/&ActorBox, x_align: f64, y_align: f64, x_fill: bool, y_fill: bool);

    /// Allocates `self` taking into account the [`Actor`][crate::Actor]'s
    /// preferred size, but limiting it to the maximum available width
    /// and height provided.
    ///
    /// This function will do the right thing when dealing with the
    /// actor's request mode.
    ///
    /// The implementation of this function is equivalent to:
    ///
    ///
    ///
    /// **⚠️ The following code is in C ⚠️**
    ///
    /// ```C
    ///   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
    ///     {
    ///       clutter_actor_get_preferred_width (self, available_height,
    ///                                          &min_width,
    ///                                          &natural_width);
    ///       width = CLAMP (natural_width, min_width, available_width);
    ///
    ///       clutter_actor_get_preferred_height (self, width,
    ///                                           &min_height,
    ///                                           &natural_height);
    ///       height = CLAMP (natural_height, min_height, available_height);
    ///     }
    ///   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
    ///     {
    ///       clutter_actor_get_preferred_height (self, available_width,
    ///                                           &min_height,
    ///                                           &natural_height);
    ///       height = CLAMP (natural_height, min_height, available_height);
    ///
    ///       clutter_actor_get_preferred_width (self, height,
    ///                                          &min_width,
    ///                                          &natural_width);
    ///       width = CLAMP (natural_width, min_width, available_width);
    ///     }
    ///   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
    ///     {
    ///       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
    ///
    ///       width = CLAMP (natural_width, 0, available_width);
    ///       height = CLAMP (natural_height, 0, available_height);
    ///     }
    ///
    ///   box.x1 = x; box.y1 = y;
    ///   box.x2 = box.x1 + available_width;
    ///   box.y2 = box.y1 + available_height;
    ///   clutter_actor_allocate (self, &box);
    /// ```
    ///
    /// This function can be used by fluid layout managers to allocate
    /// an actor's preferred size without making it bigger than the area
    /// available for the container.
    /// ## `x`
    /// the actor's X coordinate
    /// ## `y`
    /// the actor's Y coordinate
    /// ## `available_width`
    /// the maximum available width, or -1 to use the
    ///  actor's natural width
    /// ## `available_height`
    /// the maximum available height, or -1 to use the
    ///  actor's natural height
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_allocate_available_size")]
    fn allocate_available_size(&self, x: f32, y: f32, available_width: f32, available_height: f32);

    /// Allocates the natural size of `self`.
    ///
    /// This function is a utility call for [`Actor`][crate::Actor] implementations
    /// that allocates the actor's preferred natural size. It can be used
    /// by fixed layout managers (like `ClutterGroup` or so called
    /// 'composite actors') inside the ClutterActor::allocate
    /// implementation to give each child exactly how much space it
    /// requires, regardless of the size of the parent.
    ///
    /// This function is not meant to be used by applications. It is also
    /// not meant to be used outside the implementation of the
    /// `ClutterActorClass.allocate` virtual function.
    /// ## `x`
    /// the actor's X coordinate
    /// ## `y`
    /// the actor's Y coordinate
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_allocate_preferred_size")]
    fn allocate_preferred_size(&self, x: f32, y: f32);

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "clutter_actor_apply_relative_transform_to_point")]
    //fn apply_relative_transform_to_point<P: IsA<Actor>>(&self, ancestor: Option<&P>, point: /*Ignored*/&graphene::Point3D, vertex: /*Ignored*/graphene::Point3D);

    //#[cfg(any(feature = "v0_4", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
    //#[doc(alias = "clutter_actor_apply_transform_to_point")]
    //fn apply_transform_to_point(&self, point: /*Ignored*/&graphene::Point3D, vertex: /*Ignored*/graphene::Point3D);

    //#[cfg(any(feature = "v1_24", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    //#[doc(alias = "clutter_actor_bind_model")]
    //fn bind_model(&self, model: /*Ignored*/Option<&gio::ListModel>, create_child_func: /*Unimplemented*/Fn(/*Ignored*/glib::Object) -> Actor, user_data: /*Unimplemented*/Option<Fundamental: Pointer>);

    //#[cfg(any(feature = "v1_24", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    //#[doc(alias = "clutter_actor_bind_model_with_properties")]
    //fn bind_model_with_properties(&self, model: /*Ignored*/&gio::ListModel, child_type: glib::types::Type, first_model_property: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs);

    /// Clears the list of actions applied to `self`
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_clear_actions")]
    fn clear_actions(&self);

    /// Clears the list of constraints applied to `self`
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_clear_constraints")]
    fn clear_constraints(&self);

    /// Clears the list of effects applied to `self`
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_clear_effects")]
    fn clear_effects(&self);

    /// Determines if `descendant` is contained inside `self` (either as an
    /// immediate child, or as a deeper descendant). If `self` and
    /// `descendant` point to the same actor then it will also return [`true`].
    /// ## `descendant`
    /// A [`Actor`][crate::Actor], possibly contained in `self`
    ///
    /// # Returns
    ///
    /// whether `descendent` is contained within `self`
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_contains")]
    fn contains<P: IsA<Actor>>(&self, descendant: &P) -> bool;

    //#[cfg(any(feature = "v1_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    //#[doc(alias = "clutter_actor_continue_paint")]
    //fn continue_paint(&self, paint_context: /*Ignored*/&PaintContext);

    //#[doc(alias = "clutter_actor_continue_pick")]
    //fn continue_pick(&self, pick_context: /*Ignored*/&PickContext);

    /// Creates a [`pango::Context`][crate::pango::Context] for the given actor. The [`pango::Context`][crate::pango::Context]
    /// is already configured using the appropriate font map, resolution
    /// and font options.
    ///
    /// See also [`pango_context()`][Self::pango_context()].
    ///
    /// # Returns
    ///
    /// the newly created [`pango::Context`][crate::pango::Context].
    ///  Use `g_object_unref()` on the returned value to deallocate its
    ///  resources
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_create_pango_context")]
    fn create_pango_context(&self) -> Option<pango::Context>;

    /// Creates a new [`pango::Layout`][crate::pango::Layout] from the same [`pango::Context`][crate::pango::Context] used
    /// by the [`Actor`][crate::Actor]. The [`pango::Layout`][crate::pango::Layout] is already configured
    /// with the font map, resolution and font options, and the
    /// given `text`.
    ///
    /// If you want to keep around a [`pango::Layout`][crate::pango::Layout] created by this
    /// function you will have to connect to the `signal::Backend::font-changed`
    /// and `signal::Backend::resolution-changed` signals, and call
    /// [`Layout::context_changed()`][crate::pango::Layout::context_changed()] in response to them.
    /// ## `text`
    /// the text to set on the [`pango::Layout`][crate::pango::Layout], or [`None`]
    ///
    /// # Returns
    ///
    /// the newly created [`pango::Layout`][crate::pango::Layout].
    ///  Use `g_object_unref()` when done
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_create_pango_layout")]
    fn create_pango_layout(&self, text: Option<&str>) -> Option<pango::Layout>;

    /// Destroys an actor. When an actor is destroyed, it will break any
    /// references it holds to other objects. If the actor is inside a
    /// container, the actor will be removed.
    ///
    /// When you destroy a container, its children will be destroyed as well.
    #[doc(alias = "clutter_actor_destroy")]
    fn destroy(&self);

    /// Destroys all children of `self`.
    ///
    /// This function releases the reference added by inserting a child
    /// actor in the list of children of `self`, and ensures that the
    /// `signal::Actor::destroy` signal is emitted on each child of the
    /// actor.
    ///
    /// By default, [`Actor`][crate::Actor] will emit the `signal::Actor::destroy` signal
    /// when its reference count drops to 0; the default handler of the
    /// `signal::Actor::destroy` signal will destroy all the children of an
    /// actor. This function ensures that all children are destroyed, instead
    /// of just removed from `self`, unlike [`remove_all_children()`][Self::remove_all_children()]
    /// which will merely release the reference and remove each child.
    ///
    /// Unless you acquired an additional reference on each child of `self`
    /// prior to calling [`remove_all_children()`][Self::remove_all_children()] and want to reuse
    /// the actors, you should use [`destroy_all_children()`][Self::destroy_all_children()] in
    /// order to make sure that children are destroyed and signal handlers
    /// are disconnected even in cases where circular references prevent this
    /// from automatically happening through reference counting alone.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_destroy_all_children")]
    fn destroy_all_children(&self);

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "clutter_actor_event")]
    //fn event(&self, event: /*Ignored*/&Event, capture: bool) -> bool;

    //#[cfg(any(feature = "v0_4", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
    //#[doc(alias = "clutter_actor_get_abs_allocation_vertices")]
    //#[doc(alias = "get_abs_allocation_vertices")]
    //fn abs_allocation_vertices(&self, verts: /*Unimplemented*/FixedArray TypeId { ns_id: 6, id: 2 }; 4);

    //#[doc(alias = "clutter_actor_get_accessible")]
    //#[doc(alias = "get_accessible")]
    //fn accessible(&self) -> /*Ignored*/Option<atk::Object>;

    /// Retrieves the [`Action`][crate::Action] with the given name in the list
    /// of actions applied to `self`
    /// ## `name`
    /// the name of the action to retrieve
    ///
    /// # Returns
    ///
    /// a [`Action`][crate::Action] for the given
    ///  name, or [`None`]. The returned [`Action`][crate::Action] is owned by the
    ///  actor and it should not be unreferenced directly
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_get_action")]
    #[doc(alias = "get_action")]
    fn action(&self, name: &str) -> Option<Action>;

    /// Retrieves the list of actions applied to `self`
    ///
    /// # Returns
    ///
    /// a copy
    ///  of the list of [`Action`][crate::Action]<!-- -->s. The contents of the list are
    ///  owned by the [`Actor`][crate::Actor]. Use `g_list_free()` to free the resources
    ///  allocated by the returned `GList`
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_get_actions")]
    #[doc(alias = "get_actions")]
    fn actions(&self) -> Vec<Action>;

    //#[cfg(any(feature = "v0_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    //#[doc(alias = "clutter_actor_get_allocation_box")]
    //#[doc(alias = "get_allocation_box")]
    //fn allocation_box(&self, box_: /*Ignored*/ActorBox);

    /// Retrieves the color set using [`set_background_color()`][Self::set_background_color()].
    ///
    /// # Returns
    ///
    ///
    /// ## `color`
    /// return location for a [`Color`][crate::Color]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_background_color")]
    #[doc(alias = "get_background_color")]
    fn background_color(&self) -> Color;

    /// Retrieves the actor at the given `index_` inside the list of
    /// children of `self`.
    /// ## `index_`
    /// the position in the list of children
    ///
    /// # Returns
    ///
    /// a pointer to a [`Actor`][crate::Actor], or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_child_at_index")]
    #[doc(alias = "get_child_at_index")]
    fn child_at_index(&self, index_: i32) -> Option<Actor>;

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_actor_get_child_transform")]
    //#[doc(alias = "get_child_transform")]
    //fn child_transform(&self, transform: /*Ignored*/graphene::Matrix);

    /// Retrieves the list of children of `self`.
    ///
    /// # Returns
    ///
    /// A newly
    ///  allocated `GList` of [`Actor`][crate::Actor]<!-- -->s. Use `g_list_free()` when
    ///  done.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[cfg(any(not(feature = "v0_4"), feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(not(feature = "v0_4"))))]
    #[doc(alias = "clutter_actor_get_children")]
    #[doc(alias = "get_children")]
    fn children(&self) -> Vec<Actor>;

    /// Gets the clip area for `self`, if any is set.
    ///
    /// # Returns
    ///
    ///
    /// ## `xoff`
    /// return location for the X offset of
    ///  the clip rectangle, or [`None`]
    ///
    /// ## `yoff`
    /// return location for the Y offset of
    ///  the clip rectangle, or [`None`]
    ///
    /// ## `width`
    /// return location for the width of
    ///  the clip rectangle, or [`None`]
    ///
    /// ## `height`
    /// return location for the height of
    ///  the clip rectangle, or [`None`]
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_get_clip")]
    #[doc(alias = "get_clip")]
    fn clip(&self) -> (f32, f32, f32, f32);

    /// Retrieves the value set using [`set_clip_to_allocation()`][Self::set_clip_to_allocation()]
    ///
    /// # Returns
    ///
    /// [`true`] if the [`Actor`][crate::Actor] is clipped to its allocation
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_get_clip_to_allocation")]
    #[doc(alias = "get_clip_to_allocation")]
    fn is_clip_to_allocation(&self) -> bool;

    /// Retrieves the [`Constraint`][crate::Constraint] with the given name in the list
    /// of constraints applied to `self`
    /// ## `name`
    /// the name of the constraint to retrieve
    ///
    /// # Returns
    ///
    /// a [`Constraint`][crate::Constraint] for the given
    ///  name, or [`None`]. The returned [`Constraint`][crate::Constraint] is owned by the
    ///  actor and it should not be unreferenced directly
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_get_constraint")]
    #[doc(alias = "get_constraint")]
    fn constraint(&self, name: &str) -> Option<Constraint>;

    /// Retrieves the list of constraints applied to `self`
    ///
    /// # Returns
    ///
    /// a copy
    ///  of the list of [`Constraint`][crate::Constraint]<!-- -->s. The contents of the list are
    ///  owned by the [`Actor`][crate::Actor]. Use `g_list_free()` to free the resources
    ///  allocated by the returned `GList`
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_get_constraints")]
    #[doc(alias = "get_constraints")]
    fn constraints(&self) -> Vec<Constraint>;

    /// Retrieves the contents of `self`.
    ///
    /// # Returns
    ///
    /// a pointer to the [`Content`][crate::Content] instance,
    ///  or [`None`] if none was set
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_content")]
    #[doc(alias = "get_content")]
    fn content(&self) -> Option<Content>;

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_get_content_box")]
    //#[doc(alias = "get_content_box")]
    //fn content_box(&self, box_: /*Ignored*/ActorBox);

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_get_content_gravity")]
    //#[doc(alias = "get_content_gravity")]
    //fn content_gravity(&self) -> /*Ignored*/ContentGravity;

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_actor_get_content_repeat")]
    //#[doc(alias = "get_content_repeat")]
    //fn content_repeat(&self) -> /*Ignored*/ContentRepeat;

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_get_content_scaling_filters")]
    //#[doc(alias = "get_content_scaling_filters")]
    //fn content_scaling_filters(&self) -> (/*Ignored*/ScalingFilter, /*Ignored*/ScalingFilter);

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_get_default_paint_volume")]
    //#[doc(alias = "get_default_paint_volume")]
    //fn default_paint_volume(&self) -> /*Ignored*/Option<PaintVolume>;

    /// Retrieves the delay that should be applied when tweening animatable
    /// properties.
    ///
    /// # Returns
    ///
    /// a delay, in milliseconds
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_easing_delay")]
    #[doc(alias = "get_easing_delay")]
    fn easing_delay(&self) -> u32;

    /// Retrieves the duration of the tweening for animatable
    /// properties of `self` for the current easing state.
    ///
    /// # Returns
    ///
    /// the duration of the tweening, in milliseconds
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_easing_duration")]
    #[doc(alias = "get_easing_duration")]
    fn easing_duration(&self) -> u32;

    /// Retrieves the easing mode for the tweening of animatable properties
    /// of `self` for the current easing state.
    ///
    /// # Returns
    ///
    /// an easing mode
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_easing_mode")]
    #[doc(alias = "get_easing_mode")]
    fn easing_mode(&self) -> AnimationMode;

    /// Retrieves the [`Effect`][crate::Effect] with the given name in the list
    /// of effects applied to `self`
    /// ## `name`
    /// the name of the effect to retrieve
    ///
    /// # Returns
    ///
    /// a [`Effect`][crate::Effect] for the given
    ///  name, or [`None`]. The returned [`Effect`][crate::Effect] is owned by the
    ///  actor and it should not be unreferenced directly
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_get_effect")]
    #[doc(alias = "get_effect")]
    fn effect(&self, name: &str) -> Option<Effect>;

    /// Retrieves the [`Effect`][crate::Effect]<!-- -->s applied on `self`, if any
    ///
    /// # Returns
    ///
    /// a list
    ///  of [`Effect`][crate::Effect]<!-- -->s, or [`None`]. The elements of the returned
    ///  list are owned by Clutter and they should not be freed. You should
    ///  free the returned list using `g_list_free()` when done
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_get_effects")]
    #[doc(alias = "get_effects")]
    fn effects(&self) -> Vec<Effect>;

    /// Retrieves the first child of `self`.
    ///
    /// The returned pointer is only valid until the scene graph changes; it
    /// is not safe to modify the list of children of `self` while iterating
    /// it.
    ///
    /// # Returns
    ///
    /// a pointer to a [`Actor`][crate::Actor], or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_first_child")]
    #[doc(alias = "get_first_child")]
    fn first_child(&self) -> Option<Actor>;

    /// This function gets the fixed position of the actor, if set. If there
    /// is no fixed position set, this function returns [`false`] and doesn't set
    /// the x and y coordinates.
    ///
    /// # Returns
    ///
    /// [`true`] if the fixed position is set, [`false`] if it isn't
    ///
    /// ## `x`
    /// return location for the X coordinate, or [`None`]
    ///
    /// ## `y`
    /// return location for the Y coordinate, or [`None`]
    #[doc(alias = "clutter_actor_get_fixed_position")]
    #[doc(alias = "get_fixed_position")]
    fn fixed_position(&self) -> Option<(f32, f32)>;

    /// Checks whether an actor has a fixed position set (and will thus be
    /// unaffected by any layout manager).
    ///
    /// # Returns
    ///
    /// [`true`] if the fixed position is set on the actor
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_get_fixed_position_set")]
    #[doc(alias = "get_fixed_position_set")]
    fn is_fixed_position_set(&self) -> bool;

    /// Retrieves the flags set on `self`
    ///
    /// # Returns
    ///
    /// a bitwise or of [`ActorFlags`][crate::ActorFlags] or 0
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_get_flags")]
    #[doc(alias = "get_flags")]
    fn flags(&self) -> ActorFlags;

    /// Retrieves the height of a [`Actor`][crate::Actor].
    ///
    /// If the actor has a valid allocation, this function will return the
    /// height of the allocated area given to the actor.
    ///
    /// If the actor does not have a valid allocation, this function will
    /// return the actor's natural height, that is the preferred height of
    /// the actor.
    ///
    /// If you care whether you get the preferred height or the height that
    /// has been assigned to the actor, you should probably call a different
    /// function like `clutter_actor_get_allocation_box()` to retrieve the
    /// allocated size or [`preferred_height()`][Self::preferred_height()] to retrieve the
    /// preferred height.
    ///
    /// If an actor has a fixed height, for instance a height that has been
    /// assigned using [`set_height()`][Self::set_height()], the height returned will
    /// be the same value.
    ///
    /// # Returns
    ///
    /// the height of the actor, in pixels
    #[doc(alias = "clutter_actor_get_height")]
    #[doc(alias = "get_height")]
    fn height(&self) -> f32;

    /// Retrieves the last child of `self`.
    ///
    /// The returned pointer is only valid until the scene graph changes; it
    /// is not safe to modify the list of children of `self` while iterating
    /// it.
    ///
    /// # Returns
    ///
    /// a pointer to a [`Actor`][crate::Actor], or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_last_child")]
    #[doc(alias = "get_last_child")]
    fn last_child(&self) -> Option<Actor>;

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_get_layout_manager")]
    //#[doc(alias = "get_layout_manager")]
    //fn layout_manager(&self) -> /*Ignored*/Option<LayoutManager>;

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_get_margin")]
    //#[doc(alias = "get_margin")]
    //fn margin(&self, margin: /*Ignored*/Margin);

    /// Retrieves the bottom margin of a [`Actor`][crate::Actor].
    ///
    /// # Returns
    ///
    /// the bottom margin
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_margin_bottom")]
    #[doc(alias = "get_margin_bottom")]
    fn margin_bottom(&self) -> f32;

    /// Retrieves the left margin of a [`Actor`][crate::Actor].
    ///
    /// # Returns
    ///
    /// the left margin
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_margin_left")]
    #[doc(alias = "get_margin_left")]
    fn margin_left(&self) -> f32;

    /// Retrieves the right margin of a [`Actor`][crate::Actor].
    ///
    /// # Returns
    ///
    /// the right margin
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_margin_right")]
    #[doc(alias = "get_margin_right")]
    fn margin_right(&self) -> f32;

    /// Retrieves the top margin of a [`Actor`][crate::Actor].
    ///
    /// # Returns
    ///
    /// the top margin
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_margin_top")]
    #[doc(alias = "get_margin_top")]
    fn margin_top(&self) -> f32;

    /// Retrieves the number of children of `self`.
    ///
    /// # Returns
    ///
    /// the number of children of an actor
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_n_children")]
    #[doc(alias = "get_n_children")]
    fn n_children(&self) -> i32;

    /// Retrieves the name of `self`.
    ///
    /// # Returns
    ///
    /// the name of the actor, or [`None`]. The returned string is
    ///  owned by the actor and should not be modified or freed.
    #[doc(alias = "clutter_actor_get_name")]
    #[doc(alias = "get_name")]
    fn name(&self) -> Option<glib::GString>;

    /// Retrieves the sibling of `self` that comes after it in the list
    /// of children of `self`'s parent.
    ///
    /// The returned pointer is only valid until the scene graph changes; it
    /// is not safe to modify the list of children of `self` while iterating
    /// it.
    ///
    /// # Returns
    ///
    /// a pointer to a [`Actor`][crate::Actor], or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_next_sibling")]
    #[doc(alias = "get_next_sibling")]
    fn next_sibling(&self) -> Option<Actor>;

    //#[cfg(any(feature = "v1_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    //#[doc(alias = "clutter_actor_get_offscreen_redirect")]
    //#[doc(alias = "get_offscreen_redirect")]
    //fn offscreen_redirect(&self) -> /*Ignored*/OffscreenRedirect;

    /// Retrieves the opacity value of an actor, as set by
    /// [`set_opacity()`][Self::set_opacity()].
    ///
    /// For retrieving the absolute opacity of the actor inside a paint
    /// virtual function, see [`paint_opacity()`][Self::paint_opacity()].
    ///
    /// # Returns
    ///
    /// the opacity of the actor
    #[doc(alias = "clutter_actor_get_opacity")]
    #[doc(alias = "get_opacity")]
    fn opacity(&self) -> u8;

    /// See [`set_opacity_override()`][Self::set_opacity_override()]
    ///
    /// # Returns
    ///
    /// the override value for the actor's opacity, or -1 if no override
    ///  is set.
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    #[doc(alias = "clutter_actor_get_opacity_override")]
    #[doc(alias = "get_opacity_override")]
    fn opacity_override(&self) -> i32;

    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //#[doc(alias = "clutter_actor_get_paint_box")]
    //#[doc(alias = "get_paint_box")]
    //fn paint_box(&self, box_: /*Ignored*/ActorBox) -> bool;

    /// Retrieves the absolute opacity of the actor, as it appears on the stage.
    ///
    /// This function traverses the hierarchy chain and composites the opacity of
    /// the actor with that of its parents.
    ///
    /// This function is intended for subclasses to use in the paint virtual
    /// function, to paint themselves with the correct opacity.
    ///
    /// # Returns
    ///
    /// The actor opacity value.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_get_paint_opacity")]
    #[doc(alias = "get_paint_opacity")]
    fn paint_opacity(&self) -> u8;

    /// Retrieves the 'paint' visibility of an actor recursively checking for non
    /// visible parents.
    ///
    /// This is by definition the same as `CLUTTER_ACTOR_IS_MAPPED`.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor is visible and will be painted.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_get_paint_visibility")]
    #[doc(alias = "get_paint_visibility")]
    fn is_paint_visibility(&self) -> bool;

    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //#[doc(alias = "clutter_actor_get_paint_volume")]
    //#[doc(alias = "get_paint_volume")]
    //fn paint_volume(&self) -> /*Ignored*/Option<PaintVolume>;

    /// Retrieves the [`pango::Context`][crate::pango::Context] for `self`. The actor's [`pango::Context`][crate::pango::Context]
    /// is already configured using the appropriate font map, resolution
    /// and font options.
    ///
    /// Unlike [`create_pango_context()`][Self::create_pango_context()], this context is owend
    /// by the [`Actor`][crate::Actor] and it will be updated each time the options
    /// stored by the [`Backend`][crate::Backend] change.
    ///
    /// You can use the returned [`pango::Context`][crate::pango::Context] to create a [`pango::Layout`][crate::pango::Layout]
    /// and render text using `cogl_pango_show_layout()` to reuse the
    /// glyphs cache also used by Clutter.
    ///
    /// # Returns
    ///
    /// the [`pango::Context`][crate::pango::Context] for a [`Actor`][crate::Actor].
    ///  The returned [`pango::Context`][crate::pango::Context] is owned by the actor and should not be
    ///  unreferenced by the application code
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_get_pango_context")]
    #[doc(alias = "get_pango_context")]
    fn pango_context(&self) -> Option<pango::Context>;

    /// Retrieves the parent of `self`.
    ///
    /// # Returns
    ///
    /// The [`Actor`][crate::Actor] parent, or [`None`]
    ///  if no parent is set
    #[doc(alias = "clutter_actor_get_parent")]
    #[doc(alias = "get_parent")]
    fn parent(&self) -> Option<Actor>;

    /// Retrieves the coordinates of the `property::Actor::pivot-point`.
    ///
    /// # Returns
    ///
    ///
    /// ## `pivot_x`
    /// return location for the normalized X
    ///  coordinate of the pivot point, or [`None`]
    ///
    /// ## `pivot_y`
    /// return location for the normalized Y
    ///  coordinate of the pivot point, or [`None`]
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_get_pivot_point")]
    #[doc(alias = "get_pivot_point")]
    fn pivot_point(&self) -> (f32, f32);

    /// Retrieves the Z component of the `property::Actor::pivot-point`.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_get_pivot_point_z")]
    #[doc(alias = "get_pivot_point_z")]
    fn pivot_point_z(&self) -> f32;

    /// This function tries to "do what you mean" and tell you where the
    /// actor is, prior to any transformations. Retrieves the fixed
    /// position of an actor in pixels, if one has been set; otherwise, if
    /// the allocation is valid, returns the actor's allocated position;
    /// otherwise, returns 0,0.
    ///
    /// The returned position is in pixels.
    ///
    /// # Returns
    ///
    ///
    /// ## `x`
    /// return location for the X coordinate, or [`None`]
    ///
    /// ## `y`
    /// return location for the Y coordinate, or [`None`]
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_get_position")]
    #[doc(alias = "get_position")]
    fn position(&self) -> (f32, f32);

    /// Computes the requested minimum and natural heights for an actor,
    /// or if they are already computed, returns the cached values.
    ///
    /// An actor may not get its request - depending on the layout
    /// manager that's in effect.
    ///
    /// A request should not incorporate the actor's scale or translation;
    /// those transformations do not affect layout, only rendering.
    /// ## `for_width`
    /// available width to assume in computing desired height,
    ///  or a negative value to indicate that no width is defined
    ///
    /// # Returns
    ///
    ///
    /// ## `min_height_p`
    /// return location for minimum height,
    ///  or [`None`]
    ///
    /// ## `natural_height_p`
    /// return location for natural
    ///  height, or [`None`]
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_get_preferred_height")]
    #[doc(alias = "get_preferred_height")]
    fn preferred_height(&self, for_width: f32) -> (f32, f32);

    /// Computes the preferred minimum and natural size of an actor, taking into
    /// account the actor's geometry management (either height-for-width
    /// or width-for-height).
    ///
    /// The width and height used to compute the preferred height and preferred
    /// width are the actor's natural ones.
    ///
    /// If you need to control the height for the preferred width, or the width for
    /// the preferred height, you should use [`preferred_width()`][Self::preferred_width()]
    /// and [`preferred_height()`][Self::preferred_height()], and check the actor's preferred
    /// geometry management using the `property::Actor::request-mode` property.
    ///
    /// # Returns
    ///
    ///
    /// ## `min_width_p`
    /// return location for the minimum
    ///  width, or [`None`]
    ///
    /// ## `min_height_p`
    /// return location for the minimum
    ///  height, or [`None`]
    ///
    /// ## `natural_width_p`
    /// return location for the natural
    ///  width, or [`None`]
    ///
    /// ## `natural_height_p`
    /// return location for the natural
    ///  height, or [`None`]
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_get_preferred_size")]
    #[doc(alias = "get_preferred_size")]
    fn preferred_size(&self) -> (f32, f32, f32, f32);

    /// Computes the requested minimum and natural widths for an actor,
    /// optionally depending on the specified height, or if they are
    /// already computed, returns the cached values.
    ///
    /// An actor may not get its request - depending on the layout
    /// manager that's in effect.
    ///
    /// A request should not incorporate the actor's scaleor translation;
    /// those transformations do not affect layout, only rendering.
    /// ## `for_height`
    /// available height when computing the preferred width,
    ///  or a negative value to indicate that no height is defined
    ///
    /// # Returns
    ///
    ///
    /// ## `min_width_p`
    /// return location for minimum width,
    ///  or [`None`]
    ///
    /// ## `natural_width_p`
    /// return location for the natural
    ///  width, or [`None`]
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_get_preferred_width")]
    #[doc(alias = "get_preferred_width")]
    fn preferred_width(&self, for_height: f32) -> (f32, f32);

    /// Retrieves the sibling of `self` that comes before it in the list
    /// of children of `self`'s parent.
    ///
    /// The returned pointer is only valid until the scene graph changes; it
    /// is not safe to modify the list of children of `self` while iterating
    /// it.
    ///
    /// # Returns
    ///
    /// a pointer to a [`Actor`][crate::Actor], or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_previous_sibling")]
    #[doc(alias = "get_previous_sibling")]
    fn previous_sibling(&self) -> Option<Actor>;

    /// Checks whether `self` is marked as reactive.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor is reactive
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_get_reactive")]
    #[doc(alias = "get_reactive")]
    fn is_reactive(&self) -> bool;

    /// Retrieves the geometry request mode of `self`
    ///
    /// # Returns
    ///
    /// the request mode for the actor
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "clutter_actor_get_request_mode")]
    #[doc(alias = "get_request_mode")]
    fn request_mode(&self) -> RequestMode;

    /// Retrieves the resource scale for this actor.
    ///
    /// The resource scale refers to the scale the actor should use for its resources.
    /// For example if an actor draws a a picture of size 100 x 100 in the stage
    /// coordinate space, it should use a texture of twice the size (i.e. 200 x 200)
    /// if the resource scale is 2.
    ///
    /// The resource scale is determined by calculating the highest `ClutterStageView`
    /// scale the actor will get painted on.
    ///
    /// Note that the scale returned by this function is only guaranteed to be
    /// correct when queried during the paint cycle, in all other cases this
    /// function will only return a best guess. If your implementation really
    /// needs to get a resource scale outside of the paint cycle, make sure to
    /// subscribe to the "resource-scale-changed" signal to get notified about
    /// the new, correct resource scale before painting.
    ///
    /// Also avoid getting the resource scale for actors that are not attached
    /// to a stage. There's no sane way for Clutter to guess which `ClutterStageView`
    /// the actor is going to be painted on, so you'll probably end up receiving
    /// the "resource-scale-changed" signal and having to rebuild your resources.
    ///
    /// The best guess this function may return is usually just the last resource
    /// scale the actor got painted with. If this resource scale couldn't be found
    /// because the actor was never painted so far or Clutter was unable to
    /// determine its position and size, this function will return the resource
    /// scale of a parent.
    ///
    /// # Returns
    ///
    /// The resource scale the actor should use for its textures
    #[doc(alias = "clutter_actor_get_resource_scale")]
    #[doc(alias = "get_resource_scale")]
    fn resource_scale(&self) -> f32;

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_actor_get_rotation_angle")]
    //#[doc(alias = "get_rotation_angle")]
    //fn rotation_angle(&self, axis: /*Ignored*/RotateAxis) -> f64;

    /// Retrieves an actors scale factors.
    ///
    /// # Returns
    ///
    ///
    /// ## `scale_x`
    /// Location to store horizontal
    ///  scale factor, or [`None`].
    ///
    /// ## `scale_y`
    /// Location to store vertical
    ///  scale factor, or [`None`].
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "clutter_actor_get_scale")]
    #[doc(alias = "get_scale")]
    fn scale(&self) -> (f64, f64);

    /// Retrieves the scaling factor along the Z axis, as set using
    /// [`set_scale_z()`][Self::set_scale_z()].
    ///
    /// # Returns
    ///
    /// the scaling factor along the Z axis
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_get_scale_z")]
    #[doc(alias = "get_scale_z")]
    fn scale_z(&self) -> f64;

    /// This function tries to "do what you mean" and return
    /// the size an actor will have. If the actor has a valid
    /// allocation, the allocation will be returned; otherwise,
    /// the actors natural size request will be returned.
    ///
    /// If you care whether you get the request vs. the allocation, you
    /// should probably call a different function like
    /// `clutter_actor_get_allocation_box()` or
    /// [`preferred_width()`][Self::preferred_width()].
    ///
    /// # Returns
    ///
    ///
    /// ## `width`
    /// return location for the width, or [`None`].
    ///
    /// ## `height`
    /// return location for the height, or [`None`].
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "clutter_actor_get_size")]
    #[doc(alias = "get_size")]
    fn size(&self) -> (f32, f32);

    /// Retrieves the [`Stage`][crate::Stage] where `self` is contained.
    ///
    /// # Returns
    ///
    /// the stage
    ///  containing the actor, or [`None`]
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_get_stage")]
    #[doc(alias = "get_stage")]
    fn stage(&self) -> Option<Stage>;

    /// Retrieves the value set using [`set_text_direction()`][Self::set_text_direction()]
    ///
    /// If no text direction has been previously set, the default text
    /// direction, as returned by [`default_text_direction()`][crate::default_text_direction()], will
    /// be returned instead
    ///
    /// # Returns
    ///
    /// the [`TextDirection`][crate::TextDirection] for the actor
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "clutter_actor_get_text_direction")]
    #[doc(alias = "get_text_direction")]
    fn text_direction(&self) -> TextDirection;

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_actor_get_transform")]
    //#[doc(alias = "get_transform")]
    //fn transform(&self, transform: /*Ignored*/graphene::Matrix);

    //#[doc(alias = "clutter_actor_get_transformed_extents")]
    //#[doc(alias = "get_transformed_extents")]
    //fn transformed_extents(&self, rect: /*Ignored*/graphene::Rect);

    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //#[doc(alias = "clutter_actor_get_transformed_paint_volume")]
    //#[doc(alias = "get_transformed_paint_volume")]
    //fn transformed_paint_volume<P: IsA<Actor>>(&self, relative_to_ancestor: &P) -> /*Ignored*/Option<PaintVolume>;

    /// Gets the absolute position of an actor, in pixels relative to the stage.
    ///
    /// # Returns
    ///
    ///
    /// ## `x`
    /// return location for the X coordinate, or [`None`]
    ///
    /// ## `y`
    /// return location for the Y coordinate, or [`None`]
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_get_transformed_position")]
    #[doc(alias = "get_transformed_position")]
    fn transformed_position(&self) -> (f32, f32);

    /// Gets the absolute size of an actor in pixels, taking into account the
    /// scaling factors.
    ///
    /// If the actor has a valid allocation, the allocated size will be used.
    /// If the actor has not a valid allocation then the preferred size will
    /// be transformed and returned.
    ///
    /// If you want the transformed allocation, see
    /// `clutter_actor_get_abs_allocation_vertices()` instead.
    ///
    /// When the actor (or one of its ancestors) is rotated around the
    /// X or Y axis, it no longer appears as on the stage as a rectangle, but
    /// as a generic quadrangle; in that case this function returns the size
    /// of the smallest rectangle that encapsulates the entire quad. Please
    /// note that in this case no assumptions can be made about the relative
    /// position of this envelope to the absolute position of the actor, as
    /// returned by [`transformed_position()`][Self::transformed_position()]; if you need this
    /// information, you need to use `clutter_actor_get_abs_allocation_vertices()`
    /// to get the coords of the actual quadrangle.
    ///
    /// # Returns
    ///
    ///
    /// ## `width`
    /// return location for the width, or [`None`]
    ///
    /// ## `height`
    /// return location for the height, or [`None`]
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_get_transformed_size")]
    #[doc(alias = "get_transformed_size")]
    fn transformed_size(&self) -> (f32, f32);

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_get_transition")]
    //#[doc(alias = "get_transition")]
    //fn transition(&self, name: &str) -> /*Ignored*/Option<Transition>;

    /// Retrieves the translation set using [`set_translation()`][Self::set_translation()].
    ///
    /// # Returns
    ///
    ///
    /// ## `translate_x`
    /// return location for the X component
    ///  of the translation, or [`None`]
    ///
    /// ## `translate_y`
    /// return location for the Y component
    ///  of the translation, or [`None`]
    ///
    /// ## `translate_z`
    /// return location for the Z component
    ///  of the translation, or [`None`]
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_get_translation")]
    #[doc(alias = "get_translation")]
    fn translation(&self) -> (f32, f32, f32);

    /// Retrieves the width of a [`Actor`][crate::Actor].
    ///
    /// If the actor has a valid allocation, this function will return the
    /// width of the allocated area given to the actor.
    ///
    /// If the actor does not have a valid allocation, this function will
    /// return the actor's natural width, that is the preferred width of
    /// the actor.
    ///
    /// If you care whether you get the preferred width or the width that
    /// has been assigned to the actor, you should probably call a different
    /// function like `clutter_actor_get_allocation_box()` to retrieve the
    /// allocated size or [`preferred_width()`][Self::preferred_width()] to retrieve the
    /// preferred width.
    ///
    /// If an actor has a fixed width, for instance a width that has been
    /// assigned using [`set_width()`][Self::set_width()], the width returned will
    /// be the same value.
    ///
    /// # Returns
    ///
    /// the width of the actor, in pixels
    #[doc(alias = "clutter_actor_get_width")]
    #[doc(alias = "get_width")]
    fn width(&self) -> f32;

    /// Retrieves the X coordinate of a [`Actor`][crate::Actor].
    ///
    /// This function tries to "do what you mean", by returning the
    /// correct value depending on the actor's state.
    ///
    /// If the actor has a valid allocation, this function will return
    /// the X coordinate of the origin of the allocation box.
    ///
    /// If the actor has any fixed coordinate set using [`set_x()`][Self::set_x()],
    /// [`set_position()`][Self::set_position()], this function will return that coordinate.
    ///
    /// If both the allocation and a fixed position are missing, this function
    /// will return 0.
    ///
    /// # Returns
    ///
    /// the X coordinate, in pixels, ignoring any
    ///  transformation (i.e. scaling, rotation)
    #[doc(alias = "clutter_actor_get_x")]
    #[doc(alias = "get_x")]
    fn x(&self) -> f32;

    /// Retrieves the horizontal alignment policy set using
    /// [`set_x_align()`][Self::set_x_align()].
    ///
    /// # Returns
    ///
    /// the horizontal alignment policy.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_x_align")]
    #[doc(alias = "get_x_align")]
    fn x_align(&self) -> ActorAlign;

    /// Retrieves the value set with [`set_x_expand()`][Self::set_x_expand()].
    ///
    /// See also: [`needs_expand()`][Self::needs_expand()]
    ///
    /// # Returns
    ///
    /// [`true`] if the actor has been set to expand
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_get_x_expand")]
    #[doc(alias = "get_x_expand")]
    fn is_x_expand(&self) -> bool;

    /// Retrieves the Y coordinate of a [`Actor`][crate::Actor].
    ///
    /// This function tries to "do what you mean", by returning the
    /// correct value depending on the actor's state.
    ///
    /// If the actor has a valid allocation, this function will return
    /// the Y coordinate of the origin of the allocation box.
    ///
    /// If the actor has any fixed coordinate set using [`set_y()`][Self::set_y()],
    /// [`set_position()`][Self::set_position()], this function will return that coordinate.
    ///
    /// If both the allocation and a fixed position are missing, this function
    /// will return 0.
    ///
    /// # Returns
    ///
    /// the Y coordinate, in pixels, ignoring any
    ///  transformation (i.e. scaling, rotation)
    #[doc(alias = "clutter_actor_get_y")]
    #[doc(alias = "get_y")]
    fn y(&self) -> f32;

    /// Retrieves the vertical alignment policy set using
    /// [`set_y_align()`][Self::set_y_align()].
    ///
    /// # Returns
    ///
    /// the vertical alignment policy.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_get_y_align")]
    #[doc(alias = "get_y_align")]
    fn y_align(&self) -> ActorAlign;

    /// Retrieves the value set with [`set_y_expand()`][Self::set_y_expand()].
    ///
    /// See also: [`needs_expand()`][Self::needs_expand()]
    ///
    /// # Returns
    ///
    /// [`true`] if the actor has been set to expand
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_get_y_expand")]
    #[doc(alias = "get_y_expand")]
    fn is_y_expand(&self) -> bool;

    /// Retrieves the actor's position on the Z axis.
    ///
    /// # Returns
    ///
    /// the position on the Z axis.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_get_z_position")]
    #[doc(alias = "get_z_position")]
    fn z_position(&self) -> f32;

    /// Sets the key focus of the [`Stage`][crate::Stage] including `self`
    /// to this [`Actor`][crate::Actor].
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_grab_key_focus")]
    fn grab_key_focus(&self);

    #[doc(alias = "clutter_actor_has_accessible")]
    fn has_accessible(&self) -> bool;

    /// Returns whether the actor has any actions applied.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor has any actions,
    ///  [`false`] otherwise
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_has_actions")]
    fn has_actions(&self) -> bool;

    /// Checks if the actor has an up-to-date allocation assigned to
    /// it. This means that the actor should have an allocation: it's
    /// visible and has a parent. It also means that there is no
    /// outstanding relayout request in progress for the actor or its
    /// children (There might be other outstanding layout requests in
    /// progress that will cause the actor to get a new allocation
    /// when the stage is laid out, however).
    ///
    /// If this function returns [`false`], then the actor will normally
    /// be allocated before it is next drawn on the screen.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor has an up-to-date allocation
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_has_allocation")]
    fn has_allocation(&self) -> bool;

    /// Determines whether the actor has a clip area set or not.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor has a clip area set.
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "clutter_actor_has_clip")]
    fn has_clip(&self) -> bool;

    /// Returns whether the actor has any constraints applied.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor has any constraints,
    ///  [`false`] otherwise
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_has_constraints")]
    fn has_constraints(&self) -> bool;

    #[doc(alias = "clutter_actor_has_damage")]
    fn has_damage(&self) -> bool;

    /// Returns whether the actor has any effects applied.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor has any effects,
    ///  [`false`] otherwise
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_has_effects")]
    fn has_effects(&self) -> bool;

    /// Checks whether `self` is the [`Actor`][crate::Actor] that has key focus
    ///
    /// # Returns
    ///
    /// [`true`] if the actor has key focus, and [`false`] otherwise
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_has_key_focus")]
    fn has_key_focus(&self) -> bool;

    /// Returns whether a [`Actor`][crate::Actor] or any parent actors have mapped clones
    /// that are clone-painting `self`.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor has mapped clones, [`false`] otherwise
    #[doc(alias = "clutter_actor_has_mapped_clones")]
    fn has_mapped_clones(&self) -> bool;

    /// Asks the actor's implementation whether it may contain overlapping
    /// primitives.
    ///
    /// For example; Clutter may use this to determine whether the painting
    /// should be redirected to an offscreen buffer to correctly implement
    /// the opacity property.
    ///
    /// Custom actors can override the default response by implementing the
    /// `ClutterActorClass.has_overlaps()` virtual function. See
    /// `clutter_actor_set_offscreen_redirect()` for more information.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor may have overlapping primitives, and
    ///  [`false`] otherwise
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "clutter_actor_has_overlaps")]
    fn has_overlaps(&self) -> bool;

    /// Checks whether an actor contains the pointer of a
    /// [`InputDevice`][crate::InputDevice]
    ///
    /// # Returns
    ///
    /// [`true`] if the actor contains the pointer, and
    ///  [`false`] otherwise
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "clutter_actor_has_pointer")]
    fn has_pointer(&self) -> bool;

    #[doc(alias = "clutter_actor_has_transitions")]
    fn has_transitions(&self) -> bool;

    /// Flags an actor to be hidden. A hidden actor will not be
    /// rendered on the stage.
    ///
    /// Actors are visible by default.
    ///
    /// If this function is called on an actor without a parent, the
    /// `property::Actor::show-on-set-parent` property will be set to [`false`]
    /// as a side-effect.
    #[doc(alias = "clutter_actor_hide")]
    fn hide(&self);

    /// Increases the culling inhibitor counter. Inhibiting culling
    /// forces the actor to be painted even when outside the visible
    /// bounds of the stage view.
    ///
    /// This is usually necessary when an actor is being painted on
    /// another paint context.
    ///
    /// Pair with [`uninhibit_culling()`][Self::uninhibit_culling()] when the actor doesn't
    /// need to be painted anymore.
    #[doc(alias = "clutter_actor_inhibit_culling")]
    fn inhibit_culling(&self);

    /// Inserts `child` into the list of children of `self`, above another
    /// child of `self` or, if `sibling` is [`None`], above all the children
    /// of `self`.
    ///
    /// This function will acquire a reference on `child` that will only
    /// be released when calling [`remove_child()`][Self::remove_child()].
    ///
    /// This function will not take into consideration the `property::Actor::depth`
    /// of `child`.
    ///
    /// This function will emit the `signal::Container::actor-added` signal
    /// on `self`.
    /// ## `child`
    /// a [`Actor`][crate::Actor]
    /// ## `sibling`
    /// a child of `self`, or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_insert_child_above")]
    fn insert_child_above<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>);

    /// Inserts `child` into the list of children of `self`, using the
    /// given `index_`. If `index_` is greater than the number of children
    /// in `self`, or is less than 0, then the new child is added at the end.
    ///
    /// This function will acquire a reference on `child` that will only
    /// be released when calling [`remove_child()`][Self::remove_child()].
    ///
    /// This function will not take into consideration the `property::Actor::depth`
    /// of `child`.
    ///
    /// This function will emit the `signal::Container::actor-added` signal
    /// on `self`.
    /// ## `child`
    /// a [`Actor`][crate::Actor]
    /// ## `index_`
    /// the index
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_insert_child_at_index")]
    fn insert_child_at_index<P: IsA<Actor>>(&self, child: &P, index_: i32);

    /// Inserts `child` into the list of children of `self`, below another
    /// child of `self` or, if `sibling` is [`None`], below all the children
    /// of `self`.
    ///
    /// This function will acquire a reference on `child` that will only
    /// be released when calling [`remove_child()`][Self::remove_child()].
    ///
    /// This function will not take into consideration the `property::Actor::depth`
    /// of `child`.
    ///
    /// This function will emit the `signal::Container::actor-added` signal
    /// on `self`.
    /// ## `child`
    /// a [`Actor`][crate::Actor]
    /// ## `sibling`
    /// a child of `self`, or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_insert_child_below")]
    fn insert_child_below<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>);

    /// Invalidates the cached paint volume of `self`. This is needed for
    /// implementations overriding the `ClutterActorClass.get_paint_volume()`
    /// virtual function and has to be called every time the paint volume
    /// returned by that function would change.
    #[doc(alias = "clutter_actor_invalidate_paint_volume")]
    fn invalidate_paint_volume(&self);

    /// Invalidate the cached transformation matrix of `self`.
    /// This is needed for implementations overriding the `apply_transform()`
    /// vfunc and has to be called if the matrix returned by `apply_transform()`
    /// would change.
    #[doc(alias = "clutter_actor_invalidate_transform")]
    fn invalidate_transform(&self);

    //#[doc(alias = "clutter_actor_is_effectively_on_stage_view")]
    //fn is_effectively_on_stage_view(&self, view: /*Ignored*/&StageView) -> bool;

    /// Checks whether `self` is being currently painted by a `ClutterClone`
    ///
    /// This function is useful only inside implementations of the
    /// `ClutterActorClass.paint()` virtual function.
    ///
    /// This function should not be used by applications
    ///
    /// # Returns
    ///
    /// [`true`] if the [`Actor`][crate::Actor] is currently being painted
    ///  by a `ClutterClone`, and [`false`] otherwise
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_is_in_clone_paint")]
    fn is_in_clone_paint(&self) -> bool;

    /// Checks whether a [`Actor`][crate::Actor] has been set as mapped.
    ///
    /// See also `CLUTTER_ACTOR_IS_MAPPED` and `property::Actor::mapped`
    ///
    /// # Returns
    ///
    /// [`true`] if the actor is mapped
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    #[doc(alias = "clutter_actor_is_mapped")]
    fn is_mapped(&self) -> bool;

    /// Checks whether a [`Actor`][crate::Actor] is realized.
    ///
    /// See also `CLUTTER_ACTOR_IS_REALIZED` and `property::Actor::realized`.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor is realized
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    #[doc(alias = "clutter_actor_is_realized")]
    fn is_realized(&self) -> bool;

    /// Checks whether any rotation is applied to the actor.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor is rotated.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_is_rotated")]
    fn is_rotated(&self) -> bool;

    /// Checks whether the actor is scaled in either dimension.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor is scaled.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_is_scaled")]
    fn is_scaled(&self) -> bool;

    /// Checks whether an actor is marked as visible.
    ///
    /// See also `CLUTTER_ACTOR_IS_VISIBLE` and `property::Actor::visible`.
    ///
    /// # Returns
    ///
    /// [`true`] if the actor visible
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    #[doc(alias = "clutter_actor_is_visible")]
    fn is_visible(&self) -> bool;

    /// Sets the [`ActorFlags::MAPPED`][crate::ActorFlags::MAPPED] flag on the actor and possibly maps
    /// and realizes its children if they are visible. Does nothing if the
    /// actor is not visible.
    ///
    /// Calling this function is strongly discouraged: the default
    /// implementation of `ClutterActorClass.map()` will map all the children
    /// of an actor when mapping its parent.
    ///
    /// When overriding map, it is mandatory to chain up to the parent
    /// implementation.
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_map")]
    fn map(&self);

    /// Moves an actor by the specified distance relative to its current
    /// position in pixels.
    ///
    /// This function modifies the fixed position of an actor and thus removes
    /// it from any layout management. Another way to move an actor is with an
    /// additional translation, using [`set_translation()`][Self::set_translation()].
    /// ## `dx`
    /// Distance to move Actor on X axis.
    /// ## `dy`
    /// Distance to move Actor on Y axis.
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "clutter_actor_move_by")]
    fn move_by(&self, dx: f32, dy: f32);

    /// Checks whether an actor, or any of its children, is set to expand
    /// horizontally or vertically.
    ///
    /// This function should only be called by layout managers that can
    /// assign extra space to their children.
    ///
    /// If you want to know whether the actor was explicitly set to expand,
    /// use [`is_x_expand()`][Self::is_x_expand()] or [`is_y_expand()`][Self::is_y_expand()].
    /// ## `orientation`
    /// the direction of expansion
    ///
    /// # Returns
    ///
    /// [`true`] if the actor should expand
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_needs_expand")]
    fn needs_expand(&self, orientation: Orientation) -> bool;

    //#[doc(alias = "clutter_actor_paint")]
    //fn paint(&self, paint_context: /*Ignored*/&PaintContext);

    //#[doc(alias = "clutter_actor_peek_stage_views")]
    //fn peek_stage_views(&self) -> /*Ignored*/Vec<StageView>;

    //#[doc(alias = "clutter_actor_pick")]
    //fn pick(&self, pick_context: /*Ignored*/&PickContext);

    //#[doc(alias = "clutter_actor_pick_box")]
    //fn pick_box(&self, pick_context: /*Ignored*/&PickContext, box_: /*Ignored*/&ActorBox);

    //#[doc(alias = "clutter_actor_pick_frame_clock")]
    //fn pick_frame_clock<P: IsA<Actor>>(&self, out_actor: Option<&P>) -> /*Ignored*/Option<FrameClock>;

    /// Queues up a redraw of an actor and any children. The redraw occurs
    /// once the main loop becomes idle (after the current batch of events
    /// has been processed, roughly).
    ///
    /// Applications rarely need to call this, as redraws are handled
    /// automatically by modification functions.
    ///
    /// This function will not do anything if `self` is not visible, or
    /// if the actor is inside an invisible part of the scenegraph.
    ///
    /// Also be aware that painting is a NOP for actors with an opacity of
    /// 0
    ///
    /// When you are implementing a custom actor you must queue a redraw
    /// whenever some private state changes that will affect painting or
    /// picking of your actor.
    #[doc(alias = "clutter_actor_queue_redraw")]
    fn queue_redraw(&self);

    /// Queues a redraw on `self` limited to a specific, actor-relative
    /// rectangular area.
    ///
    /// If `clip` is [`None`] this function is equivalent to
    /// [`queue_redraw()`][Self::queue_redraw()].
    /// ## `clip`
    /// a rectangular clip region, or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_queue_redraw_with_clip")]
    fn queue_redraw_with_clip(&self, clip: Option<&cairo::RectangleInt>);

    /// Indicates that the actor's size request or other layout-affecting
    /// properties may have changed. This function is used inside [`Actor`][crate::Actor]
    /// subclass implementations, not by applications directly.
    ///
    /// Queueing a new layout automatically queues a redraw as well.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_queue_relayout")]
    fn queue_relayout(&self);

    /// Realization informs the actor that it is attached to a stage. It
    /// can use this to allocate resources if it wanted to delay allocation
    /// until it would be rendered. However it is perfectly acceptable for
    /// an actor to create resources before being realized because Clutter
    /// only ever has a single rendering context so that actor is free to
    /// be moved from one stage to another.
    ///
    /// This function does nothing if the actor is already realized.
    ///
    /// Because a realized actor must have realized parent actors, calling
    /// [`realize()`][Self::realize()] will also realize all parents of the actor.
    ///
    /// This function does not realize child actors, except in the special
    /// case that realizing the stage, when the stage is visible, will
    /// suddenly map (and thus realize) the children of the stage.
    ///
    /// # Deprecated since 1.16
    ///
    /// Actors are automatically realized, and nothing
    ///  requires explicit realization.
    #[cfg_attr(feature = "v1_16", deprecated = "Since 1.16")]
    #[doc(alias = "clutter_actor_realize")]
    fn realize(&self);

    /// Removes `action` from the list of actions applied to `self`
    ///
    /// The reference held by `self` on the [`Action`][crate::Action] will be released
    /// ## `action`
    /// a [`Action`][crate::Action]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_remove_action")]
    fn remove_action<P: IsA<Action>>(&self, action: &P);

    /// Removes the [`Action`][crate::Action] with the given name from the list
    /// of actions applied to `self`
    /// ## `name`
    /// the name of the action to remove
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_remove_action_by_name")]
    fn remove_action_by_name(&self, name: &str);

    /// Removes all children of `self`.
    ///
    /// This function releases the reference added by inserting a child actor
    /// in the list of children of `self`.
    ///
    /// If the reference count of a child drops to zero, the child will be
    /// destroyed. If you want to ensure the destruction of all the children
    /// of `self`, use [`destroy_all_children()`][Self::destroy_all_children()].
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_remove_all_children")]
    fn remove_all_children(&self);

    /// Removes all transitions associated to `self`.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_remove_all_transitions")]
    fn remove_all_transitions(&self);

    /// Removes `child` from the children of `self`.
    ///
    /// This function will release the reference added by
    /// [`add_child()`][Self::add_child()], so if you want to keep using `child`
    /// you will have to acquire a referenced on it before calling this
    /// function.
    ///
    /// This function will emit the `signal::Container::actor-removed`
    /// signal on `self`.
    /// ## `child`
    /// a [`Actor`][crate::Actor]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_remove_child")]
    fn remove_child<P: IsA<Actor>>(&self, child: &P);

    /// Removes clip area from `self`.
    #[doc(alias = "clutter_actor_remove_clip")]
    fn remove_clip(&self);

    /// Removes `constraint` from the list of constraints applied to `self`
    ///
    /// The reference held by `self` on the [`Constraint`][crate::Constraint] will be released
    /// ## `constraint`
    /// a [`Constraint`][crate::Constraint]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_remove_constraint")]
    fn remove_constraint<P: IsA<Constraint>>(&self, constraint: &P);

    /// Removes the [`Constraint`][crate::Constraint] with the given name from the list
    /// of constraints applied to `self`
    /// ## `name`
    /// the name of the constraint to remove
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_remove_constraint_by_name")]
    fn remove_constraint_by_name(&self, name: &str);

    /// Removes `effect` from the list of effects applied to `self`
    ///
    /// The reference held by `self` on the [`Effect`][crate::Effect] will be released
    /// ## `effect`
    /// a [`Effect`][crate::Effect]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_remove_effect")]
    fn remove_effect<P: IsA<Effect>>(&self, effect: &P);

    /// Removes the [`Effect`][crate::Effect] with the given name from the list
    /// of effects applied to `self`
    /// ## `name`
    /// the name of the effect to remove
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_remove_effect_by_name")]
    fn remove_effect_by_name(&self, name: &str);

    /// Removes the transition stored inside a [`Actor`][crate::Actor] using `name`
    /// identifier.
    ///
    /// If the transition is currently in progress, it will be stopped.
    ///
    /// This function releases the reference acquired when the transition
    /// was added to the [`Actor`][crate::Actor].
    /// ## `name`
    /// the name of the transition to remove
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_remove_transition")]
    fn remove_transition(&self, name: &str);

    /// Replaces `old_child` with `new_child` in the list of children of `self`.
    /// ## `old_child`
    /// the child of `self` to replace
    /// ## `new_child`
    /// the [`Actor`][crate::Actor] to replace `old_child`
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_replace_child")]
    fn replace_child<P: IsA<Actor>, Q: IsA<Actor>>(&self, old_child: &P, new_child: &Q);

    /// Restores the easing state as it was prior to a call to
    /// [`save_easing_state()`][Self::save_easing_state()].
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_restore_easing_state")]
    fn restore_easing_state(&self);

    /// Saves the current easing state for animatable properties, and creates
    /// a new state with the default values for easing mode and duration.
    ///
    /// New transitions created after calling this function will inherit the
    /// duration, easing mode, and delay of the new easing state; this also
    /// applies to transitions modified in flight.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_save_easing_state")]
    fn save_easing_state(&self);

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_set_allocation")]
    //fn set_allocation(&self, box_: /*Ignored*/&ActorBox);

    /// Sets the background color of a [`Actor`][crate::Actor].
    ///
    /// The background color will be used to cover the whole allocation of the
    /// actor. The default background color of an actor is transparent.
    ///
    /// To check whether an actor has a background color, you can use the
    /// `property::Actor::background-color-set` actor property.
    ///
    /// The `property::Actor::background-color` property is animatable.
    /// ## `color`
    /// a [`Color`][crate::Color], or [`None`] to unset a previously
    ///  set color
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_background_color")]
    fn set_background_color(&self, color: Option<&Color>);

    /// Sets `child` to be above `sibling` in the list of children of `self`.
    ///
    /// If `sibling` is [`None`], `child` will be the new last child of `self`.
    ///
    /// This function is logically equivalent to removing `child` and using
    /// [`insert_child_above()`][Self::insert_child_above()], but it will not emit signals
    /// or change state on `child`.
    /// ## `child`
    /// a [`Actor`][crate::Actor] child of `self`
    /// ## `sibling`
    /// a [`Actor`][crate::Actor] child of `self`, or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_child_above_sibling")]
    fn set_child_above_sibling<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>);

    /// Changes the index of `child` in the list of children of `self`.
    ///
    /// This function is logically equivalent to removing `child` and
    /// calling [`insert_child_at_index()`][Self::insert_child_at_index()], but it will not
    /// emit signals or change state on `child`.
    /// ## `child`
    /// a [`Actor`][crate::Actor] child of `self`
    /// ## `index_`
    /// the new index for `child`
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_child_at_index")]
    fn set_child_at_index<P: IsA<Actor>>(&self, child: &P, index_: i32);

    /// Sets `child` to be below `sibling` in the list of children of `self`.
    ///
    /// If `sibling` is [`None`], `child` will be the new first child of `self`.
    ///
    /// This function is logically equivalent to removing `self` and using
    /// [`insert_child_below()`][Self::insert_child_below()], but it will not emit signals
    /// or change state on `child`.
    /// ## `child`
    /// a [`Actor`][crate::Actor] child of `self`
    /// ## `sibling`
    /// a [`Actor`][crate::Actor] child of `self`, or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_child_below_sibling")]
    fn set_child_below_sibling<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>);

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_actor_set_child_transform")]
    //fn set_child_transform(&self, transform: /*Ignored*/Option<&graphene::Matrix>);

    /// Sets clip area for `self`. The clip area is always computed from the
    /// upper left corner of the actor.
    /// ## `xoff`
    /// X offset of the clip rectangle
    /// ## `yoff`
    /// Y offset of the clip rectangle
    /// ## `width`
    /// Width of the clip rectangle
    /// ## `height`
    /// Height of the clip rectangle
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_set_clip")]
    fn set_clip(&self, xoff: f32, yoff: f32, width: f32, height: f32);

    /// Sets whether `self` should be clipped to the same size as its
    /// allocation
    /// ## `clip_set`
    /// [`true`] to apply a clip tracking the allocation
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "clutter_actor_set_clip_to_allocation")]
    fn set_clip_to_allocation(&self, clip_set: bool);

    /// Sets the contents of a [`Actor`][crate::Actor].
    /// ## `content`
    /// a [`Content`][crate::Content], or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_content")]
    fn set_content<P: IsA<Content>>(&self, content: Option<&P>);

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_set_content_gravity")]
    //fn set_content_gravity(&self, gravity: /*Ignored*/ContentGravity);

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_actor_set_content_repeat")]
    //fn set_content_repeat(&self, repeat: /*Ignored*/ContentRepeat);

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_set_content_scaling_filters")]
    //fn set_content_scaling_filters(&self, min_filter: /*Ignored*/ScalingFilter, mag_filter: /*Ignored*/ScalingFilter);

    /// Sets the delay that should be applied before tweening animatable
    /// properties.
    /// ## `msecs`
    /// the delay before the start of the tweening, in milliseconds
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_easing_delay")]
    fn set_easing_delay(&self, msecs: u32);

    /// Sets the duration of the tweening for animatable properties
    /// of `self` for the current easing state.
    /// ## `msecs`
    /// the duration of the easing, or [`None`]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_easing_duration")]
    fn set_easing_duration(&self, msecs: u32);

    /// Sets the easing mode for the tweening of animatable properties
    /// of `self`.
    /// ## `mode`
    /// an easing mode, excluding [`AnimationMode::CustomMode`][crate::AnimationMode::CustomMode]
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_easing_mode")]
    fn set_easing_mode(&self, mode: AnimationMode);

    /// Sets whether an actor has a fixed position set (and will thus be
    /// unaffected by any layout manager).
    /// ## `is_set`
    /// whether to use fixed position
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "clutter_actor_set_fixed_position_set")]
    fn set_fixed_position_set(&self, is_set: bool);

    /// Sets `flags` on `self`
    ///
    /// This function will emit notifications for the changed properties
    /// ## `flags`
    /// the flags to set
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_set_flags")]
    fn set_flags(&self, flags: ActorFlags);

    /// Forces a height on an actor, causing the actor's preferred width
    /// and height (if any) to be ignored.
    ///
    /// If `height` is -1 the actor will use its preferred height instead of
    /// overriding it, i.e. you can "unset" the height with -1.
    ///
    /// This function sets both the minimum and natural size of the actor.
    /// ## `height`
    /// Requested new height for the actor, in pixels, or -1
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "clutter_actor_set_height")]
    fn set_height(&self, height: f32);

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_set_layout_manager")]
    //fn set_layout_manager(&self, manager: /*Ignored*/Option<&LayoutManager>);

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //#[doc(alias = "clutter_actor_set_margin")]
    //fn set_margin(&self, margin: /*Ignored*/&Margin);

    /// Sets the margin from the bottom of a [`Actor`][crate::Actor].
    ///
    /// The `property::Actor::margin-bottom` property is animatable.
    /// ## `margin`
    /// the bottom margin
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_margin_bottom")]
    fn set_margin_bottom(&self, margin: f32);

    /// Sets the margin from the left of a [`Actor`][crate::Actor].
    ///
    /// The `property::Actor::margin-left` property is animatable.
    /// ## `margin`
    /// the left margin
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_margin_left")]
    fn set_margin_left(&self, margin: f32);

    /// Sets the margin from the right of a [`Actor`][crate::Actor].
    ///
    /// The `property::Actor::margin-right` property is animatable.
    /// ## `margin`
    /// the right margin
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_margin_right")]
    fn set_margin_right(&self, margin: f32);

    /// Sets the margin from the top of a [`Actor`][crate::Actor].
    ///
    /// The `property::Actor::margin-top` property is animatable.
    /// ## `margin`
    /// the top margin
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_margin_top")]
    fn set_margin_top(&self, margin: f32);

    /// Sets the given name to `self`. The name can be used to identify
    /// a [`Actor`][crate::Actor].
    /// ## `name`
    /// Textual tag to apply to actor
    #[doc(alias = "clutter_actor_set_name")]
    fn set_name(&self, name: &str);

    //#[cfg(any(feature = "v1_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    //#[doc(alias = "clutter_actor_set_offscreen_redirect")]
    //fn set_offscreen_redirect(&self, redirect: /*Ignored*/OffscreenRedirect);

    /// Sets the actor's opacity, with zero being completely transparent and
    /// 255 (0xff) being fully opaque.
    ///
    /// The `property::Actor::opacity` property is animatable.
    /// ## `opacity`
    /// New opacity value for the actor.
    #[doc(alias = "clutter_actor_set_opacity")]
    fn set_opacity(&self, opacity: u8);

    /// Allows overriding the calculated paint opacity (as returned by
    /// [`paint_opacity()`][Self::paint_opacity()]). This is used internally by
    /// ClutterClone and ClutterOffscreenEffect, and should be used by
    /// actors that need to mimic those.
    ///
    /// In almost all cases this should not used by applications.
    /// ## `opacity`
    /// the override opacity value, or -1 to reset
    #[doc(alias = "clutter_actor_set_opacity_override")]
    fn set_opacity_override(&self, opacity: i32);

    /// Sets the position of the `property::Actor::pivot-point` around which the
    /// scaling and rotation transformations occur.
    ///
    /// The pivot point's coordinates are in normalized space, with the (0, 0)
    /// point being the top left corner of the actor, and the (1, 1) point being
    /// the bottom right corner.
    /// ## `pivot_x`
    /// the normalized X coordinate of the pivot point
    /// ## `pivot_y`
    /// the normalized Y coordinate of the pivot point
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_set_pivot_point")]
    fn set_pivot_point(&self, pivot_x: f32, pivot_y: f32);

    /// Sets the component on the Z axis of the `property::Actor::pivot-point` around
    /// which the scaling and rotation transformations occur.
    ///
    /// The `pivot_z` value is expressed as a distance along the Z axis.
    /// ## `pivot_z`
    /// the Z coordinate of the actor's pivot point
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_set_pivot_point_z")]
    fn set_pivot_point_z(&self, pivot_z: f32);

    /// Sets the actor's fixed position in pixels relative to any parent
    /// actor.
    ///
    /// If a layout manager is in use, this position will override the
    /// layout manager and force a fixed position.
    /// ## `x`
    /// New left position of actor in pixels.
    /// ## `y`
    /// New top position of actor in pixels.
    #[doc(alias = "clutter_actor_set_position")]
    fn set_position(&self, x: f32, y: f32);

    /// Sets `self` as reactive. Reactive actors will receive events.
    /// ## `reactive`
    /// whether the actor should be reactive to events
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_set_reactive")]
    fn set_reactive(&self, reactive: bool);

    /// Sets the geometry request mode of `self`.
    ///
    /// The `mode` determines the order for invoking
    /// [`preferred_width()`][Self::preferred_width()] and
    /// [`preferred_height()`][Self::preferred_height()]
    /// ## `mode`
    /// the request mode
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "clutter_actor_set_request_mode")]
    fn set_request_mode(&self, mode: RequestMode);

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_actor_set_rotation_angle")]
    //fn set_rotation_angle(&self, axis: /*Ignored*/RotateAxis, angle: f64);

    /// Scales an actor with the given factors.
    ///
    /// The scale transformation is relative the the `property::Actor::pivot-point`.
    ///
    /// The `property::Actor::scale-x` and `property::Actor::scale-y` properties are
    /// animatable.
    /// ## `scale_x`
    /// double factor to scale actor by horizontally.
    /// ## `scale_y`
    /// double factor to scale actor by vertically.
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "clutter_actor_set_scale")]
    fn set_scale(&self, scale_x: f64, scale_y: f64);

    /// Scales an actor on the Z axis by the given `scale_z` factor.
    ///
    /// The scale transformation is relative the the `property::Actor::pivot-point`.
    ///
    /// The `property::Actor::scale-z` property is animatable.
    /// ## `scale_z`
    /// the scaling factor along the Z axis
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_set_scale_z")]
    fn set_scale_z(&self, scale_z: f64);

    /// Sets the actor's size request in pixels. This overrides any
    /// "normal" size request the actor would have. For example
    /// a text actor might normally request the size of the text;
    /// this function would force a specific size instead.
    ///
    /// If `width` and/or `height` are -1 the actor will use its
    /// "normal" size request instead of overriding it, i.e.
    /// you can "unset" the size with -1.
    ///
    /// This function sets or unsets both the minimum and natural size.
    /// ## `width`
    /// New width of actor in pixels, or -1
    /// ## `height`
    /// New height of actor in pixels, or -1
    #[doc(alias = "clutter_actor_set_size")]
    fn set_size(&self, width: f32, height: f32);

    /// Sets the [`TextDirection`][crate::TextDirection] for an actor
    ///
    /// The passed text direction must not be [`TextDirection::Default`][crate::TextDirection::Default]
    ///
    /// If `self` implements [`Container`][crate::Container] then this function will recurse
    /// inside all the children of `self` (including the internal ones).
    ///
    /// Composite actors not implementing [`Container`][crate::Container], or actors requiring
    /// special handling when the text direction changes, should connect to
    /// the `GObject::notify` signal for the `property::Actor::text-direction` property
    /// ## `text_dir`
    /// the text direction for `self`
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "clutter_actor_set_text_direction")]
    fn set_text_direction(&self, text_dir: TextDirection);

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clutter_actor_set_transform")]
    //fn set_transform(&self, transform: /*Ignored*/Option<&graphene::Matrix>);

    /// Sets an additional translation transformation on a [`Actor`][crate::Actor],
    /// relative to the `property::Actor::pivot-point`.
    /// ## `translate_x`
    /// the translation along the X axis
    /// ## `translate_y`
    /// the translation along the Y axis
    /// ## `translate_z`
    /// the translation along the Z axis
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_set_translation")]
    fn set_translation(&self, translate_x: f32, translate_y: f32, translate_z: f32);

    /// Forces a width on an actor, causing the actor's preferred width
    /// and height (if any) to be ignored.
    ///
    /// If `width` is -1 the actor will use its preferred width request
    /// instead of overriding it, i.e. you can "unset" the width with -1.
    ///
    /// This function sets both the minimum and natural size of the actor.
    /// ## `width`
    /// Requested new width for the actor, in pixels, or -1
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "clutter_actor_set_width")]
    fn set_width(&self, width: f32);

    /// Sets the actor's X coordinate, relative to its parent, in pixels.
    ///
    /// Overrides any layout manager and forces a fixed position for
    /// the actor.
    ///
    /// The `property::Actor::x` property is animatable.
    /// ## `x`
    /// the actor's position on the X axis
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_set_x")]
    fn set_x(&self, x: f32);

    /// Sets the horizontal alignment policy of a [`Actor`][crate::Actor], in case the
    /// actor received extra horizontal space.
    ///
    /// See also the `property::Actor::x-align` property.
    /// ## `x_align`
    /// the horizontal alignment policy
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_x_align")]
    fn set_x_align(&self, x_align: ActorAlign);

    /// Sets whether a [`Actor`][crate::Actor] should expand horizontally; this means
    /// that layout manager should allocate extra space for the actor, if
    /// possible.
    ///
    /// Setting an actor to expand will also make all its parent expand, so
    /// that it's possible to build an actor tree and only set this flag on
    /// its leaves and not on every single actor.
    /// ## `expand`
    /// whether the actor should expand horizontally
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_set_x_expand")]
    fn set_x_expand(&self, expand: bool);

    /// Sets the actor's Y coordinate, relative to its parent, in pixels.#
    ///
    /// Overrides any layout manager and forces a fixed position for
    /// the actor.
    ///
    /// The `property::Actor::y` property is animatable.
    /// ## `y`
    /// the actor's position on the Y axis
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_set_y")]
    fn set_y(&self, y: f32);

    /// Sets the vertical alignment policy of a [`Actor`][crate::Actor], in case the
    /// actor received extra vertical space.
    ///
    /// See also the `property::Actor::y-align` property.
    /// ## `y_align`
    /// the vertical alignment policy
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "clutter_actor_set_y_align")]
    fn set_y_align(&self, y_align: ActorAlign);

    /// Sets whether a [`Actor`][crate::Actor] should expand horizontally; this means
    /// that layout manager should allocate extra space for the actor, if
    /// possible.
    ///
    /// Setting an actor to expand will also make all its parent expand, so
    /// that it's possible to build an actor tree and only set this flag on
    /// its leaves and not on every single actor.
    /// ## `expand`
    /// whether the actor should expand vertically
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_set_y_expand")]
    fn set_y_expand(&self, expand: bool);

    /// Sets the actor's position on the Z axis.
    ///
    /// See `property::Actor::z-position`.
    /// ## `z_position`
    /// the position on the Z axis
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clutter_actor_set_z_position")]
    fn set_z_position(&self, z_position: f32);

    //#[doc(alias = "clutter_actor_should_pick")]
    //fn should_pick(&self, pick_context: /*Ignored*/&PickContext) -> bool;

    /// Flags an actor to be displayed. An actor that isn't shown will not
    /// be rendered on the stage.
    ///
    /// Actors are visible by default.
    ///
    /// If this function is called on an actor without a parent, the
    /// `property::Actor::show-on-set-parent` will be set to [`true`] as a side
    /// effect.
    #[doc(alias = "clutter_actor_show")]
    fn show(&self);

    /// This function translates screen coordinates (`x`, `y`) to
    /// coordinates relative to the actor. For example, it can be used to translate
    /// screen events from global screen coordinates into actor-local coordinates.
    ///
    /// The conversion can fail, notably if the transform stack results in the
    /// actor being projected on the screen as a mere line.
    ///
    /// The conversion should not be expected to be pixel-perfect due to the
    /// nature of the operation. In general the error grows when the skewing
    /// of the actor rectangle on screen increases.
    ///
    /// This function can be computationally intensive.
    ///
    /// This function only works when the allocation is up-to-date, i.e. inside of
    /// the `ClutterActorClass.paint()` implementation
    /// ## `x`
    /// x screen coordinate of the point to unproject
    /// ## `y`
    /// y screen coordinate of the point to unproject
    ///
    /// # Returns
    ///
    /// [`true`] if conversion was successful.
    ///
    /// ## `x_out`
    /// return location for the unprojected x coordinance
    ///
    /// ## `y_out`
    /// return location for the unprojected y coordinance
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "clutter_actor_transform_stage_point")]
    fn transform_stage_point(&self, x: f32, y: f32) -> Option<(f32, f32)>;

    /// Decreases the culling inhibitor counter. See [`inhibit_culling()`][Self::inhibit_culling()]
    /// for when inhibit culling is necessary.
    ///
    /// Calling this function without a matching call to
    /// [`inhibit_culling()`][Self::inhibit_culling()] is a programming error.
    #[doc(alias = "clutter_actor_uninhibit_culling")]
    fn uninhibit_culling(&self);

    /// Unsets the [`ActorFlags::MAPPED`][crate::ActorFlags::MAPPED] flag on the actor and possibly
    /// unmaps its children if they were mapped.
    ///
    /// Calling this function is not encouraged: the default [`Actor`][crate::Actor]
    /// implementation of `ClutterActorClass.unmap()` will also unmap any
    /// eventual children by default when their parent is unmapped.
    ///
    /// When overriding `ClutterActorClass.unmap()`, it is mandatory to
    /// chain up to the parent implementation.
    ///
    /// It is important to note that the implementation of the
    /// `ClutterActorClass.unmap()` virtual function may be called after
    /// the `ClutterActorClass.destroy()` or the `GObjectClass.dispose()`
    /// implementation, but it is guaranteed to be called before the
    /// `GObjectClass.finalize()` implementation.
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_unmap")]
    fn unmap(&self);

    /// Unrealization informs the actor that it may be being destroyed or
    /// moved to another stage. The actor may want to destroy any
    /// underlying graphics resources at this point. However it is
    /// perfectly acceptable for it to retain the resources until the actor
    /// is destroyed because Clutter only ever uses a single rendering
    /// context and all of the graphics resources are valid on any stage.
    ///
    /// Because mapped actors must be realized, actors may not be
    /// unrealized if they are mapped. This function hides the actor to be
    /// sure it isn't mapped, an application-visible side effect that you
    /// may not be expecting.
    ///
    /// This function should not be called by application code.
    ///
    /// This function should not really be in the public API, because
    /// there isn't a good reason to call it. ClutterActor will already
    /// unrealize things for you when it's important to do so.
    ///
    /// If you were using [`unrealize()`][Self::unrealize()] in a dispose
    /// implementation, then don't, just chain up to ClutterActor's
    /// dispose.
    ///
    /// If you were using [`unrealize()`][Self::unrealize()] to implement
    /// unrealizing children of your container, then don't, ClutterActor
    /// will already take care of that.
    ///
    /// # Deprecated since 1.16
    ///
    /// Actors are automatically unrealized, and nothing
    ///  requires explicit realization.
    #[cfg_attr(feature = "v1_16", deprecated = "Since 1.16")]
    #[doc(alias = "clutter_actor_unrealize")]
    fn unrealize(&self);

    /// Unsets `flags` on `self`
    ///
    /// This function will emit notifications for the changed properties
    /// ## `flags`
    /// the flags to unset
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clutter_actor_unset_flags")]
    fn unset_flags(&self, flags: ActorFlags);

    /// Adds a [`Action`][crate::Action] to the actor
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn set_actions<P: IsA<Action>>(&self, actions: Option<&P>);

    //#[cfg(any(feature = "v0_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    //fn allocation(&self) -> /*Ignored*/Option<ActorBox>;

    /// Whether the `property::Actor::background-color` property has been set.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "background-color-set")]
    fn is_background_color_set(&self) -> bool;

    /// Whether the `property::Actor::child-transform` property is set.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "child-transform-set")]
    fn is_child_transform_set(&self) -> bool;

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clip-rect")]
    //fn clip_rect(&self) -> /*Ignored*/Option<graphene::Rect>;

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "clip-rect")]
    //fn set_clip_rect(&self, clip_rect: /*Ignored*/Option<&graphene::Rect>);

    /// Whether the clip region should track the allocated area
    /// of the actor.
    ///
    /// This property is ignored if a clip area has been explicitly
    /// set using [`set_clip()`][Self::set_clip()].
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clip-to-allocation")]
    fn get_property_clip_to_allocation(&self) -> bool;

    /// Whether the clip region should track the allocated area
    /// of the actor.
    ///
    /// This property is ignored if a clip area has been explicitly
    /// set using [`set_clip()`][Self::set_clip()].
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clip-to-allocation")]
    fn set_property_clip_to_allocation(&self, clip_to_allocation: bool);

    /// Adds a [`Constraint`][crate::Constraint] to the actor
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn set_constraints<P: IsA<Constraint>>(&self, constraints: Option<&P>);

    /// Adds [`Effect`][crate::Effect] to the list of effects be applied on a [`Actor`][crate::Actor]
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn set_effect<P: IsA<Effect>>(&self, effect: Option<&P>);

    /// The fixed X position of the actor in pixels.
    ///
    /// Writing this property sets `property::Actor::fixed-position-set`
    /// property as well, as a side effect
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "fixed-x")]
    fn fixed_x(&self) -> f32;

    /// The fixed X position of the actor in pixels.
    ///
    /// Writing this property sets `property::Actor::fixed-position-set`
    /// property as well, as a side effect
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "fixed-x")]
    fn set_fixed_x(&self, fixed_x: f32);

    /// The fixed Y position of the actor in pixels.
    ///
    /// Writing this property sets the `property::Actor::fixed-position-set`
    /// property as well, as a side effect
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "fixed-y")]
    fn fixed_y(&self) -> f32;

    /// The fixed Y position of the actor in pixels.
    ///
    /// Writing this property sets the `property::Actor::fixed-position-set`
    /// property as well, as a side effect
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "fixed-y")]
    fn set_fixed_y(&self, fixed_y: f32);

    /// Whether the actor has the `property::Actor::clip` property set or not
    #[doc(alias = "has-clip")]
    fn get_property_has_clip(&self) -> bool;

    /// Height of the actor (in pixels). If written, forces the minimum and
    /// natural size request of the actor to the given height. If read, returns
    /// the allocated height if available, otherwise the height request.
    ///
    /// The `property::Actor::height` property is animatable.
    fn set_property_height(&self, height: f32);

    //#[doc(alias = "magnification-filter")]
    //fn magnification_filter(&self) -> /*Ignored*/ScalingFilter;

    //#[doc(alias = "magnification-filter")]
    //fn set_magnification_filter(&self, magnification_filter: /*Ignored*/ScalingFilter);

    /// Whether the actor is mapped (will be painted when the stage
    /// to which it belongs is mapped)
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn get_property_mapped(&self) -> bool;

    /// A forced minimum height request for the actor, in pixels
    ///
    /// Writing this property sets the `property::Actor::min-height-set` property
    /// as well, as a side effect. This property overrides the usual height
    /// request of the actor.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-height")]
    fn min_height(&self) -> f32;

    /// A forced minimum height request for the actor, in pixels
    ///
    /// Writing this property sets the `property::Actor::min-height-set` property
    /// as well, as a side effect. This property overrides the usual height
    /// request of the actor.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-height")]
    fn set_min_height(&self, min_height: f32);

    /// This flag controls whether the `property::Actor::min-height` property
    /// is used
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-height-set")]
    fn is_min_height_set(&self) -> bool;

    /// This flag controls whether the `property::Actor::min-height` property
    /// is used
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-height-set")]
    fn set_min_height_set(&self, min_height_set: bool);

    /// A forced minimum width request for the actor, in pixels
    ///
    /// Writing this property sets the `property::Actor::min-width-set` property
    /// as well, as a side effect.
    ///
    /// This property overrides the usual width request of the actor.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-width")]
    fn min_width(&self) -> f32;

    /// A forced minimum width request for the actor, in pixels
    ///
    /// Writing this property sets the `property::Actor::min-width-set` property
    /// as well, as a side effect.
    ///
    /// This property overrides the usual width request of the actor.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-width")]
    fn set_min_width(&self, min_width: f32);

    /// This flag controls whether the `property::Actor::min-width` property
    /// is used
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-width-set")]
    fn is_min_width_set(&self) -> bool;

    /// This flag controls whether the `property::Actor::min-width` property
    /// is used
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-width-set")]
    fn set_min_width_set(&self, min_width_set: bool);

    //#[doc(alias = "minification-filter")]
    //fn minification_filter(&self) -> /*Ignored*/ScalingFilter;

    //#[doc(alias = "minification-filter")]
    //fn set_minification_filter(&self, minification_filter: /*Ignored*/ScalingFilter);

    /// A forced natural height request for the actor, in pixels
    ///
    /// Writing this property sets the `property::Actor::natural-height-set`
    /// property as well, as a side effect. This property overrides the
    /// usual height request of the actor
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-height")]
    fn natural_height(&self) -> f32;

    /// A forced natural height request for the actor, in pixels
    ///
    /// Writing this property sets the `property::Actor::natural-height-set`
    /// property as well, as a side effect. This property overrides the
    /// usual height request of the actor
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-height")]
    fn set_natural_height(&self, natural_height: f32);

    /// This flag controls whether the `property::Actor::natural-height` property
    /// is used
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-height-set")]
    fn is_natural_height_set(&self) -> bool;

    /// This flag controls whether the `property::Actor::natural-height` property
    /// is used
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-height-set")]
    fn set_natural_height_set(&self, natural_height_set: bool);

    /// A forced natural width request for the actor, in pixels
    ///
    /// Writing this property sets the `property::Actor::natural-width-set`
    /// property as well, as a side effect. This property overrides the
    /// usual width request of the actor
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-width")]
    fn natural_width(&self) -> f32;

    /// A forced natural width request for the actor, in pixels
    ///
    /// Writing this property sets the `property::Actor::natural-width-set`
    /// property as well, as a side effect. This property overrides the
    /// usual width request of the actor
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-width")]
    fn set_natural_width(&self, natural_width: f32);

    /// This flag controls whether the `property::Actor::natural-width` property
    /// is used
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-width-set")]
    fn is_natural_width_set(&self) -> bool;

    /// This flag controls whether the `property::Actor::natural-width` property
    /// is used
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-width-set")]
    fn set_natural_width_set(&self, natural_width_set: bool);

    /// Whether the actor has been realized
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn get_property_realized(&self) -> bool;

    /// Request mode for the [`Actor`][crate::Actor]. The request mode determines the
    /// type of geometry management used by the actor, either height for width
    /// (the default) or width for height.
    ///
    /// For actors implementing height for width, the parent container should get
    /// the preferred width first, and then the preferred height for that width.
    ///
    /// For actors implementing width for height, the parent container should get
    /// the preferred height first, and then the preferred width for that height.
    ///
    /// For instance:
    ///
    ///
    ///
    /// **⚠️ The following code is in C ⚠️**
    ///
    /// ```C
    ///   ClutterRequestMode mode;
    ///   gfloat natural_width, min_width;
    ///   gfloat natural_height, min_height;
    ///
    ///   mode = clutter_actor_get_request_mode (child);
    ///   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
    ///     {
    ///       clutter_actor_get_preferred_width (child, -1,
    ///                                          &min_width,
    ///                                          &natural_width);
    ///       clutter_actor_get_preferred_height (child, natural_width,
    ///                                           &min_height,
    ///                                           &natural_height);
    ///     }
    ///   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
    ///     {
    ///       clutter_actor_get_preferred_height (child, -1,
    ///                                           &min_height,
    ///                                           &natural_height);
    ///       clutter_actor_get_preferred_width (child, natural_height,
    ///                                          &min_width,
    ///                                          &natural_width);
    ///     }
    ///   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
    ///     {
    ///       ClutterContent *content = clutter_actor_get_content (child);
    ///
    ///       min_width, min_height = 0;
    ///       natural_width = natural_height = 0;
    ///
    ///       if (content != NULL)
    ///         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
    ///     }
    /// ```
    ///
    /// will retrieve the minimum and natural width and height depending on the
    /// preferred request mode of the [`Actor`][crate::Actor] "child".
    ///
    /// The [`preferred_size()`][Self::preferred_size()] function will implement this
    /// check for you.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "request-mode")]
    fn get_property_request_mode(&self) -> RequestMode;

    /// Request mode for the [`Actor`][crate::Actor]. The request mode determines the
    /// type of geometry management used by the actor, either height for width
    /// (the default) or width for height.
    ///
    /// For actors implementing height for width, the parent container should get
    /// the preferred width first, and then the preferred height for that width.
    ///
    /// For actors implementing width for height, the parent container should get
    /// the preferred height first, and then the preferred width for that height.
    ///
    /// For instance:
    ///
    ///
    ///
    /// **⚠️ The following code is in C ⚠️**
    ///
    /// ```C
    ///   ClutterRequestMode mode;
    ///   gfloat natural_width, min_width;
    ///   gfloat natural_height, min_height;
    ///
    ///   mode = clutter_actor_get_request_mode (child);
    ///   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
    ///     {
    ///       clutter_actor_get_preferred_width (child, -1,
    ///                                          &min_width,
    ///                                          &natural_width);
    ///       clutter_actor_get_preferred_height (child, natural_width,
    ///                                           &min_height,
    ///                                           &natural_height);
    ///     }
    ///   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
    ///     {
    ///       clutter_actor_get_preferred_height (child, -1,
    ///                                           &min_height,
    ///                                           &natural_height);
    ///       clutter_actor_get_preferred_width (child, natural_height,
    ///                                          &min_width,
    ///                                          &natural_width);
    ///     }
    ///   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
    ///     {
    ///       ClutterContent *content = clutter_actor_get_content (child);
    ///
    ///       min_width, min_height = 0;
    ///       natural_width = natural_height = 0;
    ///
    ///       if (content != NULL)
    ///         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
    ///     }
    /// ```
    ///
    /// will retrieve the minimum and natural width and height depending on the
    /// preferred request mode of the [`Actor`][crate::Actor] "child".
    ///
    /// The [`preferred_size()`][Self::preferred_size()] function will implement this
    /// check for you.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "request-mode")]
    fn set_property_request_mode(&self, request_mode: RequestMode);

    /// The rotation angle on the X axis.
    ///
    /// The `property::Actor::rotation-angle-x` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "rotation-angle-x")]
    fn rotation_angle_x(&self) -> f64;

    /// The rotation angle on the X axis.
    ///
    /// The `property::Actor::rotation-angle-x` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "rotation-angle-x")]
    fn set_rotation_angle_x(&self, rotation_angle_x: f64);

    /// The rotation angle on the Y axis
    ///
    /// The `property::Actor::rotation-angle-y` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "rotation-angle-y")]
    fn rotation_angle_y(&self) -> f64;

    /// The rotation angle on the Y axis
    ///
    /// The `property::Actor::rotation-angle-y` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "rotation-angle-y")]
    fn set_rotation_angle_y(&self, rotation_angle_y: f64);

    /// The rotation angle on the Z axis
    ///
    /// The `property::Actor::rotation-angle-z` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "rotation-angle-z")]
    fn rotation_angle_z(&self) -> f64;

    /// The rotation angle on the Z axis
    ///
    /// The `property::Actor::rotation-angle-z` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "rotation-angle-z")]
    fn set_rotation_angle_z(&self, rotation_angle_z: f64);

    /// The horizontal scale of the actor.
    ///
    /// The `property::Actor::scale-x` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "scale-x")]
    fn scale_x(&self) -> f64;

    /// The horizontal scale of the actor.
    ///
    /// The `property::Actor::scale-x` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "scale-x")]
    fn set_scale_x(&self, scale_x: f64);

    /// The vertical scale of the actor.
    ///
    /// The `property::Actor::scale-y` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "scale-y")]
    fn scale_y(&self) -> f64;

    /// The vertical scale of the actor.
    ///
    /// The `property::Actor::scale-y` property is animatable.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "scale-y")]
    fn set_scale_y(&self, scale_y: f64);

    /// If [`true`], the actor is automatically shown when parented.
    ///
    /// Calling [`hide()`][Self::hide()] on an actor which has not been
    /// parented will set this property to [`false`] as a side effect.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "show-on-set-parent")]
    fn shows_on_set_parent(&self) -> bool;

    /// If [`true`], the actor is automatically shown when parented.
    ///
    /// Calling [`hide()`][Self::hide()] on an actor which has not been
    /// parented will set this property to [`false`] as a side effect.
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "show-on-set-parent")]
    fn set_show_on_set_parent(&self, show_on_set_parent: bool);

    /// The direction of the text inside a [`Actor`][crate::Actor].
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "text-direction")]
    fn get_property_text_direction(&self) -> TextDirection;

    /// The direction of the text inside a [`Actor`][crate::Actor].
    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "text-direction")]
    fn set_property_text_direction(&self, text_direction: TextDirection);

    /// Whether the `property::Actor::transform` property is set.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "transform-set")]
    fn is_transform_set(&self) -> bool;

    /// An additional translation applied along the X axis, relative
    /// to the actor's `property::Actor::pivot-point`.
    ///
    /// The `property::Actor::translation-x` property is animatable.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "translation-x")]
    fn translation_x(&self) -> f32;

    /// An additional translation applied along the X axis, relative
    /// to the actor's `property::Actor::pivot-point`.
    ///
    /// The `property::Actor::translation-x` property is animatable.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "translation-x")]
    fn set_translation_x(&self, translation_x: f32);

    /// An additional translation applied along the Y axis, relative
    /// to the actor's `property::Actor::pivot-point`.
    ///
    /// The `property::Actor::translation-y` property is animatable.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "translation-y")]
    fn translation_y(&self) -> f32;

    /// An additional translation applied along the Y axis, relative
    /// to the actor's `property::Actor::pivot-point`.
    ///
    /// The `property::Actor::translation-y` property is animatable.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "translation-y")]
    fn set_translation_y(&self, translation_y: f32);

    /// An additional translation applied along the Z axis, relative
    /// to the actor's `property::Actor::pivot-point`.
    ///
    /// The `property::Actor::translation-z` property is animatable.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "translation-z")]
    fn translation_z(&self) -> f32;

    /// An additional translation applied along the Z axis, relative
    /// to the actor's `property::Actor::pivot-point`.
    ///
    /// The `property::Actor::translation-z` property is animatable.
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "translation-z")]
    fn set_translation_z(&self, translation_z: f32);

    /// Whether the actor is set to be visible or not
    ///
    /// See also `property::Actor::mapped`
    fn get_property_visible(&self) -> bool;

    /// Whether the actor is set to be visible or not
    ///
    /// See also `property::Actor::mapped`
    fn set_visible(&self, visible: bool);

    /// Width of the actor (in pixels). If written, forces the minimum and
    /// natural size request of the actor to the given width. If read, returns
    /// the allocated width if available, otherwise the width request.
    ///
    /// The `property::Actor::width` property is animatable.
    fn set_property_width(&self, width: f32);

    /// X coordinate of the actor in pixels. If written, forces a fixed
    /// position for the actor. If read, returns the fixed position if any,
    /// otherwise the allocation if available, otherwise 0.
    ///
    /// The `property::Actor::x` property is animatable.
    fn set_property_x(&self, x: f32);

    /// Y coordinate of the actor in pixels. If written, forces a fixed
    /// position for the actor. If read, returns the fixed position if
    /// any, otherwise the allocation if available, otherwise 0.
    ///
    /// The `property::Actor::y` property is animatable.
    fn set_property_y(&self, y: f32);

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "button-press-event")]
    //fn connect_button_press_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "button-release-event")]
    //fn connect_button_release_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "captured-event")]
    //fn connect_captured_event<Unsupported or ignored types>(&self, detail: Option<&str>, f: F) -> SignalHandlerId;

    /// The ::destroy signal notifies that all references held on the
    /// actor which emitted it should be released.
    ///
    /// The ::destroy signal should be used by all holders of a reference
    /// on `actor`.
    ///
    /// This signal might result in the finalization of the [`Actor`][crate::Actor]
    /// if all references are released.
    ///
    /// Composite actors and actors implementing the [`Container`][crate::Container]
    /// interface should override the default implementation of the
    /// class handler of this signal and call `clutter_actor_destroy()` on
    /// their children. When overriding the default class handler, it is
    /// required to chain up to the parent's implementation.
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "destroy")]
    fn connect_destroy<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "enter-event")]
    //fn connect_enter_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "event")]
    //fn connect_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    /// The ::hide signal is emitted when an actor is no longer rendered
    /// on the stage.
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "hide")]
    fn connect_hide<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    /// The ::key-focus-in signal is emitted when `actor` receives key focus.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "key-focus-in")]
    fn connect_key_focus_in<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    /// The ::key-focus-out signal is emitted when `actor` loses key focus.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "key-focus-out")]
    fn connect_key_focus_out<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    /// The ::key-press-event signal is emitted each time a keyboard button
    /// is pressed while `actor` has key focus (see [`StageExt::set_key_focus()`][crate::prelude::StageExt::set_key_focus()]).
    /// ## `event`
    /// a [`KeyEvent`][crate::KeyEvent]
    ///
    /// # Returns
    ///
    /// [`true`] if the event has been handled by the actor,
    ///  or [`false`] to continue the emission.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "key-press-event")]
    fn connect_key_press_event<F: Fn(&Self, &KeyEvent) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    /// The ::key-release-event signal is emitted each time a keyboard button
    /// is released while `actor` has key focus (see
    /// [`StageExt::set_key_focus()`][crate::prelude::StageExt::set_key_focus()]).
    /// ## `event`
    /// a [`KeyEvent`][crate::KeyEvent]
    ///
    /// # Returns
    ///
    /// [`true`] if the event has been handled by the actor,
    ///  or [`false`] to continue the emission.
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "key-release-event")]
    fn connect_key_release_event<F: Fn(&Self, &KeyEvent) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "leave-event")]
    //fn connect_leave_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "motion-event")]
    //fn connect_motion_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    /// This signal is emitted when the parent of the actor changes.
    /// ## `old_parent`
    /// the previous parent of the actor, or [`None`]
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "parent-set")]
    fn connect_parent_set<F: Fn(&Self, Option<&Actor>) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg_attr(feature = "v1_12", deprecated = "Since 1.12")]
    //#[cfg(any(feature = "v1_0", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    //#[doc(alias = "pick")]
    //fn connect_pick<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    /// The ::queue_layout signal is emitted when [`queue_relayout()`][Self::queue_relayout()]
    /// is called on an actor.
    ///
    /// The default implementation for [`Actor`][crate::Actor] chains up to the
    /// parent actor and queues a relayout on the parent, thus "bubbling"
    /// the relayout queue up through the actor graph.
    ///
    /// The main purpose of this signal is to allow relayout to be propagated
    /// properly in the procense of `ClutterClone` actors. Applications will
    /// not normally need to connect to this signal.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "queue-relayout")]
    fn connect_queue_relayout<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    /// The ::realize signal is emitted each time an actor is being
    /// realized.
    ///
    /// # Deprecated since 1.16
    ///
    /// The signal should not be used in newly
    ///  written code
    #[cfg_attr(feature = "v1_16", deprecated = "Since 1.16")]
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "realize")]
    fn connect_realize<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    /// The ::resource-scale-changed signal is emitted when the resource scale
    /// value returned by [`resource_scale()`][Self::resource_scale()] changes.
    ///
    /// This signal can be used to get notified about the correct resource scale
    /// when the scale had to be queried outside of the paint cycle.
    #[doc(alias = "resource-scale-changed")]
    fn connect_resource_scale_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //#[doc(alias = "scroll-event")]
    //fn connect_scroll_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    /// The ::show signal is emitted when an actor is visible and
    /// rendered on the stage.
    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "show")]
    fn connect_show<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    /// The ::stage-views-changed signal is emitted when the position or
    /// size an actor is being painted at have changed so that it's visible
    /// on different stage views.
    ///
    /// This signal is also emitted when the actor gets detached from the stage
    /// or when the views of the stage have been invalidated and will be
    /// replaced; it's not emitted when the actor gets hidden.
    #[doc(alias = "stage-views-changed")]
    fn connect_stage_views_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //#[doc(alias = "touch-event")]
    //fn connect_touch_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    /// The ::transition-stopped signal is emitted once a transition
    /// is stopped; a transition is stopped once it reached its total
    /// duration (including eventual repeats), it has been stopped
    /// using `clutter_timeline_stop()`, or it has been removed from the
    /// transitions applied on `actor`, using [`remove_transition()`][Self::remove_transition()].
    /// ## `name`
    /// the name of the transition
    /// ## `is_finished`
    /// whether the transition was finished, or stopped
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "transition-stopped")]
    fn connect_transition_stopped<F: Fn(&Self, &str, bool) + 'static>(&self, detail: Option<&str>, f: F) -> SignalHandlerId;

    /// The ::transitions-completed signal is emitted once all transitions
    /// involving `actor` are complete.
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "transitions-completed")]
    fn connect_transitions_completed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    /// The ::unrealize signal is emitted each time an actor is being
    /// unrealized.
    ///
    /// # Deprecated since 1.16
    ///
    /// The signal should not be used in newly
    ///  written code
    #[cfg_attr(feature = "v1_16", deprecated = "Since 1.16")]
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "unrealize")]
    fn connect_unrealize<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "actions")]
    fn connect_actions_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "allocation")]
    fn connect_allocation_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "background-color")]
    fn connect_background_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "background-color-set")]
    fn connect_background_color_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "child-transform")]
    fn connect_child_transform_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "child-transform-set")]
    fn connect_child_transform_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "clip-rect")]
    fn connect_clip_rect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "clip-to-allocation")]
    fn connect_clip_to_allocation_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "constraints")]
    fn connect_constraints_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "content")]
    fn connect_content_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "content-box")]
    fn connect_content_box_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "content-gravity")]
    fn connect_content_gravity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "content-repeat")]
    fn connect_content_repeat_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "effect")]
    fn connect_effect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "first-child")]
    fn connect_first_child_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "fixed-position-set")]
    fn connect_fixed_position_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "fixed-x")]
    fn connect_fixed_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "fixed-y")]
    fn connect_fixed_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "has-clip")]
    fn connect_has_clip_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "has-pointer")]
    fn connect_has_pointer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "height")]
    fn connect_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "last-child")]
    fn connect_last_child_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "layout-manager")]
    fn connect_layout_manager_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "magnification-filter")]
    fn connect_magnification_filter_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "mapped")]
    fn connect_mapped_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "margin-bottom")]
    fn connect_margin_bottom_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "margin-left")]
    fn connect_margin_left_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "margin-right")]
    fn connect_margin_right_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "margin-top")]
    fn connect_margin_top_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-height")]
    fn connect_min_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-height-set")]
    fn connect_min_height_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-width")]
    fn connect_min_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "min-width-set")]
    fn connect_min_width_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "minification-filter")]
    fn connect_minification_filter_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    #[doc(alias = "name")]
    fn connect_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-height")]
    fn connect_natural_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-height-set")]
    fn connect_natural_height_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-width")]
    fn connect_natural_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "natural-width-set")]
    fn connect_natural_width_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "offscreen-redirect")]
    fn connect_offscreen_redirect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "opacity")]
    fn connect_opacity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "pivot-point")]
    fn connect_pivot_point_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "pivot-point-z")]
    fn connect_pivot_point_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "position")]
    fn connect_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "reactive")]
    fn connect_reactive_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "realized")]
    fn connect_realized_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "request-mode")]
    fn connect_request_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "rotation-angle-x")]
    fn connect_rotation_angle_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "rotation-angle-y")]
    fn connect_rotation_angle_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "rotation-angle-z")]
    fn connect_rotation_angle_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "scale-x")]
    fn connect_scale_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    #[doc(alias = "scale-y")]
    fn connect_scale_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "scale-z")]
    fn connect_scale_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    #[doc(alias = "show-on-set-parent")]
    fn connect_show_on_set_parent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "size")]
    fn connect_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    #[doc(alias = "text-direction")]
    fn connect_text_direction_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "transform")]
    fn connect_transform_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "transform-set")]
    fn connect_transform_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "translation-x")]
    fn connect_translation_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "translation-y")]
    fn connect_translation_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "translation-z")]
    fn connect_translation_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "visible")]
    fn connect_visible_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "width")]
    fn connect_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "x")]
    fn connect_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "x-align")]
    fn connect_x_align_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "x-expand")]
    fn connect_x_expand_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "y")]
    fn connect_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "y-align")]
    fn connect_y_align_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "y-expand")]
    fn connect_y_expand_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "z-position")]
    fn connect_z_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Actor>> ActorExt for O {
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn add_action<P: IsA<Action>>(&self, action: &P) {
        unsafe {
            ffi::clutter_actor_add_action(self.as_ref().to_glib_none().0, action.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn add_action_with_name<P: IsA<Action>>(&self, name: &str, action: &P) {
        unsafe {
            ffi::clutter_actor_add_action_with_name(self.as_ref().to_glib_none().0, name.to_glib_none().0, action.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn add_child<P: IsA<Actor>>(&self, child: &P) {
        unsafe {
            ffi::clutter_actor_add_child(self.as_ref().to_glib_none().0, child.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn add_constraint<P: IsA<Constraint>>(&self, constraint: &P) {
        unsafe {
            ffi::clutter_actor_add_constraint(self.as_ref().to_glib_none().0, constraint.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn add_constraint_with_name<P: IsA<Constraint>>(&self, name: &str, constraint: &P) {
        unsafe {
            ffi::clutter_actor_add_constraint_with_name(self.as_ref().to_glib_none().0, name.to_glib_none().0, constraint.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn add_effect<P: IsA<Effect>>(&self, effect: &P) {
        unsafe {
            ffi::clutter_actor_add_effect(self.as_ref().to_glib_none().0, effect.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn add_effect_with_name<P: IsA<Effect>>(&self, name: &str, effect: &P) {
        unsafe {
            ffi::clutter_actor_add_effect_with_name(self.as_ref().to_glib_none().0, name.to_glib_none().0, effect.as_ref().to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn add_transition(&self, name: &str, transition: /*Ignored*/&Transition) {
    //    unsafe { TODO: call ffi:clutter_actor_add_transition() }
    //}

    //#[cfg(any(feature = "v0_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    //fn allocate(&self, box_: /*Ignored*/&ActorBox) {
    //    unsafe { TODO: call ffi:clutter_actor_allocate() }
    //}

    //#[cfg(any(feature = "v1_4", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    //fn allocate_align_fill(&self, box_: /*Ignored*/&ActorBox, x_align: f64, y_align: f64, x_fill: bool, y_fill: bool) {
    //    unsafe { TODO: call ffi:clutter_actor_allocate_align_fill() }
    //}

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn allocate_available_size(&self, x: f32, y: f32, available_width: f32, available_height: f32) {
        unsafe {
            ffi::clutter_actor_allocate_available_size(self.as_ref().to_glib_none().0, x, y, available_width, available_height);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn allocate_preferred_size(&self, x: f32, y: f32) {
        unsafe {
            ffi::clutter_actor_allocate_preferred_size(self.as_ref().to_glib_none().0, x, y);
        }
    }

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn apply_relative_transform_to_point<P: IsA<Actor>>(&self, ancestor: Option<&P>, point: /*Ignored*/&graphene::Point3D, vertex: /*Ignored*/graphene::Point3D) {
    //    unsafe { TODO: call ffi:clutter_actor_apply_relative_transform_to_point() }
    //}

    //#[cfg(any(feature = "v0_4", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
    //fn apply_transform_to_point(&self, point: /*Ignored*/&graphene::Point3D, vertex: /*Ignored*/graphene::Point3D) {
    //    unsafe { TODO: call ffi:clutter_actor_apply_transform_to_point() }
    //}

    //#[cfg(any(feature = "v1_24", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    //fn bind_model(&self, model: /*Ignored*/Option<&gio::ListModel>, create_child_func: /*Unimplemented*/Fn(/*Ignored*/glib::Object) -> Actor, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) {
    //    unsafe { TODO: call ffi:clutter_actor_bind_model() }
    //}

    //#[cfg(any(feature = "v1_24", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    //fn bind_model_with_properties(&self, model: /*Ignored*/&gio::ListModel, child_type: glib::types::Type, first_model_property: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
    //    unsafe { TODO: call ffi:clutter_actor_bind_model_with_properties() }
    //}

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn clear_actions(&self) {
        unsafe {
            ffi::clutter_actor_clear_actions(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn clear_constraints(&self) {
        unsafe {
            ffi::clutter_actor_clear_constraints(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn clear_effects(&self) {
        unsafe {
            ffi::clutter_actor_clear_effects(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn contains<P: IsA<Actor>>(&self, descendant: &P) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_contains(self.as_ref().to_glib_none().0, descendant.as_ref().to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v1_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    //fn continue_paint(&self, paint_context: /*Ignored*/&PaintContext) {
    //    unsafe { TODO: call ffi:clutter_actor_continue_paint() }
    //}

    //fn continue_pick(&self, pick_context: /*Ignored*/&PickContext) {
    //    unsafe { TODO: call ffi:clutter_actor_continue_pick() }
    //}

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn create_pango_context(&self) -> Option<pango::Context> {
        unsafe {
            from_glib_full(ffi::clutter_actor_create_pango_context(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn create_pango_layout(&self, text: Option<&str>) -> Option<pango::Layout> {
        unsafe {
            from_glib_full(ffi::clutter_actor_create_pango_layout(self.as_ref().to_glib_none().0, text.to_glib_none().0))
        }
    }

    fn destroy(&self) {
        unsafe {
            ffi::clutter_actor_destroy(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn destroy_all_children(&self) {
        unsafe {
            ffi::clutter_actor_destroy_all_children(self.as_ref().to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn event(&self, event: /*Ignored*/&Event, capture: bool) -> bool {
    //    unsafe { TODO: call ffi:clutter_actor_event() }
    //}

    //#[cfg(any(feature = "v0_4", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_4")))]
    //fn abs_allocation_vertices(&self, verts: /*Unimplemented*/FixedArray TypeId { ns_id: 6, id: 2 }; 4) {
    //    unsafe { TODO: call ffi:clutter_actor_get_abs_allocation_vertices() }
    //}

    //fn accessible(&self) -> /*Ignored*/Option<atk::Object> {
    //    unsafe { TODO: call ffi:clutter_actor_get_accessible() }
    //}

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn action(&self, name: &str) -> Option<Action> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_action(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn actions(&self) -> Vec<Action> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::clutter_actor_get_actions(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v0_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    //fn allocation_box(&self, box_: /*Ignored*/ActorBox) {
    //    unsafe { TODO: call ffi:clutter_actor_get_allocation_box() }
    //}

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn background_color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_actor_get_background_color(self.as_ref().to_glib_none().0, color.to_glib_none_mut().0);
            color
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn child_at_index(&self, index_: i32) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_child_at_index(self.as_ref().to_glib_none().0, index_))
        }
    }

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn child_transform(&self, transform: /*Ignored*/graphene::Matrix) {
    //    unsafe { TODO: call ffi:clutter_actor_get_child_transform() }
    //}

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[cfg(any(not(feature = "v0_4"), feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(not(feature = "v0_4"))))]
    fn children(&self) -> Vec<Actor> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::clutter_actor_get_children(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn clip(&self) -> (f32, f32, f32, f32) {
        unsafe {
            let mut xoff = mem::MaybeUninit::uninit();
            let mut yoff = mem::MaybeUninit::uninit();
            let mut width = mem::MaybeUninit::uninit();
            let mut height = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_clip(self.as_ref().to_glib_none().0, xoff.as_mut_ptr(), yoff.as_mut_ptr(), width.as_mut_ptr(), height.as_mut_ptr());
            let xoff = xoff.assume_init();
            let yoff = yoff.assume_init();
            let width = width.assume_init();
            let height = height.assume_init();
            (xoff, yoff, width, height)
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn is_clip_to_allocation(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_clip_to_allocation(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn constraint(&self, name: &str) -> Option<Constraint> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_constraint(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn constraints(&self) -> Vec<Constraint> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::clutter_actor_get_constraints(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn content(&self) -> Option<Content> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_content(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn content_box(&self, box_: /*Ignored*/ActorBox) {
    //    unsafe { TODO: call ffi:clutter_actor_get_content_box() }
    //}

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn content_gravity(&self) -> /*Ignored*/ContentGravity {
    //    unsafe { TODO: call ffi:clutter_actor_get_content_gravity() }
    //}

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn content_repeat(&self) -> /*Ignored*/ContentRepeat {
    //    unsafe { TODO: call ffi:clutter_actor_get_content_repeat() }
    //}

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn content_scaling_filters(&self) -> (/*Ignored*/ScalingFilter, /*Ignored*/ScalingFilter) {
    //    unsafe { TODO: call ffi:clutter_actor_get_content_scaling_filters() }
    //}

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn default_paint_volume(&self) -> /*Ignored*/Option<PaintVolume> {
    //    unsafe { TODO: call ffi:clutter_actor_get_default_paint_volume() }
    //}

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn easing_delay(&self) -> u32 {
        unsafe {
            ffi::clutter_actor_get_easing_delay(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn easing_duration(&self) -> u32 {
        unsafe {
            ffi::clutter_actor_get_easing_duration(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn easing_mode(&self) -> AnimationMode {
        unsafe {
            from_glib(ffi::clutter_actor_get_easing_mode(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn effect(&self, name: &str) -> Option<Effect> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_effect(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn effects(&self) -> Vec<Effect> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::clutter_actor_get_effects(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn first_child(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_first_child(self.as_ref().to_glib_none().0))
        }
    }

    fn fixed_position(&self) -> Option<(f32, f32)> {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::clutter_actor_get_fixed_position(self.as_ref().to_glib_none().0, x.as_mut_ptr(), y.as_mut_ptr()));
            let x = x.assume_init();
            let y = y.assume_init();
            if ret { Some((x, y)) } else { None }
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn is_fixed_position_set(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_fixed_position_set(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn flags(&self) -> ActorFlags {
        unsafe {
            from_glib(ffi::clutter_actor_get_flags(self.as_ref().to_glib_none().0))
        }
    }

    fn height(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_height(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn last_child(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_last_child(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn layout_manager(&self) -> /*Ignored*/Option<LayoutManager> {
    //    unsafe { TODO: call ffi:clutter_actor_get_layout_manager() }
    //}

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn margin(&self, margin: /*Ignored*/Margin) {
    //    unsafe { TODO: call ffi:clutter_actor_get_margin() }
    //}

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn margin_bottom(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_margin_bottom(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn margin_left(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_margin_left(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn margin_right(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_margin_right(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn margin_top(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_margin_top(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn n_children(&self) -> i32 {
        unsafe {
            ffi::clutter_actor_get_n_children(self.as_ref().to_glib_none().0)
        }
    }

    fn name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_name(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn next_sibling(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_next_sibling(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v1_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    //fn offscreen_redirect(&self) -> /*Ignored*/OffscreenRedirect {
    //    unsafe { TODO: call ffi:clutter_actor_get_offscreen_redirect() }
    //}

    fn opacity(&self) -> u8 {
        unsafe {
            ffi::clutter_actor_get_opacity(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    fn opacity_override(&self) -> i32 {
        unsafe {
            ffi::clutter_actor_get_opacity_override(self.as_ref().to_glib_none().0)
        }
    }

    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //fn paint_box(&self, box_: /*Ignored*/ActorBox) -> bool {
    //    unsafe { TODO: call ffi:clutter_actor_get_paint_box() }
    //}

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn paint_opacity(&self) -> u8 {
        unsafe {
            ffi::clutter_actor_get_paint_opacity(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn is_paint_visibility(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_paint_visibility(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //fn paint_volume(&self) -> /*Ignored*/Option<PaintVolume> {
    //    unsafe { TODO: call ffi:clutter_actor_get_paint_volume() }
    //}

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn pango_context(&self) -> Option<pango::Context> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_pango_context(self.as_ref().to_glib_none().0))
        }
    }

    fn parent(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_parent(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn pivot_point(&self) -> (f32, f32) {
        unsafe {
            let mut pivot_x = mem::MaybeUninit::uninit();
            let mut pivot_y = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_pivot_point(self.as_ref().to_glib_none().0, pivot_x.as_mut_ptr(), pivot_y.as_mut_ptr());
            let pivot_x = pivot_x.assume_init();
            let pivot_y = pivot_y.assume_init();
            (pivot_x, pivot_y)
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn pivot_point_z(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_pivot_point_z(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn position(&self) -> (f32, f32) {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_position(self.as_ref().to_glib_none().0, x.as_mut_ptr(), y.as_mut_ptr());
            let x = x.assume_init();
            let y = y.assume_init();
            (x, y)
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn preferred_height(&self, for_width: f32) -> (f32, f32) {
        unsafe {
            let mut min_height_p = mem::MaybeUninit::uninit();
            let mut natural_height_p = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_preferred_height(self.as_ref().to_glib_none().0, for_width, min_height_p.as_mut_ptr(), natural_height_p.as_mut_ptr());
            let min_height_p = min_height_p.assume_init();
            let natural_height_p = natural_height_p.assume_init();
            (min_height_p, natural_height_p)
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn preferred_size(&self) -> (f32, f32, f32, f32) {
        unsafe {
            let mut min_width_p = mem::MaybeUninit::uninit();
            let mut min_height_p = mem::MaybeUninit::uninit();
            let mut natural_width_p = mem::MaybeUninit::uninit();
            let mut natural_height_p = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_preferred_size(self.as_ref().to_glib_none().0, min_width_p.as_mut_ptr(), min_height_p.as_mut_ptr(), natural_width_p.as_mut_ptr(), natural_height_p.as_mut_ptr());
            let min_width_p = min_width_p.assume_init();
            let min_height_p = min_height_p.assume_init();
            let natural_width_p = natural_width_p.assume_init();
            let natural_height_p = natural_height_p.assume_init();
            (min_width_p, min_height_p, natural_width_p, natural_height_p)
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn preferred_width(&self, for_height: f32) -> (f32, f32) {
        unsafe {
            let mut min_width_p = mem::MaybeUninit::uninit();
            let mut natural_width_p = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_preferred_width(self.as_ref().to_glib_none().0, for_height, min_width_p.as_mut_ptr(), natural_width_p.as_mut_ptr());
            let min_width_p = min_width_p.assume_init();
            let natural_width_p = natural_width_p.assume_init();
            (min_width_p, natural_width_p)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn previous_sibling(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_previous_sibling(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn is_reactive(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_reactive(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn request_mode(&self) -> RequestMode {
        unsafe {
            from_glib(ffi::clutter_actor_get_request_mode(self.as_ref().to_glib_none().0))
        }
    }

    fn resource_scale(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_resource_scale(self.as_ref().to_glib_none().0)
        }
    }

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn rotation_angle(&self, axis: /*Ignored*/RotateAxis) -> f64 {
    //    unsafe { TODO: call ffi:clutter_actor_get_rotation_angle() }
    //}

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn scale(&self) -> (f64, f64) {
        unsafe {
            let mut scale_x = mem::MaybeUninit::uninit();
            let mut scale_y = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_scale(self.as_ref().to_glib_none().0, scale_x.as_mut_ptr(), scale_y.as_mut_ptr());
            let scale_x = scale_x.assume_init();
            let scale_y = scale_y.assume_init();
            (scale_x, scale_y)
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn scale_z(&self) -> f64 {
        unsafe {
            ffi::clutter_actor_get_scale_z(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn size(&self) -> (f32, f32) {
        unsafe {
            let mut width = mem::MaybeUninit::uninit();
            let mut height = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_size(self.as_ref().to_glib_none().0, width.as_mut_ptr(), height.as_mut_ptr());
            let width = width.assume_init();
            let height = height.assume_init();
            (width, height)
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn stage(&self) -> Option<Stage> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_stage(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn text_direction(&self) -> TextDirection {
        unsafe {
            from_glib(ffi::clutter_actor_get_text_direction(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn transform(&self, transform: /*Ignored*/graphene::Matrix) {
    //    unsafe { TODO: call ffi:clutter_actor_get_transform() }
    //}

    //fn transformed_extents(&self, rect: /*Ignored*/graphene::Rect) {
    //    unsafe { TODO: call ffi:clutter_actor_get_transformed_extents() }
    //}

    //#[cfg(any(feature = "v1_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
    //fn transformed_paint_volume<P: IsA<Actor>>(&self, relative_to_ancestor: &P) -> /*Ignored*/Option<PaintVolume> {
    //    unsafe { TODO: call ffi:clutter_actor_get_transformed_paint_volume() }
    //}

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn transformed_position(&self) -> (f32, f32) {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_transformed_position(self.as_ref().to_glib_none().0, x.as_mut_ptr(), y.as_mut_ptr());
            let x = x.assume_init();
            let y = y.assume_init();
            (x, y)
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn transformed_size(&self) -> (f32, f32) {
        unsafe {
            let mut width = mem::MaybeUninit::uninit();
            let mut height = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_transformed_size(self.as_ref().to_glib_none().0, width.as_mut_ptr(), height.as_mut_ptr());
            let width = width.assume_init();
            let height = height.assume_init();
            (width, height)
        }
    }

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn transition(&self, name: &str) -> /*Ignored*/Option<Transition> {
    //    unsafe { TODO: call ffi:clutter_actor_get_transition() }
    //}

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn translation(&self) -> (f32, f32, f32) {
        unsafe {
            let mut translate_x = mem::MaybeUninit::uninit();
            let mut translate_y = mem::MaybeUninit::uninit();
            let mut translate_z = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_translation(self.as_ref().to_glib_none().0, translate_x.as_mut_ptr(), translate_y.as_mut_ptr(), translate_z.as_mut_ptr());
            let translate_x = translate_x.assume_init();
            let translate_y = translate_y.assume_init();
            let translate_z = translate_z.assume_init();
            (translate_x, translate_y, translate_z)
        }
    }

    fn width(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_width(self.as_ref().to_glib_none().0)
        }
    }

    fn x(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_x(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn x_align(&self) -> ActorAlign {
        unsafe {
            from_glib(ffi::clutter_actor_get_x_align(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn is_x_expand(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_x_expand(self.as_ref().to_glib_none().0))
        }
    }

    fn y(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_y(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn y_align(&self) -> ActorAlign {
        unsafe {
            from_glib(ffi::clutter_actor_get_y_align(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn is_y_expand(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_y_expand(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn z_position(&self) -> f32 {
        unsafe {
            ffi::clutter_actor_get_z_position(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn grab_key_focus(&self) {
        unsafe {
            ffi::clutter_actor_grab_key_focus(self.as_ref().to_glib_none().0);
        }
    }

    fn has_accessible(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_accessible(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn has_actions(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_actions(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn has_allocation(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_allocation(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn has_clip(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_clip(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn has_constraints(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_constraints(self.as_ref().to_glib_none().0))
        }
    }

    fn has_damage(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_damage(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn has_effects(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_effects(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn has_key_focus(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_key_focus(self.as_ref().to_glib_none().0))
        }
    }

    fn has_mapped_clones(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_mapped_clones(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn has_overlaps(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_overlaps(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn has_pointer(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_pointer(self.as_ref().to_glib_none().0))
        }
    }

    fn has_transitions(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_transitions(self.as_ref().to_glib_none().0))
        }
    }

    fn hide(&self) {
        unsafe {
            ffi::clutter_actor_hide(self.as_ref().to_glib_none().0);
        }
    }

    fn inhibit_culling(&self) {
        unsafe {
            ffi::clutter_actor_inhibit_culling(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn insert_child_above<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>) {
        unsafe {
            ffi::clutter_actor_insert_child_above(self.as_ref().to_glib_none().0, child.as_ref().to_glib_none().0, sibling.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn insert_child_at_index<P: IsA<Actor>>(&self, child: &P, index_: i32) {
        unsafe {
            ffi::clutter_actor_insert_child_at_index(self.as_ref().to_glib_none().0, child.as_ref().to_glib_none().0, index_);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn insert_child_below<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>) {
        unsafe {
            ffi::clutter_actor_insert_child_below(self.as_ref().to_glib_none().0, child.as_ref().to_glib_none().0, sibling.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    fn invalidate_paint_volume(&self) {
        unsafe {
            ffi::clutter_actor_invalidate_paint_volume(self.as_ref().to_glib_none().0);
        }
    }

    fn invalidate_transform(&self) {
        unsafe {
            ffi::clutter_actor_invalidate_transform(self.as_ref().to_glib_none().0);
        }
    }

    //fn is_effectively_on_stage_view(&self, view: /*Ignored*/&StageView) -> bool {
    //    unsafe { TODO: call ffi:clutter_actor_is_effectively_on_stage_view() }
    //}

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn is_in_clone_paint(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_in_clone_paint(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    fn is_mapped(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_mapped(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    fn is_realized(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_realized(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn is_rotated(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_rotated(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn is_scaled(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_scaled(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    fn is_visible(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_visible(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn map(&self) {
        unsafe {
            ffi::clutter_actor_map(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn move_by(&self, dx: f32, dy: f32) {
        unsafe {
            ffi::clutter_actor_move_by(self.as_ref().to_glib_none().0, dx, dy);
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn needs_expand(&self, orientation: Orientation) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_needs_expand(self.as_ref().to_glib_none().0, orientation.into_glib()))
        }
    }

    //fn paint(&self, paint_context: /*Ignored*/&PaintContext) {
    //    unsafe { TODO: call ffi:clutter_actor_paint() }
    //}

    //fn peek_stage_views(&self) -> /*Ignored*/Vec<StageView> {
    //    unsafe { TODO: call ffi:clutter_actor_peek_stage_views() }
    //}

    //fn pick(&self, pick_context: /*Ignored*/&PickContext) {
    //    unsafe { TODO: call ffi:clutter_actor_pick() }
    //}

    //fn pick_box(&self, pick_context: /*Ignored*/&PickContext, box_: /*Ignored*/&ActorBox) {
    //    unsafe { TODO: call ffi:clutter_actor_pick_box() }
    //}

    //fn pick_frame_clock<P: IsA<Actor>>(&self, out_actor: Option<&P>) -> /*Ignored*/Option<FrameClock> {
    //    unsafe { TODO: call ffi:clutter_actor_pick_frame_clock() }
    //}

    fn queue_redraw(&self) {
        unsafe {
            ffi::clutter_actor_queue_redraw(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn queue_redraw_with_clip(&self, clip: Option<&cairo::RectangleInt>) {
        unsafe {
            ffi::clutter_actor_queue_redraw_with_clip(self.as_ref().to_glib_none().0, clip.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn queue_relayout(&self) {
        unsafe {
            ffi::clutter_actor_queue_relayout(self.as_ref().to_glib_none().0);
        }
    }

    fn realize(&self) {
        unsafe {
            ffi::clutter_actor_realize(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn remove_action<P: IsA<Action>>(&self, action: &P) {
        unsafe {
            ffi::clutter_actor_remove_action(self.as_ref().to_glib_none().0, action.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn remove_action_by_name(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_remove_action_by_name(self.as_ref().to_glib_none().0, name.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn remove_all_children(&self) {
        unsafe {
            ffi::clutter_actor_remove_all_children(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn remove_all_transitions(&self) {
        unsafe {
            ffi::clutter_actor_remove_all_transitions(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn remove_child<P: IsA<Actor>>(&self, child: &P) {
        unsafe {
            ffi::clutter_actor_remove_child(self.as_ref().to_glib_none().0, child.as_ref().to_glib_none().0);
        }
    }

    fn remove_clip(&self) {
        unsafe {
            ffi::clutter_actor_remove_clip(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn remove_constraint<P: IsA<Constraint>>(&self, constraint: &P) {
        unsafe {
            ffi::clutter_actor_remove_constraint(self.as_ref().to_glib_none().0, constraint.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn remove_constraint_by_name(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_remove_constraint_by_name(self.as_ref().to_glib_none().0, name.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn remove_effect<P: IsA<Effect>>(&self, effect: &P) {
        unsafe {
            ffi::clutter_actor_remove_effect(self.as_ref().to_glib_none().0, effect.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn remove_effect_by_name(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_remove_effect_by_name(self.as_ref().to_glib_none().0, name.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn remove_transition(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_remove_transition(self.as_ref().to_glib_none().0, name.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn replace_child<P: IsA<Actor>, Q: IsA<Actor>>(&self, old_child: &P, new_child: &Q) {
        unsafe {
            ffi::clutter_actor_replace_child(self.as_ref().to_glib_none().0, old_child.as_ref().to_glib_none().0, new_child.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn restore_easing_state(&self) {
        unsafe {
            ffi::clutter_actor_restore_easing_state(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn save_easing_state(&self) {
        unsafe {
            ffi::clutter_actor_save_easing_state(self.as_ref().to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn set_allocation(&self, box_: /*Ignored*/&ActorBox) {
    //    unsafe { TODO: call ffi:clutter_actor_set_allocation() }
    //}

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_background_color(&self, color: Option<&Color>) {
        unsafe {
            ffi::clutter_actor_set_background_color(self.as_ref().to_glib_none().0, color.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_child_above_sibling<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>) {
        unsafe {
            ffi::clutter_actor_set_child_above_sibling(self.as_ref().to_glib_none().0, child.as_ref().to_glib_none().0, sibling.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_child_at_index<P: IsA<Actor>>(&self, child: &P, index_: i32) {
        unsafe {
            ffi::clutter_actor_set_child_at_index(self.as_ref().to_glib_none().0, child.as_ref().to_glib_none().0, index_);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_child_below_sibling<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>) {
        unsafe {
            ffi::clutter_actor_set_child_below_sibling(self.as_ref().to_glib_none().0, child.as_ref().to_glib_none().0, sibling.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn set_child_transform(&self, transform: /*Ignored*/Option<&graphene::Matrix>) {
    //    unsafe { TODO: call ffi:clutter_actor_set_child_transform() }
    //}

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn set_clip(&self, xoff: f32, yoff: f32, width: f32, height: f32) {
        unsafe {
            ffi::clutter_actor_set_clip(self.as_ref().to_glib_none().0, xoff, yoff, width, height);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn set_clip_to_allocation(&self, clip_set: bool) {
        unsafe {
            ffi::clutter_actor_set_clip_to_allocation(self.as_ref().to_glib_none().0, clip_set.into_glib());
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_content<P: IsA<Content>>(&self, content: Option<&P>) {
        unsafe {
            ffi::clutter_actor_set_content(self.as_ref().to_glib_none().0, content.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn set_content_gravity(&self, gravity: /*Ignored*/ContentGravity) {
    //    unsafe { TODO: call ffi:clutter_actor_set_content_gravity() }
    //}

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn set_content_repeat(&self, repeat: /*Ignored*/ContentRepeat) {
    //    unsafe { TODO: call ffi:clutter_actor_set_content_repeat() }
    //}

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn set_content_scaling_filters(&self, min_filter: /*Ignored*/ScalingFilter, mag_filter: /*Ignored*/ScalingFilter) {
    //    unsafe { TODO: call ffi:clutter_actor_set_content_scaling_filters() }
    //}

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_easing_delay(&self, msecs: u32) {
        unsafe {
            ffi::clutter_actor_set_easing_delay(self.as_ref().to_glib_none().0, msecs);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_easing_duration(&self, msecs: u32) {
        unsafe {
            ffi::clutter_actor_set_easing_duration(self.as_ref().to_glib_none().0, msecs);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_easing_mode(&self, mode: AnimationMode) {
        unsafe {
            ffi::clutter_actor_set_easing_mode(self.as_ref().to_glib_none().0, mode.into_glib());
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_fixed_position_set(&self, is_set: bool) {
        unsafe {
            ffi::clutter_actor_set_fixed_position_set(self.as_ref().to_glib_none().0, is_set.into_glib());
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn set_flags(&self, flags: ActorFlags) {
        unsafe {
            ffi::clutter_actor_set_flags(self.as_ref().to_glib_none().0, flags.into_glib());
        }
    }

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn set_height(&self, height: f32) {
        unsafe {
            ffi::clutter_actor_set_height(self.as_ref().to_glib_none().0, height);
        }
    }

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn set_layout_manager(&self, manager: /*Ignored*/Option<&LayoutManager>) {
    //    unsafe { TODO: call ffi:clutter_actor_set_layout_manager() }
    //}

    //#[cfg(any(feature = "v1_10", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    //fn set_margin(&self, margin: /*Ignored*/&Margin) {
    //    unsafe { TODO: call ffi:clutter_actor_set_margin() }
    //}

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_margin_bottom(&self, margin: f32) {
        unsafe {
            ffi::clutter_actor_set_margin_bottom(self.as_ref().to_glib_none().0, margin);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_margin_left(&self, margin: f32) {
        unsafe {
            ffi::clutter_actor_set_margin_left(self.as_ref().to_glib_none().0, margin);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_margin_right(&self, margin: f32) {
        unsafe {
            ffi::clutter_actor_set_margin_right(self.as_ref().to_glib_none().0, margin);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_margin_top(&self, margin: f32) {
        unsafe {
            ffi::clutter_actor_set_margin_top(self.as_ref().to_glib_none().0, margin);
        }
    }

    fn set_name(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_set_name(self.as_ref().to_glib_none().0, name.to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v1_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    //fn set_offscreen_redirect(&self, redirect: /*Ignored*/OffscreenRedirect) {
    //    unsafe { TODO: call ffi:clutter_actor_set_offscreen_redirect() }
    //}

    fn set_opacity(&self, opacity: u8) {
        unsafe {
            ffi::clutter_actor_set_opacity(self.as_ref().to_glib_none().0, opacity);
        }
    }

    fn set_opacity_override(&self, opacity: i32) {
        unsafe {
            ffi::clutter_actor_set_opacity_override(self.as_ref().to_glib_none().0, opacity);
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_pivot_point(&self, pivot_x: f32, pivot_y: f32) {
        unsafe {
            ffi::clutter_actor_set_pivot_point(self.as_ref().to_glib_none().0, pivot_x, pivot_y);
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_pivot_point_z(&self, pivot_z: f32) {
        unsafe {
            ffi::clutter_actor_set_pivot_point_z(self.as_ref().to_glib_none().0, pivot_z);
        }
    }

    fn set_position(&self, x: f32, y: f32) {
        unsafe {
            ffi::clutter_actor_set_position(self.as_ref().to_glib_none().0, x, y);
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn set_reactive(&self, reactive: bool) {
        unsafe {
            ffi::clutter_actor_set_reactive(self.as_ref().to_glib_none().0, reactive.into_glib());
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn set_request_mode(&self, mode: RequestMode) {
        unsafe {
            ffi::clutter_actor_set_request_mode(self.as_ref().to_glib_none().0, mode.into_glib());
        }
    }

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn set_rotation_angle(&self, axis: /*Ignored*/RotateAxis, angle: f64) {
    //    unsafe { TODO: call ffi:clutter_actor_set_rotation_angle() }
    //}

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn set_scale(&self, scale_x: f64, scale_y: f64) {
        unsafe {
            ffi::clutter_actor_set_scale(self.as_ref().to_glib_none().0, scale_x, scale_y);
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_scale_z(&self, scale_z: f64) {
        unsafe {
            ffi::clutter_actor_set_scale_z(self.as_ref().to_glib_none().0, scale_z);
        }
    }

    fn set_size(&self, width: f32, height: f32) {
        unsafe {
            ffi::clutter_actor_set_size(self.as_ref().to_glib_none().0, width, height);
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn set_text_direction(&self, text_dir: TextDirection) {
        unsafe {
            ffi::clutter_actor_set_text_direction(self.as_ref().to_glib_none().0, text_dir.into_glib());
        }
    }

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn set_transform(&self, transform: /*Ignored*/Option<&graphene::Matrix>) {
    //    unsafe { TODO: call ffi:clutter_actor_set_transform() }
    //}

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_translation(&self, translate_x: f32, translate_y: f32, translate_z: f32) {
        unsafe {
            ffi::clutter_actor_set_translation(self.as_ref().to_glib_none().0, translate_x, translate_y, translate_z);
        }
    }

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn set_width(&self, width: f32) {
        unsafe {
            ffi::clutter_actor_set_width(self.as_ref().to_glib_none().0, width);
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn set_x(&self, x: f32) {
        unsafe {
            ffi::clutter_actor_set_x(self.as_ref().to_glib_none().0, x);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_x_align(&self, x_align: ActorAlign) {
        unsafe {
            ffi::clutter_actor_set_x_align(self.as_ref().to_glib_none().0, x_align.into_glib());
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_x_expand(&self, expand: bool) {
        unsafe {
            ffi::clutter_actor_set_x_expand(self.as_ref().to_glib_none().0, expand.into_glib());
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn set_y(&self, y: f32) {
        unsafe {
            ffi::clutter_actor_set_y(self.as_ref().to_glib_none().0, y);
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn set_y_align(&self, y_align: ActorAlign) {
        unsafe {
            ffi::clutter_actor_set_y_align(self.as_ref().to_glib_none().0, y_align.into_glib());
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_y_expand(&self, expand: bool) {
        unsafe {
            ffi::clutter_actor_set_y_expand(self.as_ref().to_glib_none().0, expand.into_glib());
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_z_position(&self, z_position: f32) {
        unsafe {
            ffi::clutter_actor_set_z_position(self.as_ref().to_glib_none().0, z_position);
        }
    }

    //fn should_pick(&self, pick_context: /*Ignored*/&PickContext) -> bool {
    //    unsafe { TODO: call ffi:clutter_actor_should_pick() }
    //}

    fn show(&self) {
        unsafe {
            ffi::clutter_actor_show(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn transform_stage_point(&self, x: f32, y: f32) -> Option<(f32, f32)> {
        unsafe {
            let mut x_out = mem::MaybeUninit::uninit();
            let mut y_out = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::clutter_actor_transform_stage_point(self.as_ref().to_glib_none().0, x, y, x_out.as_mut_ptr(), y_out.as_mut_ptr()));
            let x_out = x_out.assume_init();
            let y_out = y_out.assume_init();
            if ret { Some((x_out, y_out)) } else { None }
        }
    }

    fn uninhibit_culling(&self) {
        unsafe {
            ffi::clutter_actor_uninhibit_culling(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn unmap(&self) {
        unsafe {
            ffi::clutter_actor_unmap(self.as_ref().to_glib_none().0);
        }
    }

    fn unrealize(&self) {
        unsafe {
            ffi::clutter_actor_unrealize(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn unset_flags(&self, flags: ActorFlags) {
        unsafe {
            ffi::clutter_actor_unset_flags(self.as_ref().to_glib_none().0, flags.into_glib());
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn set_actions<P: IsA<Action>>(&self, actions: Option<&P>) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"actions\0".as_ptr() as *const _, actions.to_value().to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v0_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    //fn allocation(&self) -> /*Ignored*/Option<ActorBox> {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"allocation\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `allocation` getter")
    //    }
    //}

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn is_background_color_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"background-color-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `background-color-set` getter")
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn is_child_transform_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"child-transform-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `child-transform-set` getter")
        }
    }

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn clip_rect(&self) -> /*Ignored*/Option<graphene::Rect> {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"clip-rect\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `clip-rect` getter")
    //    }
    //}

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn set_clip_rect(&self, clip_rect: /*Ignored*/Option<&graphene::Rect>) {
    //    unsafe {
    //        glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"clip-rect\0".as_ptr() as *const _, clip_rect.to_value().to_glib_none().0);
    //    }
    //}

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn get_property_clip_to_allocation(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"clip-to-allocation\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `clip-to-allocation` getter")
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn set_property_clip_to_allocation(&self, clip_to_allocation: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"clip-to-allocation\0".as_ptr() as *const _, clip_to_allocation.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn set_constraints<P: IsA<Constraint>>(&self, constraints: Option<&P>) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"constraints\0".as_ptr() as *const _, constraints.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn set_effect<P: IsA<Effect>>(&self, effect: Option<&P>) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"effect\0".as_ptr() as *const _, effect.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn fixed_x(&self) -> f32 {
        unsafe {
            let mut value = glib::Value::from_type(<f32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"fixed-x\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `fixed-x` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_fixed_x(&self, fixed_x: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"fixed-x\0".as_ptr() as *const _, fixed_x.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn fixed_y(&self) -> f32 {
        unsafe {
            let mut value = glib::Value::from_type(<f32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"fixed-y\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `fixed-y` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_fixed_y(&self, fixed_y: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"fixed-y\0".as_ptr() as *const _, fixed_y.to_value().to_glib_none().0);
        }
    }

    fn get_property_has_clip(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"has-clip\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `has-clip` getter")
        }
    }

    fn set_property_height(&self, height: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"height\0".as_ptr() as *const _, height.to_value().to_glib_none().0);
        }
    }

    //fn magnification_filter(&self) -> /*Ignored*/ScalingFilter {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"magnification-filter\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `magnification-filter` getter")
    //    }
    //}

    //fn set_magnification_filter(&self, magnification_filter: /*Ignored*/ScalingFilter) {
    //    unsafe {
    //        glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"magnification-filter\0".as_ptr() as *const _, magnification_filter.to_value().to_glib_none().0);
    //    }
    //}

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn get_property_mapped(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"mapped\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `mapped` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn min_height(&self) -> f32 {
        unsafe {
            let mut value = glib::Value::from_type(<f32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"min-height\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `min-height` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_min_height(&self, min_height: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"min-height\0".as_ptr() as *const _, min_height.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn is_min_height_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"min-height-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `min-height-set` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_min_height_set(&self, min_height_set: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"min-height-set\0".as_ptr() as *const _, min_height_set.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn min_width(&self) -> f32 {
        unsafe {
            let mut value = glib::Value::from_type(<f32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"min-width\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `min-width` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_min_width(&self, min_width: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"min-width\0".as_ptr() as *const _, min_width.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn is_min_width_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"min-width-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `min-width-set` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_min_width_set(&self, min_width_set: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"min-width-set\0".as_ptr() as *const _, min_width_set.to_value().to_glib_none().0);
        }
    }

    //fn minification_filter(&self) -> /*Ignored*/ScalingFilter {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"minification-filter\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `minification-filter` getter")
    //    }
    //}

    //fn set_minification_filter(&self, minification_filter: /*Ignored*/ScalingFilter) {
    //    unsafe {
    //        glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"minification-filter\0".as_ptr() as *const _, minification_filter.to_value().to_glib_none().0);
    //    }
    //}

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn natural_height(&self) -> f32 {
        unsafe {
            let mut value = glib::Value::from_type(<f32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"natural-height\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `natural-height` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_natural_height(&self, natural_height: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"natural-height\0".as_ptr() as *const _, natural_height.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn is_natural_height_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"natural-height-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `natural-height-set` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_natural_height_set(&self, natural_height_set: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"natural-height-set\0".as_ptr() as *const _, natural_height_set.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn natural_width(&self) -> f32 {
        unsafe {
            let mut value = glib::Value::from_type(<f32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"natural-width\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `natural-width` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_natural_width(&self, natural_width: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"natural-width\0".as_ptr() as *const _, natural_width.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn is_natural_width_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"natural-width-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `natural-width-set` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_natural_width_set(&self, natural_width_set: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"natural-width-set\0".as_ptr() as *const _, natural_width_set.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn get_property_realized(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"realized\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `realized` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn get_property_request_mode(&self) -> RequestMode {
        unsafe {
            let mut value = glib::Value::from_type(<RequestMode as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"request-mode\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `request-mode` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_property_request_mode(&self, request_mode: RequestMode) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"request-mode\0".as_ptr() as *const _, request_mode.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn rotation_angle_x(&self) -> f64 {
        unsafe {
            let mut value = glib::Value::from_type(<f64 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"rotation-angle-x\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `rotation-angle-x` getter")
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn set_rotation_angle_x(&self, rotation_angle_x: f64) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"rotation-angle-x\0".as_ptr() as *const _, rotation_angle_x.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn rotation_angle_y(&self) -> f64 {
        unsafe {
            let mut value = glib::Value::from_type(<f64 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"rotation-angle-y\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `rotation-angle-y` getter")
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn set_rotation_angle_y(&self, rotation_angle_y: f64) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"rotation-angle-y\0".as_ptr() as *const _, rotation_angle_y.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn rotation_angle_z(&self) -> f64 {
        unsafe {
            let mut value = glib::Value::from_type(<f64 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"rotation-angle-z\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `rotation-angle-z` getter")
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn set_rotation_angle_z(&self, rotation_angle_z: f64) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"rotation-angle-z\0".as_ptr() as *const _, rotation_angle_z.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn scale_x(&self) -> f64 {
        unsafe {
            let mut value = glib::Value::from_type(<f64 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"scale-x\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `scale-x` getter")
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn set_scale_x(&self, scale_x: f64) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"scale-x\0".as_ptr() as *const _, scale_x.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn scale_y(&self) -> f64 {
        unsafe {
            let mut value = glib::Value::from_type(<f64 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"scale-y\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `scale-y` getter")
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn set_scale_y(&self, scale_y: f64) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"scale-y\0".as_ptr() as *const _, scale_y.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn shows_on_set_parent(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"show-on-set-parent\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `show-on-set-parent` getter")
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn set_show_on_set_parent(&self, show_on_set_parent: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"show-on-set-parent\0".as_ptr() as *const _, show_on_set_parent.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn get_property_text_direction(&self) -> TextDirection {
        unsafe {
            let mut value = glib::Value::from_type(<TextDirection as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"text-direction\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `text-direction` getter")
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn set_property_text_direction(&self, text_direction: TextDirection) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"text-direction\0".as_ptr() as *const _, text_direction.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn is_transform_set(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"transform-set\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `transform-set` getter")
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn translation_x(&self) -> f32 {
        unsafe {
            let mut value = glib::Value::from_type(<f32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"translation-x\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `translation-x` getter")
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_translation_x(&self, translation_x: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"translation-x\0".as_ptr() as *const _, translation_x.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn translation_y(&self) -> f32 {
        unsafe {
            let mut value = glib::Value::from_type(<f32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"translation-y\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `translation-y` getter")
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_translation_y(&self, translation_y: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"translation-y\0".as_ptr() as *const _, translation_y.to_value().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn translation_z(&self) -> f32 {
        unsafe {
            let mut value = glib::Value::from_type(<f32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"translation-z\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `translation-z` getter")
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn set_translation_z(&self, translation_z: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"translation-z\0".as_ptr() as *const _, translation_z.to_value().to_glib_none().0);
        }
    }

    fn get_property_visible(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"visible\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `visible` getter")
        }
    }

    fn set_visible(&self, visible: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"visible\0".as_ptr() as *const _, visible.to_value().to_glib_none().0);
        }
    }

    fn set_property_width(&self, width: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"width\0".as_ptr() as *const _, width.to_value().to_glib_none().0);
        }
    }

    fn set_property_x(&self, x: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"x\0".as_ptr() as *const _, x.to_value().to_glib_none().0);
        }
    }

    fn set_property_y(&self, y: f32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"y\0".as_ptr() as *const _, y.to_value().to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn connect_button_press_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored event: Clutter.ButtonEvent
    //}

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn connect_button_release_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored event: Clutter.ButtonEvent
    //}

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn connect_captured_event<Unsupported or ignored types>(&self, detail: Option<&str>, f: F) -> SignalHandlerId {
    //    Ignored event: Clutter.Event
    //}

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn connect_destroy<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn destroy_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"destroy\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(destroy_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn connect_enter_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored event: Clutter.CrossingEvent
    //}

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn connect_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored event: Clutter.Event
    //}

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn connect_hide<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn hide_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"hide\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(hide_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_key_focus_in<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn key_focus_in_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"key-focus-in\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(key_focus_in_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_key_focus_out<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn key_focus_out_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"key-focus-out\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(key_focus_out_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_key_press_event<F: Fn(&Self, &KeyEvent) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn key_press_event_trampoline<P: IsA<Actor>, F: Fn(&P, &KeyEvent) -> bool + 'static>(this: *mut ffi::ClutterActor, event: *mut ffi::ClutterKeyEvent, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(event)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"key-press-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(key_press_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_key_release_event<F: Fn(&Self, &KeyEvent) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn key_release_event_trampoline<P: IsA<Actor>, F: Fn(&P, &KeyEvent) -> bool + 'static>(this: *mut ffi::ClutterActor, event: *mut ffi::ClutterKeyEvent, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(event)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"key-release-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(key_release_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn connect_leave_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored event: Clutter.CrossingEvent
    //}

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn connect_motion_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored event: Clutter.MotionEvent
    //}

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn connect_parent_set<F: Fn(&Self, Option<&Actor>) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn parent_set_trampoline<P: IsA<Actor>, F: Fn(&P, Option<&Actor>) + 'static>(this: *mut ffi::ClutterActor, old_parent: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref(), Option::<Actor>::from_glib_borrow(old_parent).as_ref().as_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"parent-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(parent_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v1_0", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    //fn connect_pick<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored pick_context: Clutter.PickContext
    //}

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn connect_queue_relayout<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn queue_relayout_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"queue-relayout\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(queue_relayout_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_realize<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn realize_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"realize\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(realize_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_resource_scale_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn resource_scale_changed_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"resource-scale-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(resource_scale_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v0_6", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    //fn connect_scroll_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored event: Clutter.ScrollEvent
    //}

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn connect_show<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_stage_views_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn stage_views_changed_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"stage-views-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(stage_views_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v1_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    //fn connect_touch_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored event: Clutter.Event
    //}

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_transition_stopped<F: Fn(&Self, &str, bool) + 'static>(&self, detail: Option<&str>, f: F) -> SignalHandlerId {
        unsafe extern "C" fn transition_stopped_trampoline<P: IsA<Actor>, F: Fn(&P, &str, bool) + 'static>(this: *mut ffi::ClutterActor, name: *mut libc::c_char, is_finished: glib::ffi::gboolean, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref(), &glib::GString::from_glib_borrow(name), from_glib(is_finished))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            let detailed_signal_name = detail.map(|name| { format!("transition-stopped::{}\0", name) });
            let signal_name: &[u8] = detailed_signal_name.as_ref().map_or(&b"transition-stopped\0"[..], |n| n.as_bytes());
            connect_raw(self.as_ptr() as *mut _, signal_name.as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(transition_stopped_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_transitions_completed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn transitions_completed_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"transitions-completed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(transitions_completed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_unrealize<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn unrealize_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"unrealize\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(unrealize_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn connect_actions_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_actions_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::actions\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_actions_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_allocation_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_allocation_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::allocation\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_allocation_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_background_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_background_color_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::background-color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_background_color_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_background_color_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_background_color_set_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::background-color-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_background_color_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_child_transform_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_child_transform_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::child-transform\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_child_transform_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_child_transform_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_child_transform_set_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::child-transform-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_child_transform_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_clip_rect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_clip_rect_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::clip-rect\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_clip_rect_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_clip_to_allocation_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_clip_to_allocation_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::clip-to-allocation\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_clip_to_allocation_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn connect_constraints_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_constraints_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::constraints\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_constraints_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_content_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_content_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::content\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_content_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_content_box_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_content_box_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::content-box\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_content_box_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_content_gravity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_content_gravity_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::content-gravity\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_content_gravity_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_content_repeat_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_content_repeat_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::content-repeat\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_content_repeat_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    fn connect_effect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_effect_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::effect\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_effect_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_first_child_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_first_child_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::first-child\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_first_child_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_fixed_position_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_fixed_position_set_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::fixed-position-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_fixed_position_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_fixed_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_fixed_x_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::fixed-x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_fixed_x_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_fixed_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_fixed_y_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::fixed-y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_fixed_y_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_has_clip_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_has_clip_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::has-clip\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_has_clip_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn connect_has_pointer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_has_pointer_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::has-pointer\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_has_pointer_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_height_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::height\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_height_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_last_child_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_last_child_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::last-child\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_last_child_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_layout_manager_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_layout_manager_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::layout-manager\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_layout_manager_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_magnification_filter_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_magnification_filter_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::magnification-filter\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_magnification_filter_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_mapped_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mapped_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::mapped\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_mapped_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_margin_bottom_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_margin_bottom_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::margin-bottom\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_margin_bottom_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_margin_left_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_margin_left_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::margin-left\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_margin_left_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_margin_right_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_margin_right_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::margin-right\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_margin_right_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_margin_top_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_margin_top_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::margin-top\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_margin_top_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_min_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_min_height_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::min-height\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_min_height_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_min_height_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_min_height_set_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::min-height-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_min_height_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_min_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_min_width_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::min-width\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_min_width_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_min_width_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_min_width_set_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::min-width-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_min_width_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_minification_filter_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_minification_filter_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::minification-filter\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_minification_filter_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_2")))]
    fn connect_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_name_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::name\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_natural_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_natural_height_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::natural-height\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_natural_height_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_natural_height_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_natural_height_set_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::natural-height-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_natural_height_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_natural_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_natural_width_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::natural-width\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_natural_width_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_natural_width_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_natural_width_set_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::natural-width-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_natural_width_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    fn connect_offscreen_redirect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_offscreen_redirect_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::offscreen-redirect\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_offscreen_redirect_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_opacity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_opacity_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::opacity\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_opacity_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_pivot_point_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pivot_point_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::pivot-point\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_pivot_point_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_pivot_point_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pivot_point_z_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::pivot-point-z\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_pivot_point_z_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_position_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::position\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_position_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_reactive_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_reactive_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::reactive\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_reactive_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_realized_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_realized_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::realized\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_realized_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_request_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_request_mode_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::request-mode\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_request_mode_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_rotation_angle_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_rotation_angle_x_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::rotation-angle-x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_rotation_angle_x_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_rotation_angle_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_rotation_angle_y_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::rotation-angle-y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_rotation_angle_y_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_rotation_angle_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_rotation_angle_z_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::rotation-angle-z\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_rotation_angle_z_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_scale_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_scale_x_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::scale-x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_scale_x_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_6")))]
    fn connect_scale_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_scale_y_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::scale-y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_scale_y_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_scale_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_scale_z_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::scale-z\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_scale_z_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8")))]
    fn connect_show_on_set_parent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_show_on_set_parent_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::show-on-set-parent\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_show_on_set_parent_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_size_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::size\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_size_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_0")))]
    fn connect_text_direction_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_text_direction_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::text-direction\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_text_direction_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_transform_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_transform_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::transform\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_transform_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_transform_set_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_transform_set_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::transform-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_transform_set_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_translation_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_translation_x_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::translation-x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_translation_x_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_translation_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_translation_y_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::translation-y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_translation_y_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_translation_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_translation_z_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::translation-z\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_translation_z_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_visible_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_visible_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::visible\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_visible_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_width_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::width\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_width_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_x_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_x_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_x_align_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_x_align_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::x-align\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_x_align_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_x_expand_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_x_expand_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::x-expand\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_x_expand_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_y_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_y_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    fn connect_y_align_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_y_align_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::y-align\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_y_align_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_y_expand_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_y_expand_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::y-expand\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_y_expand_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v1_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    fn connect_z_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_z_position_trampoline<P: IsA<Actor>, F: Fn(&P) + 'static>(this: *mut ffi::ClutterActor, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::z-position\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_z_position_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Actor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Actor")
    }
}
